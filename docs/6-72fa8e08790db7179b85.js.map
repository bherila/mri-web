{"version":3,"sources":["webpack:///./src/api/api.ts"],"names":["BASE_PATH","replace","BaseAPI","fetch","basePath","isomorphic_fetch__WEBPACK_IMPORTED_MODULE_4__","this","AuthApiFp","params","options","fetchArgs","urlObj","url__WEBPACK_IMPORTED_MODULE_3__","parse","query","core_js_library_fn_object_assign__WEBPACK_IMPORTED_MODULE_5__","authToken","contentTypeHeader","fetchOptions","method","Content-Type","req","body","JSON","stringify","headers","url","format","AuthApiFetchParamCreator","then","response","status","json","AuthApi","_BaseAPI","apply","arguments","_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default","prototype","auth","LeadGenApiFp","LeadGenApiFetchParamCreator","LeadGenApi","_BaseAPI2","_proto2","runGET","runPOST","QuestionApiFp","QuestionApiFetchParamCreator","QuestionApi","_BaseAPI4","getQuestions","ResourceApiFp","ResourceApiFetchParamCreator","locationId","ResourceApi","_BaseAPI5","_proto5","availabilityRulesDELETE","availabilityRulesGET","availabilityRulesPOST","availabilityRulesPUT","locationsGET","locationsPOST","ScheduleApiFp","withContrast","search","ScheduleApiFetchParamCreator","notifyAdmin","length","skip","ScheduleApi","_BaseAPI6","_proto6","appointmentHandlerDELETE","appointmentHandlerGET","appointmentHandlerPOST","appointmentHandlerPUT","appointmentRefDELETE","appointmentRefGET","sendConfirmationEmailPOST","serviceTypesGET","timeSlotsGET"],"mappings":"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","file":"6-72fa8e08790db7179b85.js","sourcesContent":["/**\n * ideal MRI\n * Signup Center API\n *\n * OpenAPI spec version: v1\n * Contact: ben@herila.net\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\nimport * as querystring from \"querystring\";\nimport * as url from \"url\";\n\nimport * as isomorphicFetch from \"isomorphic-fetch\";\nimport * as assign from \"core-js/library/fn/object/assign\";\n\ninterface Dictionary<T> { [index: string]: T; }\nexport interface FetchAPI { (url: string, init?: any): Promise<any>; }\n\nexport const BASE_PATH = \"https://mrisched.azurewebsites.net\".replace(/\\/+$/, \"\");\n\nexport interface FetchArgs {\n    url: string;\n    options: any;\n}\n\nexport class BaseAPI {\n    basePath: string;\n    fetch: FetchAPI;\n\n    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {\n        this.basePath = basePath;\n        this.fetch = fetch;\n    }\n};\n\nexport interface ApiResultAppointment {\n    \"value\"?: Appointment;\n    \"success\"?: boolean;\n    \"message\"?: string;\n    \"stackTrace\"?: Array<Stack>;\n}\n\nexport interface ApiResultListAppointment {\n    \"value\"?: Array<Appointment>;\n    \"success\"?: boolean;\n    \"message\"?: string;\n    \"stackTrace\"?: Array<Stack>;\n}\n\nexport interface ApiResultListAvailabilityRule {\n    \"value\"?: Array<AvailabilityRule>;\n    \"success\"?: boolean;\n    \"message\"?: string;\n    \"stackTrace\"?: Array<Stack>;\n}\n\nexport interface ApiResultListServiceType {\n    \"value\"?: Array<ServiceType>;\n    \"success\"?: boolean;\n    \"message\"?: string;\n    \"stackTrace\"?: Array<Stack>;\n}\n\nexport interface ApiResultListSlotAvailabilityDate {\n    \"value\"?: Array<SlotAvailabilityDate>;\n    \"success\"?: boolean;\n    \"message\"?: string;\n    \"stackTrace\"?: Array<Stack>;\n}\n\nexport interface Appointment {\n    \"resourceId\"?: string;\n    \"appointmentGuid\"?: string;\n    \"serviceType\"?: string;\n    \"serviceLength\"?: number;\n    \"firstName\"?: string;\n    \"lastName\"?: string;\n    \"phone\"?: string;\n    \"email\"?: string;\n    \"address1\"?: string;\n    \"address2\"?: string;\n    \"city\"?: string;\n    \"state\"?: string;\n    \"zip\"?: string;\n    \"height\"?: string;\n    \"weight\"?: string;\n    \"reminder\"?: number;\n    \"doctorName\"?: string;\n    \"doctorPhone\"?: string;\n    \"insuranceCarrier\"?: string;\n    \"insuranceGroupNumber\"?: string;\n    \"insurancePolicyNumber\"?: string;\n    \"insuranceVerified\"?: boolean;\n    \"priorAuthObtained\"?: boolean;\n    \"orderEnteredToRIS\"?: boolean;\n    \"patientWasCalled\"?: boolean;\n    \"confirmed\"?: boolean;\n    \"safetyWarnings\"?: string;\n    \"orderImageUrl\"?: string;\n    \"insuranceFrontUrl\"?: string;\n    \"insuranceBackUrl\"?: string;\n    \"surveyDataJson\"?: string;\n    \"approvedDate\"?: Date;\n    \"submittedDate\"?: Date;\n    \"confirmedDate\"?: Date;\n    \"birthday\"?: string;\n    \"partitionKey\"?: string;\n    \"rowKey\"?: string;\n    \"timestamp\"?: Date;\n    \"eTag\"?: string;\n}\n\nexport interface AvailabilityRule {\n    \"priority\"?: number;\n    \"resourceID\"?: string;\n    \"onThisDay\"?: string;\n    \"startTime\"?: string;\n    \"endTime\"?: string;\n    \"comment\"?: string;\n    \"status\"?: string;\n    \"partitionKey\"?: string;\n    \"rowKey\"?: string;\n    \"timestamp\"?: Date;\n    \"eTag\"?: string;\n}\n\nexport interface CustomerLead {\n    \"firstName\"?: string;\n    \"lastName\"?: string;\n    \"dob\"?: string;\n    \"phone\"?: string;\n    \"email\"?: string;\n    \"serviceType\"?: string;\n    \"timeSlot\"?: string;\n    \"withContrast\"?: boolean;\n    \"partitionKey\"?: string;\n    \"rowKey\"?: string;\n    \"timestamp\"?: Date;\n    \"eTag\"?: string;\n}\n\nexport interface Location {\n    \"partitionKey\"?: string;\n    \"rowKey\"?: string;\n    \"timestamp\"?: Date;\n    \"eTag\"?: string;\n}\n\nexport interface ServiceType {\n    \"name\"?: string;\n    \"contrast\"?: string;\n    \"name2\"?: string;\n    \"name3\"?: string;\n    \"name4\"?: string;\n    \"time\"?: number;\n}\n\nexport interface SlotAvailabilityDate {\n    \"date\"?: Date;\n    \"friendlyBegin\"?: string;\n    \"times\"?: Array<SlotAvailabilityTime>;\n    \"isTomorrow\"?: boolean;\n}\n\nexport interface SlotAvailabilityTime {\n    \"time\"?: string;\n    \"resourceId\"?: string;\n    \"isHidden\"?: boolean;\n    \"isAvailable\"?: boolean;\n    \"isContrastAvailable\"?: boolean;\n    \"isContrastRequired\"?: boolean;\n    \"linkedAppointment\"?: Appointment;\n    \"slotId\"?: string;\n}\n\nexport interface Stack {\n    \"in\"?: string;\n    \"at\"?: string;\n}\n\nexport interface SurveyQuestion {\n    \"questionId\"?: string;\n    \"questionShowIf\"?: string;\n    \"questionShowIfAnswer\"?: string;\n    \"questionText\"?: string;\n    \"questionType\"?: string;\n    \"isRequired\"?: boolean;\n    \"isHidden\"?: boolean;\n    \"order\"?: number;\n    \"partitionKey\"?: string;\n    \"rowKey\"?: string;\n    \"timestamp\"?: Date;\n    \"eTag\"?: string;\n}\n\nexport interface TableResult {\n    \"result\"?: any;\n    \"httpStatusCode\"?: number;\n    \"etag\"?: string;\n}\n\nexport interface User {\n    \"apiKey\"?: string;\n    \"immutableId\"?: string;\n    \"referenceRowKey\"?: string;\n    \"partitionKey\"?: string;\n    \"rowKey\"?: string;\n    \"timestamp\"?: Date;\n    \"eTag\"?: string;\n}\n\n\n\n/**\n * AuthApi - fetch parameter creator\n */\nexport const AuthApiFetchParamCreator = {\n    /**\n     *\n     * @summary Auth\n     * @param req\n     * @param authToken\n     */\n    auth(params: {  \"req\"?: User; \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/auth`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"POST\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n};\n\n/**\n * AuthApi - functional programming interface\n */\nexport const AuthApiFp = {\n    /**\n     *\n     * @summary Auth\n     * @param req\n     * @param authToken\n     */\n    auth(params: { \"req\"?: User; \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {\n        const fetchArgs = AuthApiFetchParamCreator.auth(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n};\n\n/**\n * AuthApi - object-oriented interface\n */\nexport class AuthApi extends BaseAPI {\n    /**\n     *\n     * @summary Auth\n     * @param req\n     * @param authToken\n     */\n    auth(params: {  \"req\"?: User; \"authToken\"?: string; }, options?: any) {\n        return AuthApiFp.auth(params, options)(this.fetch, this.basePath);\n    }\n};\n\n/**\n * AuthApi - factory interface\n */\nexport const AuthApiFactory = function (fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         *\n         * @summary Auth\n         * @param req\n         * @param authToken\n         */\n        auth(params: {  \"req\"?: User; \"authToken\"?: string; }, options?: any) {\n            return AuthApiFp.auth(params, options)(fetch, basePath);\n        },\n    };\n};\n\n\n/**\n * LeadGenApi - fetch parameter creator\n */\nexport const LeadGenApiFetchParamCreator = {\n    /**\n     *\n     * @summary Run\n     * @param req\n     * @param authToken\n     */\n    runGET(params: {  \"req\"?: CustomerLead; \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/leadGen`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"GET\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary Run\n     * @param req\n     * @param authToken\n     */\n    runPOST(params: {  \"req\"?: CustomerLead; \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/leadGen`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"POST\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n};\n\n/**\n * LeadGenApi - functional programming interface\n */\nexport const LeadGenApiFp = {\n    /**\n     *\n     * @summary Run\n     * @param req\n     * @param authToken\n     */\n    runGET(params: { \"req\"?: CustomerLead; \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerLead> {\n        const fetchArgs = LeadGenApiFetchParamCreator.runGET(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary Run\n     * @param req\n     * @param authToken\n     */\n    runPOST(params: { \"req\"?: CustomerLead; \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerLead> {\n        const fetchArgs = LeadGenApiFetchParamCreator.runPOST(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n};\n\n/**\n * LeadGenApi - object-oriented interface\n */\nexport class LeadGenApi extends BaseAPI {\n    /**\n     *\n     * @summary Run\n     * @param req\n     * @param authToken\n     */\n    runGET(params: {  \"req\"?: CustomerLead; \"authToken\"?: string; }, options?: any) {\n        return LeadGenApiFp.runGET(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary Run\n     * @param req\n     * @param authToken\n     */\n    runPOST(params: {  \"req\"?: CustomerLead; \"authToken\"?: string; }, options?: any) {\n        return LeadGenApiFp.runPOST(params, options)(this.fetch, this.basePath);\n    }\n};\n\n/**\n * LeadGenApi - factory interface\n */\nexport const LeadGenApiFactory = function (fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         *\n         * @summary Run\n         * @param req\n         * @param authToken\n         */\n        runGET(params: {  \"req\"?: CustomerLead; \"authToken\"?: string; }, options?: any) {\n            return LeadGenApiFp.runGET(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary Run\n         * @param req\n         * @param authToken\n         */\n        runPOST(params: {  \"req\"?: CustomerLead; \"authToken\"?: string; }, options?: any) {\n            return LeadGenApiFp.runPOST(params, options)(fetch, basePath);\n        },\n    };\n};\n\n\n/**\n * PostQuestionApi - fetch parameter creator\n */\nexport const PostQuestionApiFetchParamCreator = {\n    /**\n     *\n     * @summary GetQuestions\n     * @param req\n     */\n    postQuestion(params: {  \"req\"?: SurveyQuestion; }, options?: any): FetchArgs {\n        const baseUrl = `/api/question`;\n        let urlObj = url.parse(baseUrl, true);\n        let fetchOptions: RequestInit = assign({}, { method: \"POST\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n};\n\n/**\n * PostQuestionApi - functional programming interface\n */\nexport const PostQuestionApiFp = {\n    /**\n     *\n     * @summary GetQuestions\n     * @param req\n     */\n    postQuestion(params: { \"req\"?: SurveyQuestion;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TableResult> {\n        const fetchArgs = PostQuestionApiFetchParamCreator.postQuestion(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n};\n\n/**\n * PostQuestionApi - object-oriented interface\n */\nexport class PostQuestionApi extends BaseAPI {\n    /**\n     *\n     * @summary GetQuestions\n     * @param req\n     */\n    postQuestion(params: {  \"req\"?: SurveyQuestion; }, options?: any) {\n        return PostQuestionApiFp.postQuestion(params, options)(this.fetch, this.basePath);\n    }\n};\n\n/**\n * PostQuestionApi - factory interface\n */\nexport const PostQuestionApiFactory = function (fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         *\n         * @summary GetQuestions\n         * @param req\n         */\n        postQuestion(params: {  \"req\"?: SurveyQuestion; }, options?: any) {\n            return PostQuestionApiFp.postQuestion(params, options)(fetch, basePath);\n        },\n    };\n};\n\n\n/**\n * QuestionApi - fetch parameter creator\n */\nexport const QuestionApiFetchParamCreator = {\n    /**\n     *\n     * @summary GetQuestions\n     */\n    getQuestions(options?: any): FetchArgs {\n        const baseUrl = `/api/question`;\n        let urlObj = url.parse(baseUrl, true);\n        let fetchOptions: RequestInit = assign({}, { method: \"GET\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n};\n\n/**\n * QuestionApi - functional programming interface\n */\nexport const QuestionApiFp = {\n    /**\n     *\n     * @summary GetQuestions\n     */\n    getQuestions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SurveyQuestion>> {\n        const fetchArgs = QuestionApiFetchParamCreator.getQuestions(options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n};\n\n/**\n * QuestionApi - object-oriented interface\n */\nexport class QuestionApi extends BaseAPI {\n    /**\n     *\n     * @summary GetQuestions\n     */\n    getQuestions(options?: any) {\n        return QuestionApiFp.getQuestions(options)(this.fetch, this.basePath);\n    }\n};\n\n/**\n * QuestionApi - factory interface\n */\nexport const QuestionApiFactory = function (fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         *\n         * @summary GetQuestions\n         */\n        getQuestions(options?: any) {\n            return QuestionApiFp.getQuestions(options)(fetch, basePath);\n        },\n    };\n};\n\n\n/**\n * ResourceApi - fetch parameter creator\n */\nexport const ResourceApiFetchParamCreator = {\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesDELETE(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/timeslot/rules`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"DELETE\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param authToken\n     */\n    availabilityRulesGET(params: {  \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/timeslot/rules`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"GET\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesPOST(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/timeslot/rules`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"POST\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesPUT(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/timeslot/rules`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"PUT\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary Locations\n     * @param locationId\n     * @param authToken\n     */\n    locationsGET(params: {  \"locationId\"?: string; \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/locations`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"locationId\": params[\"locationId\"],\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"GET\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary Locations\n     * @param locationId\n     * @param authToken\n     */\n    locationsPOST(params: {  \"locationId\"?: string; \"authToken\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/locations`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"locationId\": params[\"locationId\"],\n            \"authToken\": params[\"authToken\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"POST\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n};\n\n/**\n * ResourceApi - functional programming interface\n */\nexport const ResourceApiFp = {\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesDELETE(params: { \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAvailabilityRule> {\n        const fetchArgs = ResourceApiFetchParamCreator.availabilityRulesDELETE(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param authToken\n     */\n    availabilityRulesGET(params: { \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAvailabilityRule> {\n        const fetchArgs = ResourceApiFetchParamCreator.availabilityRulesGET(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesPOST(params: { \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAvailabilityRule> {\n        const fetchArgs = ResourceApiFetchParamCreator.availabilityRulesPOST(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesPUT(params: { \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAvailabilityRule> {\n        const fetchArgs = ResourceApiFetchParamCreator.availabilityRulesPUT(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary Locations\n     * @param locationId\n     * @param authToken\n     */\n    locationsGET(params: { \"locationId\"?: string; \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Location>> {\n        const fetchArgs = ResourceApiFetchParamCreator.locationsGET(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary Locations\n     * @param locationId\n     * @param authToken\n     */\n    locationsPOST(params: { \"locationId\"?: string; \"authToken\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Location>> {\n        const fetchArgs = ResourceApiFetchParamCreator.locationsPOST(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n};\n\n/**\n * ResourceApi - object-oriented interface\n */\nexport class ResourceApi extends BaseAPI {\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesDELETE(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any) {\n        return ResourceApiFp.availabilityRulesDELETE(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param authToken\n     */\n    availabilityRulesGET(params: {  \"authToken\"?: string; }, options?: any) {\n        return ResourceApiFp.availabilityRulesGET(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesPOST(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any) {\n        return ResourceApiFp.availabilityRulesPOST(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary AvailabilityRules\n     * @param req\n     * @param authToken\n     */\n    availabilityRulesPUT(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any) {\n        return ResourceApiFp.availabilityRulesPUT(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary Locations\n     * @param locationId\n     * @param authToken\n     */\n    locationsGET(params: {  \"locationId\"?: string; \"authToken\"?: string; }, options?: any) {\n        return ResourceApiFp.locationsGET(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary Locations\n     * @param locationId\n     * @param authToken\n     */\n    locationsPOST(params: {  \"locationId\"?: string; \"authToken\"?: string; }, options?: any) {\n        return ResourceApiFp.locationsPOST(params, options)(this.fetch, this.basePath);\n    }\n};\n\n/**\n * ResourceApi - factory interface\n */\nexport const ResourceApiFactory = function (fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         *\n         * @summary AvailabilityRules\n         * @param req\n         * @param authToken\n         */\n        availabilityRulesDELETE(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any) {\n            return ResourceApiFp.availabilityRulesDELETE(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary AvailabilityRules\n         * @param authToken\n         */\n        availabilityRulesGET(params: {  \"authToken\"?: string; }, options?: any) {\n            return ResourceApiFp.availabilityRulesGET(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary AvailabilityRules\n         * @param req\n         * @param authToken\n         */\n        availabilityRulesPOST(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any) {\n            return ResourceApiFp.availabilityRulesPOST(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary AvailabilityRules\n         * @param req\n         * @param authToken\n         */\n        availabilityRulesPUT(params: {  \"req\"?: Array<AvailabilityRule>; \"authToken\"?: string; }, options?: any) {\n            return ResourceApiFp.availabilityRulesPUT(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary Locations\n         * @param locationId\n         * @param authToken\n         */\n        locationsGET(params: {  \"locationId\"?: string; \"authToken\"?: string; }, options?: any) {\n            return ResourceApiFp.locationsGET(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary Locations\n         * @param locationId\n         * @param authToken\n         */\n        locationsPOST(params: {  \"locationId\"?: string; \"authToken\"?: string; }, options?: any) {\n            return ResourceApiFp.locationsPOST(params, options)(fetch, basePath);\n        },\n    };\n};\n\n\n/**\n * ScheduleApi - fetch parameter creator\n */\nexport const ScheduleApiFetchParamCreator = {\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerDELETE(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/appointment`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n            \"withContrast\": params[\"withContrast\"],\n            \"locationId\": params[\"locationId\"],\n            \"search\": params[\"search\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"DELETE\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerGET(params: {  \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/appointment`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n            \"withContrast\": params[\"withContrast\"],\n            \"locationId\": params[\"locationId\"],\n            \"search\": params[\"search\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"GET\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerPOST(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/appointment`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n            \"withContrast\": params[\"withContrast\"],\n            \"locationId\": params[\"locationId\"],\n            \"search\": params[\"search\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"POST\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerPUT(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/appointment`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n            \"withContrast\": params[\"withContrast\"],\n            \"locationId\": params[\"locationId\"],\n            \"search\": params[\"search\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"PUT\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary AppointmentRef\n     * @param authToken\n     * @param search\n     */\n    appointmentRefDELETE(params: {  \"authToken\"?: string; \"search\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/appointmentByRef`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n            \"search\": params[\"search\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"DELETE\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary AppointmentRef\n     * @param authToken\n     * @param search\n     */\n    appointmentRefGET(params: {  \"authToken\"?: string; \"search\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/appointmentByRef`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n            \"search\": params[\"search\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"GET\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary SendConfirmationEmail\n     * @param req\n     * @param authToken\n     * @param notifyAdmin\n     */\n    sendConfirmationEmailPOST(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"notifyAdmin\"?: boolean; }, options?: any): FetchArgs {\n        const baseUrl = `/api/sendemail`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n            \"notifyAdmin\": params[\"notifyAdmin\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"POST\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        contentTypeHeader = { \"Content-Type\": \"application/json\" };\n        if (params[\"req\"]) {\n            fetchOptions.body = JSON.stringify(params[\"req\"] || {});\n        }\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary ServiceType\n     * @param locationId\n     */\n    serviceTypesGET(params: {  \"locationId\"?: string; }, options?: any): FetchArgs {\n        const baseUrl = `/api/serviceType`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"locationId\": params[\"locationId\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"GET\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n    /**\n     *\n     * @summary TimeSlots\n     * @param authToken\n     * @param withContrast\n     * @param length\n     * @param locationId\n     * @param skip\n     */\n    timeSlotsGET(params: {  \"authToken\"?: string; \"withContrast\"?: boolean; \"length\"?: number; \"locationId\"?: string; \"skip\"?: number; }, options?: any): FetchArgs {\n        const baseUrl = `/api/timeslots`;\n        let urlObj = url.parse(baseUrl, true);\n        urlObj.query = assign({}, urlObj.query, {\n            \"authToken\": params[\"authToken\"],\n            \"withContrast\": params[\"withContrast\"],\n            \"length\": params[\"length\"],\n            \"locationId\": params[\"locationId\"],\n            \"skip\": params[\"skip\"],\n        });\n        let fetchOptions: RequestInit = assign({}, { method: \"GET\" }, options);\n\n        let contentTypeHeader: Dictionary<string> = {};\n        if (contentTypeHeader) {\n            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);\n        }\n        return {\n            url: url.format(urlObj),\n            options: fetchOptions,\n        };\n    },\n};\n\n/**\n * ScheduleApi - functional programming interface\n */\nexport const ScheduleApiFp = {\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerDELETE(params: { \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAppointment> {\n        const fetchArgs = ScheduleApiFetchParamCreator.appointmentHandlerDELETE(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerGET(params: { \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAppointment> {\n        const fetchArgs = ScheduleApiFetchParamCreator.appointmentHandlerGET(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerPOST(params: { \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAppointment> {\n        const fetchArgs = ScheduleApiFetchParamCreator.appointmentHandlerPOST(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerPUT(params: { \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAppointment> {\n        const fetchArgs = ScheduleApiFetchParamCreator.appointmentHandlerPUT(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary AppointmentRef\n     * @param authToken\n     * @param search\n     */\n    appointmentRefDELETE(params: { \"authToken\"?: string; \"search\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultAppointment> {\n        const fetchArgs = ScheduleApiFetchParamCreator.appointmentRefDELETE(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary AppointmentRef\n     * @param authToken\n     * @param search\n     */\n    appointmentRefGET(params: { \"authToken\"?: string; \"search\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultAppointment> {\n        const fetchArgs = ScheduleApiFetchParamCreator.appointmentRefGET(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary SendConfirmationEmail\n     * @param req\n     * @param authToken\n     * @param notifyAdmin\n     */\n    sendConfirmationEmailPOST(params: { \"req\"?: Appointment; \"authToken\"?: string; \"notifyAdmin\"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListAppointment> {\n        const fetchArgs = ScheduleApiFetchParamCreator.sendConfirmationEmailPOST(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary ServiceType\n     * @param locationId\n     */\n    serviceTypesGET(params: { \"locationId\"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListServiceType> {\n        const fetchArgs = ScheduleApiFetchParamCreator.serviceTypesGET(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n    /**\n     *\n     * @summary TimeSlots\n     * @param authToken\n     * @param withContrast\n     * @param length\n     * @param locationId\n     * @param skip\n     */\n    timeSlotsGET(params: { \"authToken\"?: string; \"withContrast\"?: boolean; \"length\"?: number; \"locationId\"?: string; \"skip\"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListSlotAvailabilityDate> {\n        const fetchArgs = ScheduleApiFetchParamCreator.timeSlotsGET(params, options);\n        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {\n            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {\n                if (response.status >= 200 && response.status < 300) {\n                    return response.json();\n                } else {\n                    throw response;\n                }\n            });\n        };\n    },\n};\n\n/**\n * ScheduleApi - object-oriented interface\n */\nexport class ScheduleApi extends BaseAPI {\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerDELETE(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any) {\n        return ScheduleApiFp.appointmentHandlerDELETE(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerGET(params: {  \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any) {\n        return ScheduleApiFp.appointmentHandlerGET(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerPOST(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any) {\n        return ScheduleApiFp.appointmentHandlerPOST(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary AppointmentHandler\n     * @param req\n     * @param authToken\n     * @param withContrast\n     * @param locationId\n     * @param search\n     */\n    appointmentHandlerPUT(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any) {\n        return ScheduleApiFp.appointmentHandlerPUT(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary AppointmentRef\n     * @param authToken\n     * @param search\n     */\n    appointmentRefDELETE(params: {  \"authToken\"?: string; \"search\"?: string; }, options?: any) {\n        return ScheduleApiFp.appointmentRefDELETE(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary AppointmentRef\n     * @param authToken\n     * @param search\n     */\n    appointmentRefGET(params: {  \"authToken\"?: string; \"search\"?: string; }, options?: any) {\n        return ScheduleApiFp.appointmentRefGET(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary SendConfirmationEmail\n     * @param req\n     * @param authToken\n     * @param notifyAdmin\n     */\n    sendConfirmationEmailPOST(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"notifyAdmin\"?: boolean; }, options?: any) {\n        return ScheduleApiFp.sendConfirmationEmailPOST(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary ServiceType\n     * @param locationId\n     */\n    serviceTypesGET(params: {  \"locationId\"?: string; }, options?: any) {\n        return ScheduleApiFp.serviceTypesGET(params, options)(this.fetch, this.basePath);\n    }\n    /**\n     *\n     * @summary TimeSlots\n     * @param authToken\n     * @param withContrast\n     * @param length\n     * @param locationId\n     * @param skip\n     */\n    timeSlotsGET(params: {  \"authToken\"?: string; \"withContrast\"?: boolean; \"length\"?: number; \"locationId\"?: string; \"skip\"?: number; }, options?: any) {\n        return ScheduleApiFp.timeSlotsGET(params, options)(this.fetch, this.basePath);\n    }\n};\n\n/**\n * ScheduleApi - factory interface\n */\nexport const ScheduleApiFactory = function (fetch?: FetchAPI, basePath?: string) {\n    return {\n        /**\n         *\n         * @summary AppointmentHandler\n         * @param req\n         * @param authToken\n         * @param withContrast\n         * @param locationId\n         * @param search\n         */\n        appointmentHandlerDELETE(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any) {\n            return ScheduleApiFp.appointmentHandlerDELETE(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary AppointmentHandler\n         * @param authToken\n         * @param withContrast\n         * @param locationId\n         * @param search\n         */\n        appointmentHandlerGET(params: {  \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any) {\n            return ScheduleApiFp.appointmentHandlerGET(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary AppointmentHandler\n         * @param req\n         * @param authToken\n         * @param withContrast\n         * @param locationId\n         * @param search\n         */\n        appointmentHandlerPOST(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any) {\n            return ScheduleApiFp.appointmentHandlerPOST(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary AppointmentHandler\n         * @param req\n         * @param authToken\n         * @param withContrast\n         * @param locationId\n         * @param search\n         */\n        appointmentHandlerPUT(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"withContrast\"?: boolean; \"locationId\"?: string; \"search\"?: string; }, options?: any) {\n            return ScheduleApiFp.appointmentHandlerPUT(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary AppointmentRef\n         * @param authToken\n         * @param search\n         */\n        appointmentRefDELETE(params: {  \"authToken\"?: string; \"search\"?: string; }, options?: any) {\n            return ScheduleApiFp.appointmentRefDELETE(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary AppointmentRef\n         * @param authToken\n         * @param search\n         */\n        appointmentRefGET(params: {  \"authToken\"?: string; \"search\"?: string; }, options?: any) {\n            return ScheduleApiFp.appointmentRefGET(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary SendConfirmationEmail\n         * @param req\n         * @param authToken\n         * @param notifyAdmin\n         */\n        sendConfirmationEmailPOST(params: {  \"req\"?: Appointment; \"authToken\"?: string; \"notifyAdmin\"?: boolean; }, options?: any) {\n            return ScheduleApiFp.sendConfirmationEmailPOST(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary ServiceType\n         * @param locationId\n         */\n        serviceTypesGET(params: {  \"locationId\"?: string; }, options?: any) {\n            return ScheduleApiFp.serviceTypesGET(params, options)(fetch, basePath);\n        },\n        /**\n         *\n         * @summary TimeSlots\n         * @param authToken\n         * @param withContrast\n         * @param length\n         * @param locationId\n         * @param skip\n         */\n        timeSlotsGET(params: {  \"authToken\"?: string; \"withContrast\"?: boolean; \"length\"?: number; \"locationId\"?: string; \"skip\"?: number; }, options?: any) {\n            return ScheduleApiFp.timeSlotsGET(params, options)(fetch, basePath);\n        },\n    };\n};\n\n"],"sourceRoot":""}