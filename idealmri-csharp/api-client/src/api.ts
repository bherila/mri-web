/**
 * UCMidtier
 * java -jar ../swagger-codegen-cli.jar generate -i http://localhost:8082/swagger/docs/v1 -l typescript-fetch -o C:\proj\uc_shared\src
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

require("portable-fetch");
//import * as assign from "core-js/library/fn/object/assign";
const assign = require('object-assign');
const isomorphicFetch = fetch;

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

export const BASE_PATH = (!process.env.BROWSER) ? ((process.env && process.env.BASE_PATH) || 'https://www.undergroundcellar.com') : '';

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface AccessLogModel {
    "acType"?: string;
    "acUrl"?: string;
    "acIpv6"?: string;
    "acOffersef"?: string;
    "acQsEmail"?: string;
    "acQsFname"?: string;
    "acQsLname"?: string;
    "acReferrer"?: string;
    "acSessionid"?: string;
}

export interface AchievementModel {
    "name"?: string;
    "description"?: string;
    "totalPoints"?: number;
    "records"?: Array<AchievementRecord>;
}

export interface AchievementRecord {
    "itemId"?: string;
    "name"?: string;
    "date"?: Date;
    "pointsEarned"?: number;
}

export interface AdminOfferOverviewItem {
    "status"?: string;
    "dueDate"?: Date;
}

export interface AdminOfferOverviewModel {
    "offerStartDate"?: Date;
    "items"?: { [key: string]: AdminOfferOverviewItem; };
}

export interface AdminReferralModel {
    "userEmail"?: string;
    "referredUserEmail"?: string;
}

export interface AdminSkuDelivery {
    "items"?: string;
    "arrivalId"?: string;
    "offerId"?: string;
    "eta"?: Date;
    "invoiceLink"?: string;
    "comments"?: string;
    "deliveryCost"?: number;
    "isReceived"?: boolean;
    "receivedDate"?: Date;
    "enteredDate"?: Date;
}

export interface AdminUserPushModel {
    "userQuery"?: string;
    "searchResult"?: Array<UserModelExtended>;
    "body"?: string;
    "deepLink"?: string;
    "title"?: string;
}

export interface Animation {
    "fileId"?: string;
    "thumb"?: PhotoSize;
    "fileName"?: string;
    "mimeType"?: string;
    "fileSize"?: number;
}

export interface ApiBillingModelWithAuthnet {
    "userGuid"?: string;
    "authNetUserProfileId"?: string;
    "authNetUserId"?: string;
    "authNetPaymentProfileId"?: string;
    "authNetShippingProfileId"?: string;
    "isDeleted"?: boolean;
    "isTest"?: boolean;
    "billingAddressId"?: string;
    "cvv": string;
    "firstName": string;
    "lastName": string;
    "dateAdded"?: Date;
    "expiryYear"?: number;
    "expiryMonth"?: number;
    "cardNumber"?: string;
    "id"?: string;
    "isDefault"?: boolean;
    "cardType"?: string;
}

export interface ApiBillingModelWithCardNumber {
    "billingAddressId"?: string;
    "cvv": string;
    "firstName": string;
    "lastName": string;
    "dateAdded"?: Date;
    "expiryYear"?: number;
    "expiryMonth"?: number;
    "cardNumber"?: string;
    "id"?: string;
    "isDefault"?: boolean;
    "cardType"?: string;
}

export interface ApiResultAdminUserPushModel {
    "value"?: AdminUserPushModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultApiBillingModelWithAuthnet {
    "value"?: ApiBillingModelWithAuthnet;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultApplePushEnroll {
    "value"?: ApplePushEnroll;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultAttributedItemList {
    "value"?: AttributedItemList;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultBoolean {
    "value"?: boolean;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultCheckoutPromoCodeModel {
    "value"?: CheckoutPromoCodeModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultCloudCart {
    "value"?: CloudCart;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultCloudCheckoutModel {
    "value"?: CloudCheckoutModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultCreditOrderResult {
    "value"?: CreditOrderResult;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultDecimal {
    "value"?: number;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultGeniusExcl {
    "value"?: GeniusExcl;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultInviteByEmailModel {
    "value"?: InviteByEmailModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultItemDetailEntity {
    "value"?: ItemDetailEntity;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultLeaderboardModel {
    "value"?: LeaderboardModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListApiBillingModelWithCardNumber {
    "value"?: Array<ApiBillingModelWithCardNumber>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListChargebackSearchResult {
    "value"?: Array<ChargebackSearchResult>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListCheckoutPromoCodeModel {
    "value"?: Array<CheckoutPromoCodeModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListCloudCheckoutItem {
    "value"?: Array<CloudCheckoutItem>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListCodeWithOrder {
    "value"?: Array<CodeWithOrder>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListCommentJsonObject {
    "value"?: Array<CommentJsonObject>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListDeficitItem {
    "value"?: Array<DeficitItem>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListFeatureRestriction {
    "value"?: Array<FeatureRestriction>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListGeniusGuess {
    "value"?: Array<GeniusGuess>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListGuid {
    "value"?: Array<string>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListInviteByEmailModel {
    "value"?: Array<InviteByEmailModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListItemDetailEntity {
    "value"?: Array<ItemDetailEntity>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListLinkInvoiceItem {
    "value"?: Array<LinkInvoiceItem>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListLinkTransferItem {
    "value"?: Array<LinkTransferItem>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListMarketingExpiringCredits {
    "value"?: Array<MarketingExpiringCredits>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListMisallocation {
    "value"?: Array<Misallocation>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhAbandonedBottle {
    "value"?: Array<NhAbandonedBottle>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhAddressModel {
    "value"?: Array<NhAddressModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhCohort {
    "value"?: Array<NhCohort>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhCreditModel {
    "value"?: Array<NhCreditModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhInvoice {
    "value"?: Array<NhInvoice>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhItemGroupViewEntity {
    "value"?: Array<NhItemGroupViewEntity>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhOrderModel {
    "value"?: Array<NhOrderModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhTransfer {
    "value"?: Array<NhTransfer>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListNhUserModel {
    "value"?: Array<NhUserModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListOfferV2AdminManifest {
    "value"?: Array<OfferV2AdminManifest>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListOfferV2Entity {
    "value"?: Array<OfferV2Entity>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListOrderGeniusState {
    "value"?: Array<OrderGeniusState>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListPage {
    "value"?: Array<Page>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListParsedShipmentEmail {
    "value"?: Array<ParsedShipmentEmail>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListPaymentWithAddressModel {
    "value"?: Array<PaymentWithAddressModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListPgCloudCellarRecord {
    "value"?: Array<PgCloudCellarRecord>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListPurchaseOrderModel {
    "value"?: Array<PurchaseOrderModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListShippingModel {
    "value"?: Array<ShippingModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListSkuBackup {
    "value"?: Array<SkuBackup>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListSkuEntity {
    "value"?: Array<SkuEntity>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListSkuHistory {
    "value"?: Array<SkuHistory>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListSkuSale {
    "value"?: Array<SkuSale>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListString {
    "value"?: Array<string>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListTaxReportRecord {
    "value"?: Array<TaxReportRecord>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListUserCreditViewModel {
    "value"?: Array<UserCreditViewModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListUserModelExtended {
    "value"?: Array<UserModelExtended>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListUserReferralModel {
    "value"?: Array<UserReferralModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListUserSummaryViewRecord {
    "value"?: Array<UserSummaryViewRecord>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListWineGeniusMessage {
    "value"?: Array<WineGeniusMessage>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListWineGeniusVacation {
    "value"?: Array<WineGeniusVacation>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultListWineryModel {
    "value"?: Array<WineryModel>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultManifestList {
    "value"?: Array<OfferV2ManifestEntity>;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhAddressModel {
    "value"?: NhAddressModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhCreditModel {
    "value"?: NhCreditModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhInvoice {
    "value"?: NhInvoice;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhInvoiceItem {
    "value"?: NhInvoiceItem;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhItemGroupEntity {
    "value"?: NhItemGroupEntity;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhOrderModel {
    "value"?: NhOrderModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhPromoCodeModel {
    "value"?: NhPromoCodeModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhTransfer {
    "value"?: NhTransfer;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhTransferItem {
    "value"?: NhTransferItem;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhUserEmailPreference {
    "value"?: NhUserEmailPreference;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultNhUserModel {
    "value"?: NhUserModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultOauthorization {
    "value"?: Oauthorization;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultOfferCheckoutModel {
    "value"?: OfferCheckoutModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultOfferV2Entity {
    "value"?: OfferV2Entity;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultOrderViewModel {
    "value"?: OrderViewModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultOrdersOverviewModel {
    "value"?: OrdersOverviewModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultPage {
    "value"?: Page;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultPasswordChangeModel {
    "value"?: PasswordChangeModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultPaymentWithAddressModel {
    "value"?: PaymentWithAddressModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultPromoResult {
    "value"?: PromoResult;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultPurchaseOrderModel {
    "value"?: PurchaseOrderModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultShippingModel {
    "value"?: ShippingModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultSkuBackup {
    "value"?: SkuBackup;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultSkuDashboard {
    "value"?: SkuDashboard;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultSkuEntity {
    "value"?: SkuEntity;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultSkuHistory {
    "value"?: SkuHistory;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultSkuSwapModel {
    "value"?: SkuSwapModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultString {
    "value"?: string;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultSupportRequest {
    "value"?: SupportRequest;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultSupportTicket {
    "value"?: SupportTicket;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultTupleWineProductDataNonWineProductData {
    "value"?: TupleWineProductDataNonWineProductData;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultUpdateStockResult {
    "value"?: UpdateStockResult;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultUserAuthResultModel {
    "value"?: UserAuthResultModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultUserModelExtended {
    "value"?: UserModelExtended;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultWineGeniusData {
    "value"?: WineGeniusData;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultWineGeniusMessage {
    "value"?: WineGeniusMessage;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultWineGeniusVacation {
    "value"?: WineGeniusVacation;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultWineryModel {
    "value"?: WineryModel;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApiResultWordGame {
    "value"?: WordGame;
    "success"?: boolean;
    "message"?: string;
    "stackTrace"?: Array<Stack>;
}

export interface ApplePushEnroll {
    "deviceToken"?: string;
    "deviceUuid"?: string;
    "entryPoint"?: string;
}

export interface AttributedItemList {
    "itemCount"?: number;
    "items"?: Array<CloudRecordGroup>;
    "varietals"?: Array<TupleStringInt32>;
    "regions"?: Array<TupleStringInt32>;
    "countries"?: Array<TupleStringInt32>;
    "subregions"?: Array<TupleStringInt32>;
    "appellations"?: Array<TupleStringInt32>;
    "types"?: Array<TupleStringInt32>;
    "producers"?: Array<TupleStringInt32>;
    "shipStatus"?: Array<TupleStringInt32>;
    "prices"?: Array<TupleStringInt32>;
}

export interface Audio {
    "duration"?: number;
    "performer"?: string;
    "title"?: string;
    "mimeType"?: string;
    "fileId"?: string;
    "fileSize"?: number;
}

export interface CallbackQuery {
    "id"?: string;
    "from"?: User;
    "message"?: Message;
    "inlineMessageId"?: string;
    "chatInstance"?: string;
    "data"?: string;
    "gameShortName"?: string;
}

export interface CampaignApiModel {
    "title"?: string;
    "landingHtml"?: string;
    "shareTitle"?: string;
    "shareDescription"?: string;
    "endDate"?: Date;
    "prize"?: Array<PrizeModel>;
    "additionalDetails"?: string;
    "type"?: CampaignApiModelTypeEnum;
    "landingPages"?: Array<any>;
    "userEntries"?: number;
    "invitedByUser"?: number;
    "totalEntries"?: number;
    "userInCampaign"?: boolean;
    "isActive"?: boolean;
}

export type CampaignApiModelTypeEnum = "0" | "1";
export interface CampaignEntryModel {
    "userId"?: number;
    "campaignId"?: number;
    "invitedByUserId"?: number;
}

export interface CampaignExportModel {
    "bonus"?: number;
    "email"?: string;
    "referrals"?: number;
    "totalEntry"?: number;
    "userId"?: number;
}

export interface ChargebackSearchResult {
    "timestamp"?: Date;
    "cardNo"?: string;
    "cardType"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "totalPrice"?: number;
    "orderUserNth"?: number;
    "email"?: string;
    "userGuid"?: string;
    "orderGuid"?: string;
    "orderStatus"?: string;
    "paymentStatus"?: string;
}

export interface Chat {
    "id"?: number;
    "type"?: ChatTypeEnum;
    "title"?: string;
    "username"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "allMembersAreAdministrators"?: boolean;
    "photo"?: ChatPhoto;
    "description"?: string;
    "inviteLink"?: string;
    "pinnedMessage"?: Message;
    "stickerSetName"?: string;
    "canSetStickerSet"?: boolean;
}

export type ChatTypeEnum = "private" | "group" | "channel" | "supergroup";
export interface ChatPhoto {
    "bigFileId"?: string;
    "smallFileId"?: string;
}

export interface CheckoutPromoCodeModel {
    "code"?: string;
    "error"?: CheckoutPromoCodeModelErrorEnum;
    "discountApplied"?: number;
}

export type CheckoutPromoCodeModelErrorEnum = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
export interface ChosenInlineResult {
    "resultId"?: string;
    "from"?: User;
    "location"?: Location;
    "inlineMessageId"?: string;
    "query"?: string;
}

export interface CloudCart {
    "regularItems"?: Array<CloudCheckoutItem>;
    "oversizeItems"?: Array<CloudCheckoutItem>;
    "otherItems"?: Array<CloudCheckoutItem>;
}

export interface CloudCellarV2 {
    "firstName"?: string;
    "biography"?: string;
    "url"?: string;
    "userName"?: string;
    "lifetimeValueSpent"?: number;
    "lifetimeUpgradeReceived"?: number;
    "shippingSavings"?: number;
    "shipments"?: any;
    "allItems"?: AttributedItemList;
    "userImg"?: string;
    "signupDate"?: Date;
}

export interface CloudCheckoutItem {
    "sku"?: string;
    "qty"?: number;
    "cloudItemDetail"?: PgCloudCellarRecord;
    "slotType"?: string;
}

export interface CloudCheckoutModel {
    "shippingMethod"?: CloudCheckoutModelShippingMethodEnum;
    "icePack"?: boolean;
    "giftMessage"?: string;
    "bottles"?: Array<CloudCheckoutItem>;
    "additionalItems"?: Array<CloudCheckoutItem>;
    "protectShipment"?: boolean;
    "protectShipmentValue"?: number;
    "protectShipmentPercent"?: number;
    "qty"?: number;
    "userGuid": string;
    "creditCardId": string;
    "shippingAddressId": string;
    "promoCode": Array<CheckoutPromoCodeModel>;
    "appId"?: string;
    "useAccountCredit"?: boolean;
    "result"?: ShipOrderResult;
    "noAuthAddress"?: NhAddressModel;
    "validationWarnings"?: Array<ValidationResult>;
    "validationErrors"?: Array<ValidationResult>;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
}

export type CloudCheckoutModelShippingMethodEnum = "0" | "1" | "2" | "3";
export interface CloudRecordGroup {
    "item"?: PgCloudCellarRecord;
    "paid"?: Array<number>;
    "qtyAvailable"?: number;
    "qtyShipped"?: number;
    "qtyEnRoute"?: number;
    "qtyManual"?: number;
    "qtyInCart"?: number;
}

export interface CodeWithOrder {
    "code"?: NhPromoCodeModel;
    "usedWithOrders"?: Array<NhOrderModel>;
    "isReferral"?: boolean;
    "isRedeemed"?: boolean;
    "dateRedeemed"?: Date;
    "redeemedForCredit"?: NhCreditModel;
}

export interface CommentJsonObject {
    "commentId"?: string;
    "commentTime"?: Date;
    "commentText"?: string;
    "sendEmail"?: boolean;
}

export interface Contact {
    "phoneNumber"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "userId"?: number;
}

export interface CreditCheckoutModel {
    "qty"?: number;
    "amt"?: number;
    "friendEmail"?: string;
    "userGuid": string;
    "creditCardId": string;
    "shippingAddressId": string;
    "promoCode": Array<CheckoutPromoCodeModel>;
    "appId"?: string;
    "useAccountCredit"?: boolean;
    "result"?: CreditOrderResult;
    "noAuthAddress"?: NhAddressModel;
    "validationWarnings"?: Array<ValidationResult>;
    "validationErrors"?: Array<ValidationResult>;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
}

export interface CreditOrderResult {
    "promoCodeCreated"?: string;
    "promotionsUsed"?: Array<CheckoutPromoCodeModel>;
    "promoValue"?: number;
    "accountBalanceUsed"?: number;
    "accountBalanceAvailable"?: number;
    "taxComputed"?: TaxInfo;
    "totalPrice"?: number;
    "subtotal"?: number;
}

export interface DecoderFallback {
    "maxCharCount"?: number;
}

export interface DeficitItem {
    "sku"?: string;
    "lastOrder"?: Date;
    "firstOrder"?: Date;
    "qtyOwedOverTimeLimit"?: number;
    "qtyInStock"?: number;
    "retailPrice"?: number;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface Document {
    "thumb"?: PhotoSize;
    "fileName"?: string;
    "mimeType"?: string;
    "fileId"?: string;
    "fileSize"?: number;
}

export interface EmailCapture {
    "email"?: string;
    "favoriteVarietal"?: string;
}

export interface EncoderFallback {
    "maxCharCount"?: number;
}

export interface Encoding {
    "bodyName"?: string;
    "encodingName"?: string;
    "headerName"?: string;
    "webName"?: string;
    "windowsCodePage"?: number;
    "isBrowserDisplay"?: boolean;
    "isBrowserSave"?: boolean;
    "isMailNewsDisplay"?: boolean;
    "isMailNewsSave"?: boolean;
    "isSingleByte"?: boolean;
    "encoderFallback"?: EncoderFallback;
    "decoderFallback"?: DecoderFallback;
    "isReadOnly"?: boolean;
    "codePage"?: number;
}

export interface FeatureRestriction {
    "featureName"?: string;
    "restrictUtm"?: string;
    "requireTest"?: number;
    "releaseDate"?: Date;
    "isAllowed"?: boolean;
}

export interface Game {
    "title"?: string;
    "description"?: string;
    "photo"?: Array<PhotoSize>;
    "text"?: string;
    "textEntities"?: Array<MessageEntity>;
    "animation"?: Animation;
}

export interface GeniusExcl {
    "include"?: Array<WineGeniusExclusionItem>;
    "exclude"?: Array<WineGeniusExclusionItem>;
}

export interface GeniusGuess {
    "userGuid"?: string;
    "email"?: string;
    "qty"?: number;
    "match"?: string;
    "lifeOrderValue"?: number;
    "lifeQty"?: number;
    "userLastPurchaseDate"?: Date;
}

export interface GroupItemEntity {
    "groupItemId"?: string;
    "referenceIdentity"?: string;
    "groupName"?: string;
    "groupType"?: GroupItemEntityGroupTypeEnum;
    "dateAdded"?: Date;
}

export type GroupItemEntityGroupTypeEnum = "1" | "2" | "3";
export interface IBulkItemDetail {
    "region"?: string;
    "appel"?: string;
    "varietal"?: string;
    "vintage"?: number;
    "brand"?: string;
    "countryCode"?: string;
    "fancifulName"?: string;
}

export interface IContentNegotiator {
}

export interface IRequiredMemberSelector {
}

export interface InlineQuery {
    "id"?: string;
    "from"?: User;
    "query"?: string;
    "location"?: Location;
    "offset"?: string;
}

export interface InviteByEmailModel {
    "userUrlProfile"?: string;
    "newUserEmail"?: string;
    "newUserName"?: string;
}

export interface Invoice {
    "title"?: string;
    "description"?: string;
    "startParameter"?: string;
    "currency"?: string;
    "totalAmount"?: number;
}

export interface ItemDetailBulkUpdate {
    "detailIds"?: Array<string>;
    "bulkDetails"?: IBulkItemDetail;
}

export interface ItemDetailEntity {
    "itemDetailGuid"?: string;
    "fancifulName"?: string;
    "region"?: string;
    "appel"?: string;
    "varietal"?: string;
    "vintage"?: number;
    "abv"?: number;
    "wineTastingNotes"?: string;
    "winemakerNotes"?: string;
    "retailPrice"?: number;
    "wineryGuid"?: string;
    "urlKey"?: string;
    "brand"?: string;
    "countryCode"?: string;
    "upc"?: string;
    "ml"?: number;
    "isWine"?: boolean;
    "isBeer"?: boolean;
    "isLiquor"?: boolean;
    "isSparkling"?: boolean;
    "isSmallProduction"?: boolean;
    "isCult"?: boolean;
    "ctWineId"?: number;
    "ctProducerId"?: number;
    "ctLikes"?: number;
    "ctTastingNotes"?: number;
    "ctReview"?: number;
    "ctCommunityScore"?: number;
    "ctQty"?: number;
    "wineVineyard"?: string;
    "wineDrinkStart"?: number;
    "wineDrinkEnd"?: number;
    "redirectTo"?: string;
    "opName"?: string;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface KpiItem {
    "timestamp"?: Date;
    "newUsers"?: number;
    "totalUsers"?: number;
    "newCustomers"?: number;
    "totalCustomers"?: number;
    "newOrders"?: number;
    "totalOrders"?: number;
    "newBottles"?: number;
    "totalBottles"?: number;
    "newSalesRevenue"?: number;
    "totalSalesRevenue"?: number;
    "directShippingRevenue"?: number;
    "cloudShippingRevenue"?: number;
    "totalShippingRevenue"?: number;
    "orderTaxRevenue"?: number;
    "creditsUsed"?: number;
    "promoCodeValueUsed"?: number;
}

export interface LeaderboardItem {
    "userId"?: string;
    "userDisplayName"?: string;
    "userSef"?: string;
    "points"?: number;
    "userEmail"?: string;
}

export interface LeaderboardItemGroup {
    "participants"?: Array<LeaderboardItem>;
    "groupName"?: string;
}

export interface LeaderboardModel {
    "contestBegin"?: Date;
    "contestEnd"?: Date;
    "items"?: Array<LeaderboardItemGroup>;
}

export interface LinkInvoiceItem {
    "invItem"?: NhInvoiceItem;
    "onInvoice"?: string;
    "onInvoiceMemo"?: string;
    "onTransfer"?: string;
    "canLinkTransfer"?: Array<NhTransferItem>;
}

export interface LinkTransferItem {
    "xferItem"?: NhTransferItem;
    "onTransfer"?: string;
    "onInvoice"?: string;
    "canLinkInvoice"?: Array<NhInvoiceItem>;
    "canLinkHistory"?: Array<SkuHistory>;
}

export interface LiveFeedItem {
    "quantity"?: number;
    "name"?: string;
    "url"?: string;
    "imageUrl"?: string;
}

export interface Location {
    "longitude"?: number;
    "latitude"?: number;
}

export interface ManifestSwapAction {
    "action"?: string;
    "msOfferSef"?: string;
    "msOfferGuid"?: string;
    "email"?: string;
    "manifestId"?: string;
    "skuEntity"?: SkuEntity;
    "retailPrice"?: number;
    "taxableValue"?: number;
    "estimatedTaxAllocated"?: number;
    "shippingCaseGuid"?: string;
    "isSuspended"?: boolean;
    "itemGroupId"?: string;
    "pickIndex"?: number;
    "replacementForManifestGuid"?: string;
    "campaignId"?: number;
    "creditedForGuid"?: string;
    "unitDiscount"?: number;
    "suspendDate"?: Date;
    "fulfilledSku"?: string;
}

export interface MarketingCreditExpiry {
    "creditAmt"?: number;
    "expiry"?: Date;
}

export interface MarketingExpiringCredits {
    "email"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "userCredits"?: Array<MarketingCreditExpiry>;
}

export interface MaskPosition {
    "point"?: MaskPositionPointEnum;
    "xShift"?: number;
    "yShift"?: number;
    "scale"?: number;
}

export type MaskPositionPointEnum = "forehead" | "eyes" | "mouth" | "chin";
export interface MediaTypeFormatter {
    "supportedMediaTypes"?: Array<MediaTypeHeaderValue>;
    "supportedEncodings"?: Array<Encoding>;
    "mediaTypeMappings"?: Array<MediaTypeMapping>;
    "requiredMemberSelector"?: IRequiredMemberSelector;
}

export interface MediaTypeHeaderValue {
    "charSet"?: string;
    "parameters"?: Array<NameValueHeaderValue>;
    "mediaType"?: string;
}

export interface MediaTypeMapping {
    "mediaType"?: MediaTypeHeaderValue;
}

export interface Message {
    "messageId"?: number;
    "from"?: User;
    "date"?: Date;
    "chat"?: Chat;
    "forwardFrom"?: User;
    "forwardFromChat"?: Chat;
    "forwardFromMessageId"?: number;
    "forwardSignature"?: string;
    "forwardDate"?: Date;
    "replyToMessage"?: Message;
    "editDate"?: Date;
    "mediaGroupId"?: string;
    "authorSignature"?: string;
    "text"?: string;
    "entities"?: Array<MessageEntity>;
    "captionEntities"?: Array<MessageEntity>;
    "audio"?: Audio;
    "document"?: Document;
    "game"?: Game;
    "photo"?: Array<PhotoSize>;
    "sticker"?: Sticker;
    "video"?: Video;
    "voice"?: Voice;
    "videoNote"?: VideoNote;
    "caption"?: string;
    "contact"?: Contact;
    "location"?: Location;
    "venue"?: Venue;
    "newChatMembers"?: Array<User>;
    "leftChatMember"?: User;
    "newChatTitle"?: string;
    "newChatPhoto"?: Array<PhotoSize>;
    "deleteChatPhoto"?: boolean;
    "groupChatCreated"?: boolean;
    "supergroupChatCreated"?: boolean;
    "channelChatCreated"?: boolean;
    "migrateToChatId"?: number;
    "migrateFromChatId"?: number;
    "pinnedMessage"?: Message;
    "invoice"?: Invoice;
    "successfulPayment"?: SuccessfulPayment;
    "connectedWebsite"?: string;
}

export interface MessageEntity {
    "type"?: MessageEntityTypeEnum;
    "offset"?: number;
    "length"?: number;
    "url"?: string;
    "user"?: User;
}

export type MessageEntityTypeEnum = "mention" | "hashtag" | "bot_command" | "url" | "email" | "bold" | "italic" | "code" | "pre" | "text_link" | "text_mention";
export interface Misallocation {
    "orderId"?: string;
    "offerId"?: string;
    "userEmail"?: string;
    "qtyExpected"?: number;
    "qtyAllocated"?: number;
    "paymentStatus"?: string;
    "buyPrice"?: number;
    "replacementCredit"?: number;
    "bottleCacheJson"?: string;
    "canFix"?: boolean;
    "error"?: string;
    "replacements"?: Array<NhItemGroupViewEntity>;
}

export interface NameValueHeaderValue {
    "name"?: string;
    "value"?: string;
}

export interface NewUserCheckoutModel {
    "newUserCheckout"?: OfferCheckoutModel;
    "newUser"?: NhUserModel;
    "newPayment"?: PaymentWithAddressModel;
}

export interface NhAbandonedBottle {
    "wineName"?: string;
    "manifestGuid"?: string;
    "taxValue"?: number;
    "taxAllocated"?: number;
    "sku"?: string;
    "retailPrice"?: number;
    "lastStockQty"?: number;
    "orderGuid"?: string;
    "orderTimestamp"?: Date;
    "winnerGuid"?: string;
    "winnerEmail"?: string;
    "userFname"?: string;
    "userLname"?: string;
    "userLastPurchaseDt"?: Date;
    "offerSef"?: string;
    "isWine"?: string;
    "colaVarietal"?: string;
    "colaRegion"?: string;
    "colaAppellation"?: string;
    "ccBrand"?: string;
    "ccVintage"?: string;
    "ccFanciful"?: string;
    "ccVineyard"?: string;
    "ccMl"?: number;
    "lifeSpend"?: number;
    "lifeOrderValuePq"?: number;
    "orderStatus"?: string;
    "isDefected"?: boolean;
    "neverBought"?: boolean;
    "orderValue365"?: number;
    "totalQty60"?: number;
    "totalQty90"?: number;
    "firstNotice"?: Date;
    "secondNotice"?: Date;
    "reclaimCreditGuid"?: string;
}

export interface NhAddressModel {
    "id"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "address1"?: string;
    "address2"?: string;
    "city"?: string;
    "isDefault"?: boolean;
    "cplId"?: string;
    "state"?: string;
    "carrierPreference"?: string;
    "zip"?: string;
    "phone"?: string;
    "status"?: number;
    "dateAdded"?: Date;
}

export interface NhAdjViewRecord {
    "adjMfId"?: string;
    "adjOrder"?: string;
    "adjMfIdShipped"?: string;
    "adjMfIdAdded"?: string;
    "adjMfIdRemoved"?: string;
    "adjSku"?: string;
    "adjMfIdReplaced"?: string;
    "adjCreditIssuedId"?: string;
    "adjCreditIssuedAmt"?: number;
    "adjUser"?: string;
    "adjTaxAlloc"?: number;
    "adjTaxValue"?: number;
}

export interface NhAdjustment {
    "userId"?: string;
    "adjustmentId"?: string;
    "items"?: Array<NhAdjustmentItem>;
    "adjutmentCreateTime"?: Date;
    "adjustmentExecTime"?: Date;
}

export interface NhAdjustmentItem {
    "adjustmentItemId"?: string;
    "add"?: boolean;
    "sku"?: string;
    "manifestUpdated"?: OfferV2ManifestEntity;
    "manifestCreated"?: OfferV2ManifestEntity;
    "legacyManifestUpdated"?: string;
    "legacyManifestCreated"?: string;
}

export interface NhCohort {
    "cohortPeriod"?: string;
    "cohortSize"?: number;
    "totalQty"?: number;
    "totalOrders"?: number;
    "totalRev"?: number;
    "totalCogs"?: number;
    "totalDiscount"?: number;
    "totalCreditRdmp"?: number;
    "totalTax"?: number;
    "totalNetRev"?: number;
}

export interface NhCreditModel {
    "creditId"?: string;
    "date"?: Date;
    "originalAmt"?: number;
    "creditAmt"?: number;
    "expiry"?: Date;
    "comment"?: string;
    "creditForReferredUser"?: string;
    "dateUsed"?: Date;
    "isSuspended"?: boolean;
    "warningSent"?: Date;
    "canUseUpgrade"?: boolean;
    "canUseShipment"?: boolean;
    "canUseSingle"?: boolean;
    "creditForManifest"?: string;
    "creditForGiftCard"?: string;
    "splitFrom"?: string;
    "usedWithOrder"?: string;
    "refundForOrder"?: string;
    "usedWithShipment"?: string;
    "taxRefundState"?: string;
    "ownerUser"?: string;
    "isExpired"?: boolean;
}

export interface NhInvoice {
    "invGuid"?: string;
    "invCreated"?: Date;
    "invDue"?: Date;
    "invWineryGuid"?: string;
    "invSupplierName"?: string;
    "invOfferGuid"?: string;
    "invMemo"?: string;
    "invItems"?: Array<NhInvoiceItem>;
    "invItemCount"?: number;
    "invItemQty"?: number;
    "invXferQty"?: number;
    "invRecvQty"?: number;
    "invExt"?: number;
    "recvExt"?: number;
    "xferExt"?: number;
    "countLinkableSkuHistory"?: number;
    "minMargin"?: number;
    "maxMargin"?: number;
}

export interface NhInvoiceItem {
    "liGuid"?: string;
    "liSortOrder"?: number;
    "liDescription"?: string;
    "liSkuLink"?: string;
    "liQty"?: number;
    "liUnitPrice"?: number;
    "liExt"?: number;
    "liMargin"?: number;
    "liLinkXferQty"?: number;
    "liTransferItems"?: Array<NhTransferItem>;
}

export interface NhItemGroupEntity {
    "parentOffer"?: OfferV2Entity;
    "itemList"?: Array<OfferV2ItemEntity>;
    "qtyInsideGroup"?: number;
    "isValid"?: boolean;
    "retailPrice"?: number;
    "estChance"?: number;
    "itemGroupGuid"?: string;
    "pickQty"?: number;
    "pickRoundRobin"?: boolean;
    "qtyOfGroup"?: number;
    "urlKey"?: string;
    "isUpgrade"?: boolean;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface NhItemGroupViewEntity {
    "itemDetailGuid"?: string;
    "sku"?: string;
    "isSuspended"?: boolean;
    "lastStockQty"?: number;
    "estChance"?: number;
    "retailPrice"?: number;
    "itemGroupGuid"?: string;
    "pickQty"?: number;
    "pickRoundRobin"?: boolean;
    "qtyOfGroup"?: number;
    "urlKey"?: string;
    "isUpgrade"?: boolean;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface NhOrderModel {
    "daysSinceFirstPurchase"?: number;
    "daysSinceLastPurchase"?: number;
    "daysSinceSignup"?: number;
    "isPromoEligible"?: boolean;
    "cohortUserFirstPurchase"?: Date;
    "cohortUserMonth"?: number;
    "monthSinceFirstPurchase"?: number;
    "revealDate"?: Date;
    "isRevealed"?: boolean;
    "isTest"?: boolean;
    "nhUserGuid"?: string;
    "xUserEmail"?: string;
    "orderRejectDate"?: Date;
    "billing"?: ApiBillingModelWithAuthnet;
    "skuList"?: string;
    "bottleList"?: string;
    "paymentAuthCode"?: string;
    "paymentAuthDate"?: Date;
    "transactionId"?: string;
    "promoCode"?: string;
    "bottles"?: Array<NhItemGroupViewEntity>;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "orderGuid"?: string;
    "totalQuantity"?: number;
    "totalPrice"?: number;
    "discount"?: number;
    "creditDiscount"?: number;
    "tax"?: number;
    "timestamp"?: Date;
    "orderStatus"?: string;
    "paymentStatus"?: string;
    "offerId"?: string;
    "userNthOrder"?: number;
    "unitPrice"?: number;
}

export interface NhPromoCodeModel {
    "promoCode"?: string;
    "isPercent"?: boolean;
    "promoAmount"?: number;
    "minBottlesQty"?: number;
    "minSubtotal"?: number;
    "date"?: Date;
    "startDate"?: Date;
    "expiry"?: Date;
    "promoEnabled"?: boolean;
    "redemptionsAllowedPerUser"?: number;
    "redemptionsAllowedOverall"?: number;
    "promoGroupName"?: string;
    "firstOrderOnly"?: boolean;
    "leftOverCredit"?: boolean;
    "amtPaid"?: number;
    "createdFromManifest"?: string;
    "issuedToUser"?: string;
    "isRefundable"?: boolean;
    "restrictOffer"?: string;
    "isExpired"?: boolean;
}

export interface NhSkuDelivery {
    "items"?: Array<NhSkuDeliveryItem>;
    "arrivalId"?: string;
    "offerId"?: string;
    "eta"?: Date;
    "invoiceLink"?: string;
    "comments"?: string;
    "deliveryCost"?: number;
    "isReceived"?: boolean;
    "receivedDate"?: Date;
    "enteredDate"?: Date;
}

export interface NhSkuDeliveryItem {
    "arrivalItemId"?: string;
    "arrivalItemSku"?: string;
    "unitCost"?: number;
    "arrivalQtyExpected"?: number;
    "arrivalQtyActual"?: number;
}

export interface NhSkuEnRoute {
    "sku"?: string;
    "wineName"?: string;
    "numEnroute"?: number;
    "numUsersAffected"?: number;
    "pricePaidExt"?: number;
    "srpExt"?: number;
    "lastOrderDt"?: Date;
}

export interface NhTransfer {
    "xferGuid"?: string;
    "xferLabel"?: string;
    "xferCreated"?: Date;
    "xferDue"?: Date;
    "xferCompleted"?: Date;
    "xferItems"?: Array<NhTransferItem>;
}

export interface NhTransferItem {
    "xiGuid"?: string;
    "xiSku"?: string;
    "xiLabel"?: string;
    "xiQtyOrdered"?: number;
    "xiQtyReceived"?: number;
    "xiDue"?: Date;
    "xiComment"?: string;
    "xiLinkedSkuHistory"?: Array<SkuHistory>;
    "isLinked"?: boolean;
    "xInvoiceGuid"?: string;
    "distanceFromTarget"?: number;
}

export interface NhUserEmailPreference {
    "preferenceId"?: string;
    "email"?: string;
    "sendAbandonedCheckoutEmail"?: boolean;
    "sendOrderConfirmation"?: boolean;
    "sendOrderCancellation"?: boolean;
    "sendReferralNotice"?: boolean;
    "sendCloudcellarReminder"?: boolean;
    "sendCreditReminder"?: boolean;
    "sendSystemNotice"?: boolean;
    "emailedInvited10"?: Date;
    "emailedCredits"?: Date;
    "emailedHeavyBuyer"?: Date;
    "emailedStagnant"?: Date;
    "emailedAbandonedCheckout"?: Date;
    "emailedCreditReminder"?: Date;
    "emailedCloudcellarReminder"?: Date;
    "unsubCampaignTitle"?: string;
    "unsubCampaignId"?: string;
    "unsubReason"?: string;
    "unsubTime"?: Date;
    "verifyStatus"?: string;
    "verifyDetail"?: string;
}

export interface NhUserModel {
    "acquisitionCost"?: number;
    "cacheAchievementPoints"?: number;
    "dotmailerId"?: number;
    "normalizedEmail"?: string;
    "xOrderCount"?: number;
    "xLifeSpend"?: number;
    "xLifeCredit"?: number;
    "xLifeQty"?: number;
    "xLifeDiscount"?: number;
    "userName"?: string;
    "lastOrder"?: Date;
    "profileImageUrl"?: string;
    "isPrivate"?: boolean;
    "referredByUserId"?: string;
    "defaultAddressId"?: string;
    "defaultPaymentId"?: string;
    "defaultShip"?: number;
    "defaultIce"?: boolean;
    "signupDate"?: Date;
    "lastLoginDate"?: Date;
    "lastPurchaseDate"?: Date;
    "outreachDate"?: Date;
    "sessionId"?: string;
    "password": string;
    "facebookAccessToken"?: string;
    "facebookUserId"?: number;
    "referralString"?: string;
    "clientIpAddress"?: string;
    "is21"?: boolean;
    "referralGroup"?: GroupItemEntity;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "referralCloudcellarName"?: string;
    "referralDomain"?: string;
    "userGuid"?: string;
    "email": string;
    "firstName": string;
    "lastName": string;
    "profileUrl"?: string;
    "birthday"?: Date;
    "isTestAccount"?: boolean;
}

export interface NhUserOrderCohort {
    "orderGuid"?: string;
    "userEmail"?: string;
    "orderQty"?: number;
    "unitPrice"?: number;
    "creditDiscount"?: number;
    "orderDiscount"?: number;
    "totalPrice"?: number;
    "orderUserNth"?: number;
    "orderPQ"?: number;
    "daysSinceSignup"?: number;
    "daysSinceFirstPurchase"?: number;
    "orderOfferGuid"?: string;
    "orderTax"?: number;
    "orderUtmSource"?: string;
    "orderUtmMedium"?: string;
    "orderUtmCampaign"?: string;
    "lastPurchaseDate"?: Date;
    "firstPurchaseDate"?: Date;
}

export interface NhWordGamePrize {
    "prize"?: string;
    "sku"?: string;
    "numRemaining"?: number;
    "canClaim"?: boolean;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface NonWineProductData {
    "itemType"?: string;
    "caseQuantity"?: number;
    "supplierNumber"?: number;
    "supplierSku"?: string;
    "description"?: string;
    "retailPrice"?: number;
    "sellingInfo"?: Array<ProductSellingInfo>;
}

export interface Oauthorization {
    "tokenType"?: string;
    "token"?: string;
    "refreshToken"?: string;
}

export interface OfferCheckoutModel {
    "qty"?: number;
    "isTest"?: boolean;
    "offerGuid"?: string;
    "offerSef"?: string;
    "bottlesQty"?: number;
    "specificItems"?: Array<string>;
    "revealDate"?: Date;
    "doubleDownTime"?: number;
    "userGuid": string;
    "creditCardId": string;
    "shippingAddressId": string;
    "promoCode": Array<CheckoutPromoCodeModel>;
    "appId"?: string;
    "useAccountCredit"?: boolean;
    "result"?: UpgradeOrderResult;
    "noAuthAddress"?: NhAddressModel;
    "validationWarnings"?: Array<ValidationResult>;
    "validationErrors"?: Array<ValidationResult>;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
}

export interface OfferDetailModel {
    "url"?: string;
    "title"?: string;
    "subtitle"?: string;
    "offerImgCsv"?: string;
    "offerImg"?: Array<string>;
    "minPrice"?: number;
    "maxPrice"?: number;
    "offerItemName"?: string;
    "offerItemNamePlural"?: string;
    "minQtyAllow"?: number;
    "maxQtyAllow"?: number;
    "pricePerBottle"?: number;
    "bottlesRemaining"?: number;
    "offerTotal"?: number;
    "offerStatus"?: number;
    "offerGuid"?: string;
    "sellerGuid"?: string;
    "buyText"?: string;
    "states"?: Array<string>;
    "expiryDate"?: Date;
    "startDate"?: Date;
    "isFeatured"?: boolean;
    "isDirectShip"?: boolean;
    "wineryName"?: string;
    "wineryNotes"?: string;
    "wineryAbout"?: string;
    "metaDescription"?: string;
    "metaKeywords"?: string;
    "metaTitle"?: string;
    "numberOfUpgradesGuaranteed"?: Array<number>;
    "wineryImages"?: Array<string>;
}

export interface OfferV2AdminManifest {
    "manifestId"?: string;
    "name"?: string;
    "price"?: number;
    "sku"?: string;
    "isSuspended"?: boolean;
    "winnerGuid"?: string;
    "xWinnerEmail"?: string;
    "qtyInStock"?: number;
    "shippingCaseGuid"?: string;
    "paymentStatus"?: string;
    "orderStatus"?: string;
    "orderGuid"?: string;
    "orderDate"?: Date;
}

export interface OfferV2Entity {
    "offerContent"?: string;
    "shippingAvailability"?: string;
    "dateCreated"?: Date;
    "isApproved"?: boolean;
    "isSideDeal"?: boolean;
    "priority"?: number;
    "enableAutoBuy"?: boolean;
    "enablePromo"?: boolean;
    "enableCredit"?: boolean;
    "enableDoubleDown"?: boolean;
    "enableTax"?: boolean;
    "adminNotes"?: string;
    "capturedDate"?: Date;
    "offerTax"?: number;
    "offerPq"?: number;
    "offerDisc"?: number;
    "offerCred"?: number;
    "offerUniq"?: number;
    "lifecycleUrl"?: string;
    "scrambleRatio"?: number;
    "evalUnlisted"?: boolean;
    "evalLive"?: boolean;
    "evalClosed"?: boolean;
    "evalSoldOut"?: boolean;
    "itemGroupsFlat"?: Array<NhItemGroupViewEntity>;
    "url"?: string;
    "title"?: string;
    "subtitle"?: string;
    "offerImgCsv"?: string;
    "offerImg"?: Array<string>;
    "minPrice"?: number;
    "maxPrice"?: number;
    "offerItemName"?: string;
    "offerItemNamePlural"?: string;
    "minQtyAllow"?: number;
    "maxQtyAllow"?: number;
    "pricePerBottle"?: number;
    "bottlesRemaining"?: number;
    "offerTotal"?: number;
    "offerStatus"?: number;
    "offerGuid"?: string;
    "sellerGuid"?: string;
    "buyText"?: string;
    "states"?: Array<string>;
    "expiryDate"?: Date;
    "startDate"?: Date;
    "isFeatured"?: boolean;
    "isDirectShip"?: boolean;
    "wineryName"?: string;
    "wineryNotes"?: string;
    "wineryAbout"?: string;
    "metaDescription"?: string;
    "metaKeywords"?: string;
    "metaTitle"?: string;
    "numberOfUpgradesGuaranteed"?: Array<number>;
    "wineryImages"?: Array<string>;
}

export interface OfferV2ItemEntity {
    "itemId"?: string;
    "parentItemGroup"?: NhItemGroupEntity;
    "sku"?: SkuEntity;
    "qty"?: number;
    "draftName"?: string;
    "draftPrice"?: number;
    "draftCogs"?: number;
    "flag"?: boolean;
}

export interface OfferV2ManifestEntity {
    "manifestId"?: string;
    "skuEntity"?: SkuEntity;
    "retailPrice"?: number;
    "taxableValue"?: number;
    "estimatedTaxAllocated"?: number;
    "shippingCaseGuid"?: string;
    "isSuspended"?: boolean;
    "itemGroupId"?: string;
    "pickIndex"?: number;
    "replacementForManifestGuid"?: string;
    "campaignId"?: number;
    "creditedForGuid"?: string;
    "unitDiscount"?: number;
    "suspendDate"?: Date;
    "fulfilledSku"?: string;
}

export interface OkNegotiatedContentResultApiResultBoolean {
    "content"?: ApiResultBoolean;
    "contentNegotiator"?: IContentNegotiator;
    "request"?: any;
    "formatters"?: Array<MediaTypeFormatter>;
}

export interface OrderGeniusState {
    "cancelBy"?: Date;
    "orderEntity"?: Array<NhOrderModel>;
}

export interface OrderInfo {
    "name"?: string;
    "phoneNumber"?: string;
    "email"?: string;
    "shippingAddress"?: ShippingAddress;
}

export interface OrderViewModel {
    "orderId"?: string;
    "offerSef"?: string;
    "ovOfferGuid"?: string;
    "offerTitle"?: string;
    "date"?: Date;
    "credit"?: number;
    "discount"?: number;
    "subtotal"?: number;
    "tax"?: number;
    "amtCharged"?: number;
    "status"?: string;
    "paymentStatus"?: string;
    "unitPrice"?: number;
    "totalQty"?: number;
    "isRevealed"?: boolean;
    "cardNum"?: string;
    "cardType"?: string;
    "promo"?: string;
    "tracking"?: string;
    "allItems"?: AttributedItemList;
    "lineItems"?: Array<NhItemGroupViewEntity>;
    "adjustments"?: Array<NhAdjViewRecord>;
    "address"?: NhAddressModel;
}

export interface OrdersOverviewModel {
    "orders"?: Array<OrderViewModel>;
    "shipments"?: Array<OrderViewModel>;
}

export interface OverallPlan {
    "canFree"?: Array<SkuPlan>;
    "userPlan"?: { [key: string]: number; };
    "inactiveUserPlan"?: { [key: string]: number; };
}

export interface Page {
    "id"?: string;
    "section"?: string;
    "url"?: string;
    "title"?: string;
    "main"?: string;
    "topImage"?: string;
    "sideImage"?: string;
    "sideText"?: string;
    "sideLinkUrl"?: string;
    "sideLinkText"?: string;
    "fileAttachUrl"?: string;
    "fileAttachText"?: string;
    "publishDate"?: Date;
    "expiryDate"?: Date;
}

export interface ParsedShipmentEmail {
    "track"?: string;
    "address"?: string;
    "body"?: string;
    "emailTime"?: Date;
}

export interface PasswordChangeModel {
    "oldPassword": string;
    "newPassword": string;
    "confirmNewPassword": string;
}

export interface PasswordResetAdminModel {
    "userGuid"?: string;
    "newPassword"?: string;
}

export interface PasswordResetModel {
    "email": string;
    "resetToken"?: string;
    "newPassword"?: string;
}

export interface PaymentWithAddressModel {
    "payment"?: ApiBillingModelWithAuthnet;
    "address"?: NhAddressModel;
}

export interface PgCloudCellarRecord {
    "isCounted"?: boolean;
    "varietal"?: string;
    "region"?: string;
    "appel"?: string;
    "states"?: Array<string>;
    "itemDetailGuid"?: string;
    "sku"?: string;
    "urlKey"?: string;
    "retailPrice"?: number;
    "qtyInStock"?: number;
    "isManual"?: boolean;
    "eta"?: Date;
    "isClearance"?: boolean;
    "isSuspended"?: boolean;
    "shipIncentive"?: number;
    "manifestGuid"?: string;
    "taxValue"?: number;
    "taxAllocated"?: number;
    "orderGuid"?: string;
    "winnerGuid"?: string;
    "orderDate"?: Date;
    "orderStatus"?: string;
    "paymentStatus"?: string;
    "offerGuid"?: string;
    "offerSef"?: string;
    "wineDrinkEnd"?: Date;
    "isAutographed"?: boolean;
    "isWine"?: boolean;
    "isBeer"?: boolean;
    "isCult"?: boolean;
    "shipCase"?: string;
    "shipMethod"?: string;
    "shipPrice"?: number;
    "tracking"?: string;
    "shipDate"?: Date;
    "itemGroupId"?: string;
    "fancifulName"?: string;
    "brand"?: string;
    "vintage"?: number;
    "wineVineyard"?: string;
    "ml"?: number;
    "backupSku"?: string;
    "slotType"?: string;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface PhotoSize {
    "width"?: number;
    "height"?: number;
    "fileId"?: string;
    "fileSize"?: number;
}

export interface PreCheckoutQuery {
    "id"?: string;
    "from"?: User;
    "currency"?: string;
    "totalAmount"?: number;
    "invoicePayload"?: string;
    "shippingOptionId"?: string;
    "orderInfo"?: OrderInfo;
}

export interface PrizeModel {
    "title"?: string;
    "image"?: string;
    "details"?: string;
}

export interface ProductSellingInfo {
    "accountNumber"?: string;
    "sellingSKU"?: string;
    "description"?: string;
    "supplierPayment"?: number;
}

export interface PromoResult {
    "refundAmt"?: number;
    "creditAmt"?: number;
    "orderUpdated"?: NhOrderModel;
}

export interface PurchaseOrderItem {
    "sku"?: string;
    "cogs"?: number;
    "orderQty"?: number;
}

export interface PurchaseOrderModel {
    "items"?: Array<PurchaseOrderItem>;
    "deliveryDate"?: Date;
    "deliveryCost"?: number;
    "cplId"?: string;
    "offerGuid"?: string;
    "approvedBy"?: string;
    "poGuid"?: string;
}

export interface SessionEventModel {
    "eventMd5"?: string;
    "eventString"?: string;
}

export interface SessionModel {
    "sessionId"?: string;
    "sessionExpiration"?: Date;
    "sessionLastPage"?: string;
    "sessionFbrLhState"?: string;
    "sessionUserGuid"?: string;
    "sessionUserName"?: string;
    "sessionUserFname"?: string;
    "sessionUserImageurl"?: string;
    "sessionUserBalance"?: number;
    "sessionUserUrlProfile"?: string;
    "sessionUserReferralCloudName"?: string;
    "sessionLastQty"?: number;
    "sessionIsBeta"?: number;
    "sessionEmail"?: string;
    "sessionUserAgent"?: string;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
}

export interface SessionTrackModel {
    "sessionTrackId"?: string;
    "trackEvent"?: SessionEventModel;
    "trackDt"?: Date;
    "trackExtra"?: string;
}

export interface ShipOrderResult {
    "cplId"?: string;
    "shippingCaseGuid"?: string;
    "bottles"?: Array<OfferV2ManifestEntity>;
    "totalTax"?: number;
    "taxAlreadyPaid"?: number;
    "taxChargedOrRefunded"?: number;
    "protectShipmentValue"?: number;
    "shipMethods"?: Array<ShippingMethodModel>;
    "iceAvailable"?: boolean;
    "icePrice"?: number;
    "promotionsUsed"?: Array<CheckoutPromoCodeModel>;
    "promoValue"?: number;
    "accountBalanceUsed"?: number;
    "accountBalanceAvailable"?: number;
    "taxComputed"?: TaxInfo;
    "totalPrice"?: number;
    "subtotal"?: number;
}

export interface ShippingAddress {
    "countryCode"?: string;
    "state"?: string;
    "city"?: string;
    "streetLine1"?: string;
    "streetLine2"?: string;
    "postCode"?: string;
}

export interface ShippingMethodModel {
    "name"?: string;
    "description"?: string;
    "price"?: number;
    "guaranteedBy"?: Date;
    "value"?: ShippingMethodModelValueEnum;
}

export type ShippingMethodModelValueEnum = "0" | "1" | "2" | "3";
export interface ShippingModel {
    "shippingPrice"?: number;
    "tax"?: number;
    "iceGelPackPrice"?: number;
    "cplOrderId"?: string;
    "shippingCaseGuid"?: string;
    "shippingMethod"?: string;
    "shippingStatus"?: string;
    "trackingNumber"?: string;
    "date"?: Date;
    "dateProcessed"?: Date;
    "dateDelivered"?: Date;
    "shippedManifests"?: Array<OfferV2ManifestEntity>;
    "payment"?: ApiBillingModelWithAuthnet;
    "giftMessage"?: string;
    "qty"?: number;
    "transactionId"?: string;
    "isAdminHold"?: boolean;
    "willCall"?: boolean;
    "isTest"?: boolean;
    "weight"?: number;
    "firstName"?: string;
    "lastName"?: string;
    "address1"?: string;
    "address2"?: string;
    "city"?: string;
    "state"?: string;
    "zip"?: string;
    "phone"?: string;
    "email"?: string;
    "requestedShipDate"?: Date;
    "xItemCount"?: number;
    "xTotalTax"?: number;
    "xTotalTaxValue"?: number;
    "cohortUserFirstPurchase"?: Date;
    "cohortUserMonth"?: number;
    "monthSinceFirstPurchase"?: number;
    "daysSinceFirstPurchase"?: number;
    "daysSinceLastPurchase"?: number;
    "daysSinceSignup"?: number;
}

export interface ShippingQuery {
    "id"?: string;
    "from"?: User;
    "invoicePayload"?: string;
    "shippingAddress"?: ShippingAddress;
}

export interface SkuBackup {
    "skuBackupId"?: string;
    "originalSku"?: string;
    "newSku"?: string;
    "useAllQtyInStock"?: boolean;
    "newSkuComment"?: string;
    "newSkuQtyAvailable"?: number;
    "newSkuQtyOwed"?: number;
}

export interface SkuDashboard {
    "needRestock"?: Array<SkuTimeStat>;
    "deficitByUsersAffected"?: Array<NhSkuEnRoute>;
    "recentlySold"?: Array<SkuTimeStat>;
    "recentlyArrived"?: Array<SkuTimeStat>;
    "oldStockSku"?: Array<SkuTimeStat>;
    "oldEnRouteSku"?: Array<SkuTimeStat>;
    "usersWaiting30"?: number;
    "usersWaiting60"?: number;
    "usersWaiting90"?: number;
    "usersOk"?: number;
}

export interface SkuEntity {
    "sku"?: string;
    "suggestedPrice"?: number;
    "sellerId"?: string;
    "isAutographed"?: boolean;
    "isDeprecated"?: boolean;
    "isTaxable"?: boolean;
    "isCountedInShipment"?: boolean;
    "isPalletProgram"?: boolean;
    "drinkByDate"?: Date;
    "cacheLatestOrderDate"?: Date;
    "cacheLastRestocked"?: Date;
    "cacheLastUpdated"?: Date;
    "cacheNextDelivery"?: Date;
    "cacheNumAvailable"?: number;
    "scrambleLetters"?: string;
    "scrambleQtyAllowed"?: number;
    "allowedStatesCsv"?: string;
    "comment"?: string;
    "cogsUnit"?: number;
    "taxSetId"?: string;
    "allowedStates"?: Array<string>;
    "cacheNumOwed"?: number;
    "cacheNumShipped"?: number;
    "cacheSurplus"?: number;
    "qtyReserved"?: number;
    "preSwap"?: string;
    "backupSwap"?: string;
    "itemDetailGuid"?: string;
    "itemDetail"?: ItemDetailEntity;
    "skuWasSwap"?: boolean;
    "isInWineDirect"?: boolean;
}

export interface SkuHistory {
    "skuHistoryId"?: string;
    "sku"?: string;
    "snapshotTime"?: Date;
    "available"?: number;
    "owed"?: number;
    "dAvailable"?: number;
    "dOwed"?: number;
    "shipped"?: number;
    "dShipped"?: number;
    "xiGuid"?: string;
}

export interface SkuPlan {
    "sku"?: string;
    "usersNeeded"?: Array<UserPlan>;
}

export interface SkuSale {
    "sku"?: string;
    "price"?: number;
    "name"?: string;
    "varietal"?: string;
    "qtyInOffer"?: number;
    "qtySold"?: number;
    "qtyInStock"?: number;
}

export interface SkuSwapModel {
    "eligibleSkuSwapFrom"?: Array<string>;
    "eligibleSkuSwapTo"?: Array<string>;
    "selectedSkuSwapFrom"?: string;
    "selectedSkuSwapTo"?: Array<string>;
    "eligibleOfferSefToSwapIn"?: Array<string>;
    "selectedOfferSefToSwap"?: string;
    "credit"?: boolean;
    "creditFullValue"?: boolean;
    "qtyToSwap"?: number;
    "swapReason"?: string;
    "sendEmail"?: boolean;
    "manifestsAffected"?: Array<ManifestSwapAction>;
}

export interface SkuTimeStat {
    "sku"?: string;
    "lastNumAvail"?: number;
    "lastNumOwed"?: number;
    "surplus"?: number;
    "firstOwed"?: Date;
    "lastBecameowed"?: Date;
    "lastZerostock"?: Date;
    "lastRestock"?: Date;
    "skuAge"?: number;
    "daysEnroute"?: number;
    "daysSinceRestock"?: number;
    "skuCogsUnit"?: number;
    "isDeprecated"?: boolean;
    "comment"?: string;
    "skuVarietal"?: string;
    "displayName"?: string;
}

export interface Stack {
    "in"?: string;
    "at"?: string;
}

export interface Sticker {
    "width"?: number;
    "height"?: number;
    "thumb"?: PhotoSize;
    "emoji"?: string;
    "setName"?: string;
    "maskPosition"?: MaskPosition;
    "fileId"?: string;
    "fileSize"?: number;
}

export interface SuccessfulPayment {
    "currency"?: string;
    "totalAmount"?: number;
    "invoicePayload"?: string;
    "shippingOptionId"?: string;
    "orderInfo"?: OrderInfo;
    "telegramPaymentChargeId"?: string;
    "providerPaymentChargeId"?: string;
}

export interface SupportRequest {
    "userGuid"?: string;
    "orderGuid"?: string;
    "skuList"?: Array<string>;
    "manifestIds"?: Array<string>;
    "didntLike"?: boolean;
    "damaged"?: boolean;
    "inaccurate"?: boolean;
    "comment"?: string;
    "enRoute"?: boolean;
    "requestTime"?: Date;
    "requestId"?: string;
    "zendeskId"?: string;
}

export interface SupportTicket {
    "id"?: string;
    "subject"?: string;
    "description"?: string;
    "status"?: string;
    "priority"?: string;
    "requesterName"?: string;
    "requesterEmail"?: string;
    "zendeskId"?: string;
    "zendeskUrl"?: string;
    "systemResponse"?: string;
}

export interface SurplusItemDateTime {
    "key"?: Date;
    "surplusQty"?: number;
    "surplusValue"?: number;
    "deficitQty"?: number;
    "deficitValue"?: number;
    "numAvailable"?: number;
    "numOwed"?: number;
}

export interface SurplusItemString {
    "key"?: string;
    "surplusQty"?: number;
    "surplusValue"?: number;
    "deficitQty"?: number;
    "deficitValue"?: number;
    "numAvailable"?: number;
    "numOwed"?: number;
}

export interface TaxInfo {
    "taxRate"?: number;
    "regionName"?: string;
    "orderTaxAmt"?: number;
}

export interface TaxReportRecord {
    "period"?: string;
    "region"?: string;
    "totalTaxValue"?: number;
    "totalTaxAllocated"?: number;
    "skuPrefix"?: string;
}

export interface TimeSeriesCohort {
    "data"?: { [key: string]: NhCohort; };
    "totalPq"?: number;
    "totalOrder"?: number;
    "totalQty"?: number;
    "timeToFirstPurchase"?: number;
}

export interface TimeSeriesCohortSummary {
    "cohorts"?: { [key: string]: TimeSeriesCohort; };
    "avgPq"?: number;
    "avgOrder"?: number;
    "avgQty"?: number;
    "sumByKey"?: TimeSeriesCohort;
}

export interface TimeSeriesReport {
    "entityGuid"?: string;
    "begin"?: Date;
    "end"?: Date;
    "reportDate"?: Date;
    "description"?: string;
}

export interface TupleStringInt32 {
    "item1"?: string;
    "item2"?: number;
}

export interface TupleStringInt32String {
    "item1"?: string;
    "item2"?: number;
    "item3"?: string;
}

export interface TupleStringStringString {
    "item1"?: string;
    "item2"?: string;
    "item3"?: string;
}

export interface TupleWineProductDataNonWineProductData {
    "item1"?: WineProductData;
    "item2"?: NonWineProductData;
}

export interface Update {
    "updateId"?: number;
    "message"?: Message;
    "editedMessage"?: Message;
    "inlineQuery"?: InlineQuery;
    "chosenInlineResult"?: ChosenInlineResult;
    "callbackQuery"?: CallbackQuery;
    "channelPost"?: Message;
    "editedChannelPost"?: Message;
    "shippingQuery"?: ShippingQuery;
    "preCheckoutQuery"?: PreCheckoutQuery;
}

export interface UpdateStockResult {
    "success"?: Array<string>;
    "fail"?: Array<string>;
}

export interface UpgradeOrderResult {
    "bottles"?: Array<NhItemGroupViewEntity>;
    "orderGuid"?: string;
    "orderUserNth"?: number;
    "promotionsUsed"?: Array<CheckoutPromoCodeModel>;
    "promoValue"?: number;
    "accountBalanceUsed"?: number;
    "accountBalanceAvailable"?: number;
    "taxComputed"?: TaxInfo;
    "totalPrice"?: number;
    "subtotal"?: number;
}

export interface User {
    "id"?: number;
    "isBot"?: boolean;
    "firstName"?: string;
    "lastName"?: string;
    "username"?: string;
    "languageCode"?: string;
}

export interface UserAuthModel {
    "sessionId"?: string;
    "password": string;
    "facebookAccessToken"?: string;
    "facebookUserId"?: number;
    "referralString"?: string;
    "clientIpAddress"?: string;
    "is21"?: boolean;
    "referralGroup"?: GroupItemEntity;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "referralCloudcellarName"?: string;
    "referralDomain"?: string;
    "userGuid"?: string;
    "email": string;
    "firstName": string;
    "lastName": string;
    "profileUrl"?: string;
    "birthday"?: Date;
    "isTestAccount"?: boolean;
}

export interface UserAuthResultModel {
    "emailOk"?: boolean;
    "isAuthenticated"?: boolean;
    "hasEmail"?: boolean;
    "hasPassword"?: boolean;
    "hasFbToken"?: boolean;
    "session"?: SessionModel;
    "user"?: UserAuthModel;
}

export interface UserCreditViewModel {
    "userEmail"?: string;
    "userGuid"?: string;
    "event"?: string;
    "eventDate"?: Date;
    "amount"?: number;
    "balance"?: number;
    "creditComment"?: string;
    "creditUsedWithOrders"?: string;
    "creditRefundForOrder"?: string;
    "creditGuid"?: string;
    "creditForManifest"?: string;
    "creditForGiftCard"?: string;
    "creditForShipment"?: string;
    "upgradeEligible"?: boolean;
    "shipmentEligible"?: boolean;
    "itemEligible"?: boolean;
    "chMd5"?: string;
}

export interface UserLifetimeViewRecord {
    "signupMth"?: Date;
    "latestOrder"?: Date;
    "numCustomers"?: number;
    "numUsersActive"?: number;
    "avgOrderCount"?: number;
    "totalOrderCount"?: number;
    "avgTotalOrderValuePerUser"?: number;
    "totalOrderValue"?: number;
    "sum30DayOrderValue"?: number;
    "sum30DayQty"?: number;
    "sum30DayCreditUsed"?: number;
    "sum30DaySpentWithTaxAndDiscount"?: number;
    "sum30DayDiscount"?: number;
    "sum30DayTax"?: number;
    "avg30DayOrderValue"?: number;
    "avg30DayQty"?: number;
    "avg30DayCreditUsed"?: number;
    "avg30DaySpentWithTaxAndDiscount"?: number;
    "avg30DayDiscount"?: number;
    "avg30DayTax"?: number;
    "sum60DayOrderValue"?: number;
    "sum60DayQty"?: number;
    "sum60DayCreditUsed"?: number;
    "sum60DaySpentWithTaxAndDiscount"?: number;
    "sum60DayDiscount"?: number;
    "sum60DayTax"?: number;
    "avg60DayOrderValue"?: number;
    "avg60DayQty"?: number;
    "avg60DayCreditUsed"?: number;
    "avg60DaySpentWithTaxAndDiscount"?: number;
    "avg60DayDiscount"?: number;
    "avg60DayTax"?: number;
    "sum90DayOrderValue"?: number;
    "sum90DayQty"?: number;
    "sum90DayCreditUsed"?: number;
    "sum90DaySpentWithTaxAndDiscount"?: number;
    "sum90DayDiscount"?: number;
    "sum90DayTax"?: number;
    "avg90DayOrderValue"?: number;
    "avg90DayQty"?: number;
    "avg90DayCreditUsed"?: number;
    "avg90DaySpentWithTaxAndDiscount"?: number;
    "avg90DayDiscount"?: number;
    "avg90DayTax"?: number;
    "sum365DayOrderValue"?: number;
    "sum365DayQty"?: number;
    "sum365DayCreditUsed"?: number;
    "sum365DaySpentWithTaxAndDiscount"?: number;
    "sum365DayDiscount"?: number;
    "sum365DayTax"?: number;
    "avg365DayOrderValue"?: number;
    "avg365DayQty"?: number;
    "avg365DayCreditUsed"?: number;
    "avg365DaySpentWithTaxAndDiscount"?: number;
    "avg365DayDiscount"?: number;
    "avg365DayTax"?: number;
    "groupUtmCampaign"?: string;
    "groupUtmSource"?: string;
    "groupUtmMedium"?: string;
}

export interface UserModelExtended {
    "userName"?: string;
    "lastOrder"?: Date;
    "profileImageUrl"?: string;
    "isPrivate"?: boolean;
    "referredByUserId"?: string;
    "defaultAddressId"?: string;
    "defaultPaymentId"?: string;
    "defaultShip"?: number;
    "defaultIce"?: boolean;
    "signupDate"?: Date;
    "lastLoginDate"?: Date;
    "lastPurchaseDate"?: Date;
    "outreachDate"?: Date;
    "sessionId"?: string;
    "password": string;
    "facebookAccessToken"?: string;
    "facebookUserId"?: number;
    "referralString"?: string;
    "clientIpAddress"?: string;
    "is21"?: boolean;
    "referralGroup"?: GroupItemEntity;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "referralCloudcellarName"?: string;
    "referralDomain"?: string;
    "userGuid"?: string;
    "email": string;
    "firstName": string;
    "lastName": string;
    "profileUrl"?: string;
    "birthday"?: Date;
    "isTestAccount"?: boolean;
}

export interface UserPlan {
    "userEmail"?: string;
    "userGuid"?: string;
    "tryToShip"?: Array<TupleStringInt32String>;
}

export interface UserReferralModel {
    "referredUserEmail"?: string;
    "referredUserFname"?: string;
    "referredUserGuid"?: string;
    "referredUserSignupOrInviteDt"?: Date;
    "firstOrderPlaced"?: Date;
    "firstOrderGuid"?: string;
    "referringUserGuid"?: string;
    "referringUserEmail"?: string;
    "creditAmt"?: number;
    "creditDate"?: Date;
    "creditOriginalAmount"?: number;
    "creditId"?: string;
}

export interface UserSummaryViewRecord {
    "userEmail"?: string;
    "userSignupDt"?: Date;
    "userLoginDt"?: Date;
    "userFirstPurchaseDate"?: Date;
    "userLastPurchaseDate"?: Date;
    "orderCount"?: number;
    "lifeOrderValue"?: number;
    "lifeQty"?: number;
    "lifeCreditUsed"?: number;
    "lifeSpentWithTaxAndDiscount"?: number;
    "lifeDiscount"?: number;
    "lifeTax"?: number;
    "x30DayOrderValue"?: number;
    "x30DayQty"?: number;
    "x30DayCreditUsed"?: number;
    "x30DaySpentWithTaxAndDiscount"?: number;
    "x30DayDiscount"?: number;
    "x30DayTax"?: number;
    "x60DayOrderValue"?: number;
    "x60DayQty"?: number;
    "x60DayCreditUsed"?: number;
    "x60DaySpentWithTaxAndDiscount"?: number;
    "x60DayDiscount"?: number;
    "x60DayTax"?: number;
    "x90DayOrderValue"?: number;
    "x90DayQty"?: number;
    "x90DayCreditUsed"?: number;
    "x90DaySpentWithTaxAndDiscount"?: number;
    "x90DayDiscount"?: number;
    "x90DayTax"?: number;
    "x365DayOrderValue"?: number;
    "x365DayQty"?: number;
    "x365DayCreditUsed"?: number;
    "x365DaySpentWithTaxAndDiscount"?: number;
    "x365DayDiscount"?: number;
    "x365DayTax"?: number;
    "userUtmCampaign"?: string;
    "userUtmSource"?: string;
    "userUtmMedium"?: string;
    "lifeSpentPerDay"?: number;
    "lifeShipmentCount"?: number;
    "lifeShipPrice"?: number;
    "lifeShipTax"?: number;
    "lastShipDate"?: Date;
    "totalArv"?: number;
    "totalUnshippedValue"?: number;
    "totalShippedValue"?: number;
    "countUnshipped"?: number;
}

export interface ValidationResult {
    "memberNames"?: Array<string>;
    "errorMessage"?: string;
}

export interface Venue {
    "location"?: Location;
    "title"?: string;
    "address"?: string;
    "foursquareId"?: string;
}

export interface Video {
    "width"?: number;
    "height"?: number;
    "duration"?: number;
    "thumb"?: PhotoSize;
    "mimeType"?: string;
    "fileId"?: string;
    "fileSize"?: number;
}

export interface VideoNote {
    "length"?: number;
    "duration"?: number;
    "thumb"?: PhotoSize;
    "fileId"?: string;
    "fileSize"?: number;
}

export interface Voice {
    "duration"?: number;
    "mimeType"?: string;
    "fileId"?: string;
    "fileSize"?: number;
}

export interface WineGenius {
    "name"?: string;
    "image"?: string;
    "desc"?: string;
    "overallSweet"?: number;
    "overallSour"?: number;
    "overallSalty"?: number;
    "overallBitter"?: number;
    "overallTexture"?: number;
}

export interface WineGeniusData {
    "coffeeBlack"?: boolean;
    "coffeeCream"?: boolean;
    "coffeeCreamSugar"?: boolean;
    "coffeeFrappuccino"?: boolean;
    "saltyPopcorn"?: boolean;
    "charcuterie"?: boolean;
    "applesAndPeanutButter"?: boolean;
    "fruitSmoothie"?: boolean;
    "teriyaki"?: boolean;
    "mushroom"?: boolean;
    "risotto"?: boolean;
    "pastaWithArugula"?: boolean;
    "lemonSorbet"?: boolean;
    "caramelIceCream"?: boolean;
    "darkChocolateMousse"?: boolean;
    "olives"?: boolean;
    "level"?: string;
    "redWhitePosition"?: number;
    "redMin"?: string;
    "redMax"?: string;
    "whiteMin"?: string;
    "whiteMax"?: string;
    "bottlesPerWeek"?: number;
    "sparkling"?: boolean;
    "largeFormat"?: boolean;
    "rare"?: boolean;
    "autographed"?: boolean;
    "highValue"?: boolean;
    "smallProduction"?: boolean;
    "cult"?: boolean;
    "international"?: boolean;
    "firstTrait"?: string;
    "secondTrait"?: string;
    "lastTrait"?: string;
    "budget"?: number;
    "paymentGuid"?: string;
    "surveyDate"?: Date;
    "traits"?: Array<TupleStringInt32>;
    "genius"?: WineGenius;
    "overallSweet"?: number;
    "overallSour"?: number;
    "overallSalty"?: number;
    "overallBitter"?: number;
    "overallTexture"?: number;
}

export interface WineGeniusExclusionItem {
    "userGuid"?: string;
    "email"?: string;
}

export interface WineGeniusMessage {
    "userGuid"?: string;
    "from"?: string;
    "message"?: string;
    "messageDate"?: Date;
}

export interface WineGeniusVacation {
    "dateSet"?: Date;
    "suspendOn"?: Date;
    "resumeOn"?: Date;
    "vacationGuid"?: string;
}

export interface WineProductData {
    "colaNumber"?: string;
    "alcoholType"?: string;
    "countryOfOrigin"?: string;
    "regionOfOrigin"?: string;
    "varietal"?: string;
    "brandName"?: string;
    "fancifulName"?: string;
    "vineyardDesignation"?: string;
    "appellation"?: string;
    "vintage"?: number;
    "bottleSize"?: number;
    "alcoholPercentage"?: number;
    "attributes"?: string;
    "caseQuantity"?: number;
    "supplierNumber"?: number;
    "supplierSku"?: string;
    "description"?: string;
    "retailPrice"?: number;
    "sellingInfo"?: Array<ProductSellingInfo>;
}

export interface WineryModel {
    "wineryId"?: string;
    "winerySef"?: string;
    "wineryAddress"?: string;
    "wineryCity"?: string;
    "wineryFax"?: string;
    "wineryZip"?: string;
    "wineryCountry"?: string;
    "wineryWebsite"?: string;
    "wineryOwners"?: string;
    "wineryWinemakers"?: string;
    "wineryArea"?: string;
    "wineryTourInfo"?: string;
    "wineryHours"?: string;
    "wineryDescription"?: string;
    "wineryLogo"?: string;
    "wineryMainImage"?: string;
    "wineryName"?: string;
    "wineryPublicPhone"?: string;
    "wineryPublicEmail"?: string;
    "wineryDateEstablished"?: Date;
    "wineryPopularVarietals"?: string;
    "wineryContactName"?: string;
    "wineryContactPhone"?: string;
    "wineryContactEmail"?: string;
    "wineryExpectation"?: string;
    "wineryAgreementUrl"?: string;
    "wineryAgreementDocusign"?: string;
    "winerySkuPrefix"?: string;
    "wineryInternalNotes"?: string;
    "wineryUsername"?: string;
    "wineryPasswordHash"?: string;
    "wineryContactedDate"?: Date;
    "wineryState": string;
    "visible"?: boolean;
}

export interface WordGame {
    "letters"?: Array<string>;
    "prizes"?: Array<NhWordGamePrize>;
}



/**
 * AccessLogApi - fetch parameter creator
 */
export const AccessLogApiFetchParamCreator = {
    /**
     * 
     * @param lead 
     */
    accessLogLog(params: {  "lead": AccessLogModel; }, options?: any): FetchArgs {
        // verify required parameter "lead" is set
        if (params["lead"] == null) {
            throw new Error("Missing required parameter lead when calling accessLogLog");
        }
        const baseUrl = `/api/access/log`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["lead"]) {
            fetchOptions.body = JSON.stringify(params["lead"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param lead 
     */
    accessLogPostLead(params: {  "lead": SessionTrackModel; }, options?: any): FetchArgs {
        // verify required parameter "lead" is set
        if (params["lead"] == null) {
            throw new Error("Missing required parameter lead when calling accessLogPostLead");
        }
        const baseUrl = `/api/access/lead`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["lead"]) {
            fetchOptions.body = JSON.stringify(params["lead"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccessLogApi - functional programming interface
 */
export const AccessLogApiFp = {
    /**
     * 
     * @param lead 
     */
    accessLogLog(params: { "lead": AccessLogModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccessLogApiFetchParamCreator.accessLogLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param lead 
     */
    accessLogPostLead(params: { "lead": SessionTrackModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccessLogApiFetchParamCreator.accessLogPostLead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccessLogApi - object-oriented interface
 */
export class AccessLogApi extends BaseAPI {
    /**
     * 
     * @param lead 
     */
    accessLogLog(params: {  "lead": AccessLogModel; }, options?: any) {
        return AccessLogApiFp.accessLogLog(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param lead 
     */
    accessLogPostLead(params: {  "lead": SessionTrackModel; }, options?: any) {
        return AccessLogApiFp.accessLogPostLead(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccessLogApi - factory interface
 */
export const AccessLogApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param lead 
         */
        accessLogLog(params: {  "lead": AccessLogModel; }, options?: any) {
            return AccessLogApiFp.accessLogLog(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param lead 
         */
        accessLogPostLead(params: {  "lead": SessionTrackModel; }, options?: any) {
            return AccessLogApiFp.accessLogPostLead(params, options)(fetch, basePath);
        },
    };
};


/**
 * AchievementApi - fetch parameter creator
 */
export const AchievementApiFetchParamCreator = {
    /**
     * 
     * @param userId 
     */
    achievementGetAchievementForUser(params: {  "userId": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling achievementGetAchievementForUser");
        }
        const baseUrl = `/api/contest/{userId}/achievements`
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userId 
     */
    achievementGetLeaderboardForUser(params: {  "userId": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling achievementGetLeaderboardForUser");
        }
        const baseUrl = `/api/contest/{userId}/leaderboard`
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AchievementApi - functional programming interface
 */
export const AchievementApiFp = {
    /**
     * 
     * @param userId 
     */
    achievementGetAchievementForUser(params: { "userId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AchievementModel>> {
        const fetchArgs = AchievementApiFetchParamCreator.achievementGetAchievementForUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userId 
     */
    achievementGetLeaderboardForUser(params: { "userId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardModel> {
        const fetchArgs = AchievementApiFetchParamCreator.achievementGetLeaderboardForUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AchievementApi - object-oriented interface
 */
export class AchievementApi extends BaseAPI {
    /**
     * 
     * @param userId 
     */
    achievementGetAchievementForUser(params: {  "userId": string; }, options?: any) {
        return AchievementApiFp.achievementGetAchievementForUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userId 
     */
    achievementGetLeaderboardForUser(params: {  "userId": string; }, options?: any) {
        return AchievementApiFp.achievementGetLeaderboardForUser(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AchievementApi - factory interface
 */
export const AchievementApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param userId 
         */
        achievementGetAchievementForUser(params: {  "userId": string; }, options?: any) {
            return AchievementApiFp.achievementGetAchievementForUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userId 
         */
        achievementGetLeaderboardForUser(params: {  "userId": string; }, options?: any) {
            return AchievementApiFp.achievementGetLeaderboardForUser(params, options)(fetch, basePath);
        },
    };
};


/**
 * AddressApi - fetch parameter creator
 */
export const AddressApiFetchParamCreator = {
    /**
     * 
     * @summary Deletes a user's stored address.
     * @param sessionId 
     * @param addressId Address id to delete.
     */
    addressSessionDeleteAddress(params: {  "sessionId": string; "addressId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionDeleteAddress");
        }
        // verify required parameter "addressId" is set
        if (params["addressId"] == null) {
            throw new Error("Missing required parameter addressId when calling addressSessionDeleteAddress");
        }
        const baseUrl = `/api/session/{sessionId}/user-address/{addressId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"addressId"}}`, `${ params["addressId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressDictionary(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionGetAddressDictionary");
        }
        const baseUrl = `/api/session/{sessionId}/user-address`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionGetAddressList");
        }
        const baseUrl = `/api/session/{sessionId}/user-address/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList3(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionGetAddressList3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/user-address`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Adds an address to a user's account
     * @param sessionId User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressSessionPostAddress3(params: {  "sessionId": string; "address": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionPostAddress3");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling addressSessionPostAddress3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/user-address`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Updates a user's stored address.
     * @param sessionId Session id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressSessionPutAddress(params: {  "sessionId": string; "addressId": string; "address": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionPutAddress");
        }
        // verify required parameter "addressId" is set
        if (params["addressId"] == null) {
            throw new Error("Missing required parameter addressId when calling addressSessionPutAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling addressSessionPutAddress");
        }
        const baseUrl = `/api/session/{sessionId}/user-address/{addressId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"addressId"}}`, `${ params["addressId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes a user's stored address.
     * @param userGuid Id of the user to delete the address from (for verification against the owner of the address Id,  specified in the request body &#39;address&#39;)
     * @param addressId Address id to delete.
     */
    addressUserDeleteAddress(params: {  "userGuid": string; "addressId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling addressUserDeleteAddress");
        }
        // verify required parameter "addressId" is set
        if (params["addressId"] == null) {
            throw new Error("Missing required parameter addressId when calling addressUserDeleteAddress");
        }
        const baseUrl = `/api/user/{userGuid}/address/{addressId}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"addressId"}}`, `${ params["addressId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param userGuid Id of the user to get addresses from.
     */
    addressUserGetAddressDictionary(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling addressUserGetAddressDictionary");
        }
        const baseUrl = `/api/user/{userGuid}/address`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Adds an address to a user's account
     * @param userGuid User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressUserPostAddress(params: {  "userGuid": string; "address": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling addressUserPostAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling addressUserPostAddress");
        }
        const baseUrl = `/api/user/{userGuid}/address`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Updates a user's stored address.
     * @param userGuid User id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressUserPutAddress(params: {  "userGuid": string; "addressId": string; "address": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling addressUserPutAddress");
        }
        // verify required parameter "addressId" is set
        if (params["addressId"] == null) {
            throw new Error("Missing required parameter addressId when calling addressUserPutAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling addressUserPutAddress");
        }
        const baseUrl = `/api/user/{userGuid}/address/{addressId}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"addressId"}}`, `${ params["addressId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AddressApi - functional programming interface
 */
export const AddressApiFp = {
    /**
     * 
     * @summary Deletes a user's stored address.
     * @param sessionId 
     * @param addressId Address id to delete.
     */
    addressSessionDeleteAddress(params: { "sessionId": string; "addressId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionDeleteAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressDictionary(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: NhAddressModel; }> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionGetAddressDictionary(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhAddressModel>> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionGetAddressList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList3(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhAddressModel> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionGetAddressList3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Adds an address to a user's account
     * @param sessionId User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressSessionPostAddress3(params: { "sessionId": string; "address": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhAddressModel> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionPostAddress3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Updates a user's stored address.
     * @param sessionId Session id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressSessionPutAddress(params: { "sessionId": string; "addressId": string; "address": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhAddressModel> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionPutAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes a user's stored address.
     * @param userGuid Id of the user to delete the address from (for verification against the owner of the address Id,  specified in the request body &#39;address&#39;)
     * @param addressId Address id to delete.
     */
    addressUserDeleteAddress(params: { "userGuid": string; "addressId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreator.addressUserDeleteAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param userGuid Id of the user to get addresses from.
     */
    addressUserGetAddressDictionary(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: NhAddressModel; }> {
        const fetchArgs = AddressApiFetchParamCreator.addressUserGetAddressDictionary(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Adds an address to a user's account
     * @param userGuid User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressUserPostAddress(params: { "userGuid": string; "address": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreator.addressUserPostAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Updates a user's stored address.
     * @param userGuid User id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressUserPutAddress(params: { "userGuid": string; "addressId": string; "address": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreator.addressUserPutAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AddressApi - object-oriented interface
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a user's stored address.
     * @param sessionId 
     * @param addressId Address id to delete.
     */
    addressSessionDeleteAddress(params: {  "sessionId": string; "addressId": string; }, options?: any) {
        return AddressApiFp.addressSessionDeleteAddress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressDictionary(params: {  "sessionId": string; }, options?: any) {
        return AddressApiFp.addressSessionGetAddressDictionary(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList(params: {  "sessionId": string; }, options?: any) {
        return AddressApiFp.addressSessionGetAddressList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList3(params: {  "sessionId": string; }, options?: any) {
        return AddressApiFp.addressSessionGetAddressList3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Adds an address to a user's account
     * @param sessionId User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressSessionPostAddress3(params: {  "sessionId": string; "address": NhAddressModel; }, options?: any) {
        return AddressApiFp.addressSessionPostAddress3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Updates a user's stored address.
     * @param sessionId Session id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressSessionPutAddress(params: {  "sessionId": string; "addressId": string; "address": NhAddressModel; }, options?: any) {
        return AddressApiFp.addressSessionPutAddress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes a user's stored address.
     * @param userGuid Id of the user to delete the address from (for verification against the owner of the address Id,  specified in the request body &#39;address&#39;)
     * @param addressId Address id to delete.
     */
    addressUserDeleteAddress(params: {  "userGuid": string; "addressId": string; }, options?: any) {
        return AddressApiFp.addressUserDeleteAddress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets the addresses for a specified user.
     * @param userGuid Id of the user to get addresses from.
     */
    addressUserGetAddressDictionary(params: {  "userGuid": string; }, options?: any) {
        return AddressApiFp.addressUserGetAddressDictionary(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Adds an address to a user's account
     * @param userGuid User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressUserPostAddress(params: {  "userGuid": string; "address": NhAddressModel; }, options?: any) {
        return AddressApiFp.addressUserPostAddress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Updates a user's stored address.
     * @param userGuid User id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressUserPutAddress(params: {  "userGuid": string; "addressId": string; "address": NhAddressModel; }, options?: any) {
        return AddressApiFp.addressUserPutAddress(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AddressApi - factory interface
 */
export const AddressApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes a user's stored address.
         * @param sessionId 
         * @param addressId Address id to delete.
         */
        addressSessionDeleteAddress(params: {  "sessionId": string; "addressId": string; }, options?: any) {
            return AddressApiFp.addressSessionDeleteAddress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the addresses for a specified user.
         * @param sessionId sessionId of the user to get addresses from.
         */
        addressSessionGetAddressDictionary(params: {  "sessionId": string; }, options?: any) {
            return AddressApiFp.addressSessionGetAddressDictionary(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the addresses for a specified user.
         * @param sessionId sessionId of the user to get addresses from.
         */
        addressSessionGetAddressList(params: {  "sessionId": string; }, options?: any) {
            return AddressApiFp.addressSessionGetAddressList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the addresses for a specified user.
         * @param sessionId sessionId of the user to get addresses from.
         */
        addressSessionGetAddressList3(params: {  "sessionId": string; }, options?: any) {
            return AddressApiFp.addressSessionGetAddressList3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds an address to a user's account
         * @param sessionId User id to add the address to
         * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
         */
        addressSessionPostAddress3(params: {  "sessionId": string; "address": NhAddressModel; }, options?: any) {
            return AddressApiFp.addressSessionPostAddress3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a user's stored address.
         * @param sessionId Session id that owns the address
         * @param addressId specifies the address Id to update
         * @param address Address to update, with updated data.
         */
        addressSessionPutAddress(params: {  "sessionId": string; "addressId": string; "address": NhAddressModel; }, options?: any) {
            return AddressApiFp.addressSessionPutAddress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a user's stored address.
         * @param userGuid Id of the user to delete the address from (for verification against the owner of the address Id,  specified in the request body &#39;address&#39;)
         * @param addressId Address id to delete.
         */
        addressUserDeleteAddress(params: {  "userGuid": string; "addressId": string; }, options?: any) {
            return AddressApiFp.addressUserDeleteAddress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the addresses for a specified user.
         * @param userGuid Id of the user to get addresses from.
         */
        addressUserGetAddressDictionary(params: {  "userGuid": string; }, options?: any) {
            return AddressApiFp.addressUserGetAddressDictionary(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds an address to a user's account
         * @param userGuid User id to add the address to
         * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
         */
        addressUserPostAddress(params: {  "userGuid": string; "address": NhAddressModel; }, options?: any) {
            return AddressApiFp.addressUserPostAddress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a user's stored address.
         * @param userGuid User id that owns the address
         * @param addressId specifies the address Id to update
         * @param address Address to update, with updated data.
         */
        addressUserPutAddress(params: {  "userGuid": string; "addressId": string; "address": NhAddressModel; }, options?: any) {
            return AddressApiFp.addressUserPutAddress(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdjustmentApi - fetch parameter creator
 */
export const AdjustmentApiFetchParamCreator = {
    /**
     * 
     * @param model 
     */
    adjustmentCreateAdjustmentForSku(params: {  "model": NhAdjustment; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling adjustmentCreateAdjustmentForSku");
        }
        const baseUrl = `/api/admin/adjustment/list`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param id 
     */
    adjustmentExecAdjustment(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adjustmentExecAdjustment");
        }
        const baseUrl = `/api/admin/adjustment/exec/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdjustmentApi - functional programming interface
 */
export const AdjustmentApiFp = {
    /**
     * 
     * @param model 
     */
    adjustmentCreateAdjustmentForSku(params: { "model": NhAdjustment;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhAdjustment> {
        const fetchArgs = AdjustmentApiFetchParamCreator.adjustmentCreateAdjustmentForSku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param id 
     */
    adjustmentExecAdjustment(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OfferV2ManifestEntity>> {
        const fetchArgs = AdjustmentApiFetchParamCreator.adjustmentExecAdjustment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdjustmentApi - object-oriented interface
 */
export class AdjustmentApi extends BaseAPI {
    /**
     * 
     * @param model 
     */
    adjustmentCreateAdjustmentForSku(params: {  "model": NhAdjustment; }, options?: any) {
        return AdjustmentApiFp.adjustmentCreateAdjustmentForSku(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param id 
     */
    adjustmentExecAdjustment(params: {  "id": string; }, options?: any) {
        return AdjustmentApiFp.adjustmentExecAdjustment(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdjustmentApi - factory interface
 */
export const AdjustmentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param model 
         */
        adjustmentCreateAdjustmentForSku(params: {  "model": NhAdjustment; }, options?: any) {
            return AdjustmentApiFp.adjustmentCreateAdjustmentForSku(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param id 
         */
        adjustmentExecAdjustment(params: {  "id": string; }, options?: any) {
            return AdjustmentApiFp.adjustmentExecAdjustment(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdminCampaignApi - fetch parameter creator
 */
export const AdminCampaignApiFetchParamCreator = {
    /**
     * 
     * @param campaignId 
     */
    adminCampaignExport(params: {  "campaignId": number; }, options?: any): FetchArgs {
        // verify required parameter "campaignId" is set
        if (params["campaignId"] == null) {
            throw new Error("Missing required parameter campaignId when calling adminCampaignExport");
        }
        const baseUrl = `/api/admin/campaign/export/{campaignId}`
            .replace(`{${"campaignId"}}`, `${ params["campaignId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param campaignId 
     */
    adminCampaignPick(params: {  "campaignId": number; }, options?: any): FetchArgs {
        // verify required parameter "campaignId" is set
        if (params["campaignId"] == null) {
            throw new Error("Missing required parameter campaignId when calling adminCampaignPick");
        }
        const baseUrl = `/api/admin/campaign/pick/{campaignId}`
            .replace(`{${"campaignId"}}`, `${ params["campaignId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminCampaignApi - functional programming interface
 */
export const AdminCampaignApiFp = {
    /**
     * 
     * @param campaignId 
     */
    adminCampaignExport(params: { "campaignId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CampaignExportModel>> {
        const fetchArgs = AdminCampaignApiFetchParamCreator.adminCampaignExport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param campaignId 
     */
    adminCampaignPick(params: { "campaignId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CampaignExportModel> {
        const fetchArgs = AdminCampaignApiFetchParamCreator.adminCampaignPick(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminCampaignApi - object-oriented interface
 */
export class AdminCampaignApi extends BaseAPI {
    /**
     * 
     * @param campaignId 
     */
    adminCampaignExport(params: {  "campaignId": number; }, options?: any) {
        return AdminCampaignApiFp.adminCampaignExport(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param campaignId 
     */
    adminCampaignPick(params: {  "campaignId": number; }, options?: any) {
        return AdminCampaignApiFp.adminCampaignPick(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdminCampaignApi - factory interface
 */
export const AdminCampaignApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param campaignId 
         */
        adminCampaignExport(params: {  "campaignId": number; }, options?: any) {
            return AdminCampaignApiFp.adminCampaignExport(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param campaignId 
         */
        adminCampaignPick(params: {  "campaignId": number; }, options?: any) {
            return AdminCampaignApiFp.adminCampaignPick(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdminDeliveryApi - fetch parameter creator
 */
export const AdminDeliveryApiFetchParamCreator = {
    /**
     * 
     * @param model 
     */
    adminDeliveryCreateDelivery(params: {  "model": AdminSkuDelivery; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling adminDeliveryCreateDelivery");
        }
        const baseUrl = `/api/admin/SkuDelivery`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    adminDeliveryListDeliveries(options?: any): FetchArgs {
        const baseUrl = `/api/admin/SkuDelivery`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminDeliveryApi - functional programming interface
 */
export const AdminDeliveryApiFp = {
    /**
     * 
     * @param model 
     */
    adminDeliveryCreateDelivery(params: { "model": AdminSkuDelivery;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminSkuDelivery> {
        const fetchArgs = AdminDeliveryApiFetchParamCreator.adminDeliveryCreateDelivery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    adminDeliveryListDeliveries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhSkuDelivery>> {
        const fetchArgs = AdminDeliveryApiFetchParamCreator.adminDeliveryListDeliveries(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminDeliveryApi - object-oriented interface
 */
export class AdminDeliveryApi extends BaseAPI {
    /**
     * 
     * @param model 
     */
    adminDeliveryCreateDelivery(params: {  "model": AdminSkuDelivery; }, options?: any) {
        return AdminDeliveryApiFp.adminDeliveryCreateDelivery(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    adminDeliveryListDeliveries(options?: any) {
        return AdminDeliveryApiFp.adminDeliveryListDeliveries(options)(this.fetch, this.basePath);
    }
};

/**
 * AdminDeliveryApi - factory interface
 */
export const AdminDeliveryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param model 
         */
        adminDeliveryCreateDelivery(params: {  "model": AdminSkuDelivery; }, options?: any) {
            return AdminDeliveryApiFp.adminDeliveryCreateDelivery(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        adminDeliveryListDeliveries(options?: any) {
            return AdminDeliveryApiFp.adminDeliveryListDeliveries(options)(fetch, basePath);
        },
    };
};


/**
 * AdminOrderApi - fetch parameter creator
 */
export const AdminOrderApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param fix 
     * @param orderGuid 
     */
    adminOrderArFindMisallocations(params: {  "sessionId": string; "fix"?: boolean; "orderGuid"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderArFindMisallocations");
        }
        const baseUrl = `/api/admin/misallocations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "fix": params["fix"],
            "orderGuid": params["orderGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieves detail, including bottle info, about a specific order.
     * @param sessionId Admin session id.
     * @param id Order id.
     */
    adminOrderArOrderById(params: {  "sessionId": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderArOrderById");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderById");
        }
        const baseUrl = `/api/admin/orders/byId/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    adminOrderArOrderCaptureSingle(params: {  "sessionId": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderArOrderCaptureSingle");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderCaptureSingle");
        }
        const baseUrl = `/api/captureOrder/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     * @param promoCode 
     */
    adminOrderArOrderPromoApply(params: {  "sessionId": string; "id": string; "promoCode": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderArOrderPromoApply");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderPromoApply");
        }
        // verify required parameter "promoCode" is set
        if (params["promoCode"] == null) {
            throw new Error("Missing required parameter promoCode when calling adminOrderArOrderPromoApply");
        }
        const baseUrl = `/api/admin/orders/byId/{id}/promocode`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "promoCode": params["promoCode"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Updates the order status of one or more order(s).
     * @param sessionId Admin session id.
     * @param details The orders to update (order id and status must be filled in).
     */
    adminOrderArOrderPut(params: {  "sessionId": string; "details": Array<NhOrderModel>; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderArOrderPut");
        }
        // verify required parameter "details" is set
        if (params["details"] == null) {
            throw new Error("Missing required parameter details when calling adminOrderArOrderPut");
        }
        const baseUrl = `/api/admin/orders/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["details"]) {
            fetchOptions.body = JSON.stringify(params["details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     * @param background 
     */
    adminOrderArOrderReject(params: {  "sessionId": string; "id": string; "background"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderArOrderReject");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderReject");
        }
        const baseUrl = `/api/admin/orders/byId/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "background": params["background"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    adminOrderArOrderRepick(params: {  "sessionId": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderArOrderRepick");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderRepick");
        }
        const baseUrl = `/api/admin/orders/byId/{id}/repick`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets a list of orders, with paging information. Can also filter the orders based on a search criterion. Bottle  information is not available.
     * @param sessionId Admin session id.
     * @param skip Skip.
     * @param take Take.
     * @param search Search.
     */
    adminOrderArOrderSearch(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderArOrderSearch");
        }
        const baseUrl = `/api/admin/orders/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param cardNo 
     * @param amount 
     * @param year 
     * @param month 
     */
    adminOrderFindChargeback(params: {  "sessionId": string; "cardNo": string; "amount": number; "year": number; "month": number; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminOrderFindChargeback");
        }
        // verify required parameter "cardNo" is set
        if (params["cardNo"] == null) {
            throw new Error("Missing required parameter cardNo when calling adminOrderFindChargeback");
        }
        // verify required parameter "amount" is set
        if (params["amount"] == null) {
            throw new Error("Missing required parameter amount when calling adminOrderFindChargeback");
        }
        // verify required parameter "year" is set
        if (params["year"] == null) {
            throw new Error("Missing required parameter year when calling adminOrderFindChargeback");
        }
        // verify required parameter "month" is set
        if (params["month"] == null) {
            throw new Error("Missing required parameter month when calling adminOrderFindChargeback");
        }
        const baseUrl = `/api/admin/orders/researchChargeback`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "cardNo": params["cardNo"],
            "amount": params["amount"],
            "year": params["year"],
            "month": params["month"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    adminOrderRunHourlyTasks(options?: any): FetchArgs {
        const baseUrl = `/api/hourly`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminOrderApi - functional programming interface
 */
export const AdminOrderApiFp = {
    /**
     * 
     * @param sessionId 
     * @param fix 
     * @param orderGuid 
     */
    adminOrderArFindMisallocations(params: { "sessionId": string; "fix"?: boolean; "orderGuid"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListMisallocation> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArFindMisallocations(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieves detail, including bottle info, about a specific order.
     * @param sessionId Admin session id.
     * @param id Order id.
     */
    adminOrderArOrderById(params: { "sessionId": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhOrderModel> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    adminOrderArOrderCaptureSingle(params: { "sessionId": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListGuid> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderCaptureSingle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     * @param promoCode 
     */
    adminOrderArOrderPromoApply(params: { "sessionId": string; "id": string; "promoCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhOrderModel> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderPromoApply(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Updates the order status of one or more order(s).
     * @param sessionId Admin session id.
     * @param details The orders to update (order id and status must be filled in).
     */
    adminOrderArOrderPut(params: { "sessionId": string; "details": Array<NhOrderModel>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     * @param background 
     */
    adminOrderArOrderReject(params: { "sessionId": string; "id": string; "background"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderReject(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    adminOrderArOrderRepick(params: { "sessionId": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultManifestList> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderRepick(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets a list of orders, with paging information. Can also filter the orders based on a search criterion. Bottle  information is not available.
     * @param sessionId Admin session id.
     * @param skip Skip.
     * @param take Take.
     * @param search Search.
     */
    adminOrderArOrderSearch(params: { "sessionId": string; "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhOrderModel> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderSearch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param cardNo 
     * @param amount 
     * @param year 
     * @param month 
     */
    adminOrderFindChargeback(params: { "sessionId": string; "cardNo": string; "amount": number; "year": number; "month": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListChargebackSearchResult> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderFindChargeback(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    adminOrderRunHourlyTasks(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderRunHourlyTasks(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminOrderApi - object-oriented interface
 */
export class AdminOrderApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param fix 
     * @param orderGuid 
     */
    adminOrderArFindMisallocations(params: {  "sessionId": string; "fix"?: boolean; "orderGuid"?: string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArFindMisallocations(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieves detail, including bottle info, about a specific order.
     * @param sessionId Admin session id.
     * @param id Order id.
     */
    adminOrderArOrderById(params: {  "sessionId": string; "id": string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    adminOrderArOrderCaptureSingle(params: {  "sessionId": string; "id": string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderCaptureSingle(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param id 
     * @param promoCode 
     */
    adminOrderArOrderPromoApply(params: {  "sessionId": string; "id": string; "promoCode": string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderPromoApply(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Updates the order status of one or more order(s).
     * @param sessionId Admin session id.
     * @param details The orders to update (order id and status must be filled in).
     */
    adminOrderArOrderPut(params: {  "sessionId": string; "details": Array<NhOrderModel>; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param id 
     * @param background 
     */
    adminOrderArOrderReject(params: {  "sessionId": string; "id": string; "background"?: boolean; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderReject(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    adminOrderArOrderRepick(params: {  "sessionId": string; "id": string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderRepick(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets a list of orders, with paging information. Can also filter the orders based on a search criterion. Bottle  information is not available.
     * @param sessionId Admin session id.
     * @param skip Skip.
     * @param take Take.
     * @param search Search.
     */
    adminOrderArOrderSearch(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderSearch(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param cardNo 
     * @param amount 
     * @param year 
     * @param month 
     */
    adminOrderFindChargeback(params: {  "sessionId": string; "cardNo": string; "amount": number; "year": number; "month": number; }, options?: any) {
        return AdminOrderApiFp.adminOrderFindChargeback(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    adminOrderRunHourlyTasks(options?: any) {
        return AdminOrderApiFp.adminOrderRunHourlyTasks(options)(this.fetch, this.basePath);
    }
};

/**
 * AdminOrderApi - factory interface
 */
export const AdminOrderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param fix 
         * @param orderGuid 
         */
        adminOrderArFindMisallocations(params: {  "sessionId": string; "fix"?: boolean; "orderGuid"?: string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArFindMisallocations(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves detail, including bottle info, about a specific order.
         * @param sessionId Admin session id.
         * @param id Order id.
         */
        adminOrderArOrderById(params: {  "sessionId": string; "id": string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param id 
         */
        adminOrderArOrderCaptureSingle(params: {  "sessionId": string; "id": string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderCaptureSingle(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param id 
         * @param promoCode 
         */
        adminOrderArOrderPromoApply(params: {  "sessionId": string; "id": string; "promoCode": string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderPromoApply(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the order status of one or more order(s).
         * @param sessionId Admin session id.
         * @param details The orders to update (order id and status must be filled in).
         */
        adminOrderArOrderPut(params: {  "sessionId": string; "details": Array<NhOrderModel>; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderPut(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param id 
         * @param background 
         */
        adminOrderArOrderReject(params: {  "sessionId": string; "id": string; "background"?: boolean; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderReject(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param id 
         */
        adminOrderArOrderRepick(params: {  "sessionId": string; "id": string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderRepick(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets a list of orders, with paging information. Can also filter the orders based on a search criterion. Bottle  information is not available.
         * @param sessionId Admin session id.
         * @param skip Skip.
         * @param take Take.
         * @param search Search.
         */
        adminOrderArOrderSearch(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderSearch(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param cardNo 
         * @param amount 
         * @param year 
         * @param month 
         */
        adminOrderFindChargeback(params: {  "sessionId": string; "cardNo": string; "amount": number; "year": number; "month": number; }, options?: any) {
            return AdminOrderApiFp.adminOrderFindChargeback(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        adminOrderRunHourlyTasks(options?: any) {
            return AdminOrderApiFp.adminOrderRunHourlyTasks(options)(fetch, basePath);
        },
    };
};


/**
 * AdminPromoCodeApi - fetch parameter creator
 */
export const AdminPromoCodeApiFetchParamCreator = {
    /**
     * 
     * @summary Deactivates a promo code so it can't be used.
     * @param sessionId Admin Session ID
     * @param code Promo code to deactivate.
     */
    adminPromoCodeDelete(params: {  "sessionId": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminPromoCodeDelete");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling adminPromoCodeDelete");
        }
        const baseUrl = `/api/admin/promo`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "code": params["code"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets a single promo code, or a list of promo codes.
     * @param sessionId Admin Session ID
     * @param search 
     * @param skip 
     * @param take 
     */
    adminPromoCodeGet(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminPromoCodeGet");
        }
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling adminPromoCodeGet");
        }
        const baseUrl = `/api/admin/promo`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new promo code.
     * @param sessionId Admin Session ID
     * @param model 
     */
    adminPromoCodePost(params: {  "sessionId": string; "model": NhPromoCodeModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminPromoCodePost");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling adminPromoCodePost");
        }
        const baseUrl = `/api/admin/promo`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Updates a new promo code.
     * @param sessionId Admin Session ID
     * @param model 
     */
    adminPromoCodePut(params: {  "sessionId": string; "model": NhPromoCodeModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminPromoCodePut");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling adminPromoCodePut");
        }
        const baseUrl = `/api/admin/promo`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminPromoCodeApi - functional programming interface
 */
export const AdminPromoCodeApiFp = {
    /**
     * 
     * @summary Deactivates a promo code so it can't be used.
     * @param sessionId Admin Session ID
     * @param code Promo code to deactivate.
     */
    adminPromoCodeDelete(params: { "sessionId": string; "code": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodeDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets a single promo code, or a list of promo codes.
     * @param sessionId Admin Session ID
     * @param search 
     * @param skip 
     * @param take 
     */
    adminPromoCodeGet(params: { "sessionId": string; "search": string; "skip"?: number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhPromoCodeModel> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new promo code.
     * @param sessionId Admin Session ID
     * @param model 
     */
    adminPromoCodePost(params: { "sessionId": string; "model": NhPromoCodeModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhPromoCodeModel> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Updates a new promo code.
     * @param sessionId Admin Session ID
     * @param model 
     */
    adminPromoCodePut(params: { "sessionId": string; "model": NhPromoCodeModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodePut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminPromoCodeApi - object-oriented interface
 */
export class AdminPromoCodeApi extends BaseAPI {
    /**
     * 
     * @summary Deactivates a promo code so it can't be used.
     * @param sessionId Admin Session ID
     * @param code Promo code to deactivate.
     */
    adminPromoCodeDelete(params: {  "sessionId": string; "code": string; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodeDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets a single promo code, or a list of promo codes.
     * @param sessionId Admin Session ID
     * @param search 
     * @param skip 
     * @param take 
     */
    adminPromoCodeGet(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodeGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new promo code.
     * @param sessionId Admin Session ID
     * @param model 
     */
    adminPromoCodePost(params: {  "sessionId": string; "model": NhPromoCodeModel; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Updates a new promo code.
     * @param sessionId Admin Session ID
     * @param model 
     */
    adminPromoCodePut(params: {  "sessionId": string; "model": NhPromoCodeModel; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodePut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdminPromoCodeApi - factory interface
 */
export const AdminPromoCodeApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deactivates a promo code so it can't be used.
         * @param sessionId Admin Session ID
         * @param code Promo code to deactivate.
         */
        adminPromoCodeDelete(params: {  "sessionId": string; "code": string; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodeDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets a single promo code, or a list of promo codes.
         * @param sessionId Admin Session ID
         * @param search 
         * @param skip 
         * @param take 
         */
        adminPromoCodeGet(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodeGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new promo code.
         * @param sessionId Admin Session ID
         * @param model 
         */
        adminPromoCodePost(params: {  "sessionId": string; "model": NhPromoCodeModel; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodePost(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a new promo code.
         * @param sessionId Admin Session ID
         * @param model 
         */
        adminPromoCodePut(params: {  "sessionId": string; "model": NhPromoCodeModel; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodePut(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdminReferralApi - fetch parameter creator
 */
export const AdminReferralApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     */
    adminReferralGet(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminReferralGet");
        }
        const baseUrl = `/api/admin/referral`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param skip 
     * @param take 
     */
    adminReferralGet_1(params: {  "sessionId": string; "userId": string; "skip"?: number; "take"?: number; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling adminReferralGet_1");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling adminReferralGet_1");
        }
        const baseUrl = `/api/admin/referrals/list/byUser/{userId}`
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Sets the referral of user. Doesn't automatically give  the bonus; the bonus must manually be added by the admin if the referred user already made first purchase. If the  referred user later  makes the first purchase, then the system will automatically credit the appropriate awards.
     * @param userGuid User id
     * @param data Email address of user to credit with referral
     */
    adminReferralPost(params: {  "userGuid": string; "data": AdminReferralModel; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling adminReferralPost");
        }
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling adminReferralPost");
        }
        const baseUrl = `/api/admin/referral/{userGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminReferralApi - functional programming interface
 */
export const AdminReferralApiFp = {
    /**
     * 
     * @param sessionId 
     */
    adminReferralGet(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListUserReferralModel> {
        const fetchArgs = AdminReferralApiFetchParamCreator.adminReferralGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param skip 
     * @param take 
     */
    adminReferralGet_1(params: { "sessionId": string; "userId": string; "skip"?: number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserReferralModel>> {
        const fetchArgs = AdminReferralApiFetchParamCreator.adminReferralGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Sets the referral of user. Doesn't automatically give  the bonus; the bonus must manually be added by the admin if the referred user already made first purchase. If the  referred user later  makes the first purchase, then the system will automatically credit the appropriate awards.
     * @param userGuid User id
     * @param data Email address of user to credit with referral
     */
    adminReferralPost(params: { "userGuid": string; "data": AdminReferralModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminReferralApiFetchParamCreator.adminReferralPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminReferralApi - object-oriented interface
 */
export class AdminReferralApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     */
    adminReferralGet(params: {  "sessionId": string; }, options?: any) {
        return AdminReferralApiFp.adminReferralGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param skip 
     * @param take 
     */
    adminReferralGet_1(params: {  "sessionId": string; "userId": string; "skip"?: number; "take"?: number; }, options?: any) {
        return AdminReferralApiFp.adminReferralGet_1(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Sets the referral of user. Doesn't automatically give  the bonus; the bonus must manually be added by the admin if the referred user already made first purchase. If the  referred user later  makes the first purchase, then the system will automatically credit the appropriate awards.
     * @param userGuid User id
     * @param data Email address of user to credit with referral
     */
    adminReferralPost(params: {  "userGuid": string; "data": AdminReferralModel; }, options?: any) {
        return AdminReferralApiFp.adminReferralPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdminReferralApi - factory interface
 */
export const AdminReferralApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         */
        adminReferralGet(params: {  "sessionId": string; }, options?: any) {
            return AdminReferralApiFp.adminReferralGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param userId 
         * @param skip 
         * @param take 
         */
        adminReferralGet_1(params: {  "sessionId": string; "userId": string; "skip"?: number; "take"?: number; }, options?: any) {
            return AdminReferralApiFp.adminReferralGet_1(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sets the referral of user. Doesn't automatically give  the bonus; the bonus must manually be added by the admin if the referred user already made first purchase. If the  referred user later  makes the first purchase, then the system will automatically credit the appropriate awards.
         * @param userGuid User id
         * @param data Email address of user to credit with referral
         */
        adminReferralPost(params: {  "userGuid": string; "data": AdminReferralModel; }, options?: any) {
            return AdminReferralApiFp.adminReferralPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * AnalyticsApi - fetch parameter creator
 */
export const AnalyticsApiFetchParamCreator = {
    /**
     * 
     * @param until 
     * @param weekly 
     */
    analyticsGetCohort(params: {  "until": string; "weekly": boolean; }, options?: any): FetchArgs {
        // verify required parameter "until" is set
        if (params["until"] == null) {
            throw new Error("Missing required parameter until when calling analyticsGetCohort");
        }
        // verify required parameter "weekly" is set
        if (params["weekly"] == null) {
            throw new Error("Missing required parameter weekly when calling analyticsGetCohort");
        }
        const baseUrl = `/api/analytics/cohort/prior`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "until": params["until"],
            "weekly": params["weekly"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AnalyticsApi - functional programming interface
 */
export const AnalyticsApiFp = {
    /**
     * 
     * @param until 
     * @param weekly 
     */
    analyticsGetCohort(params: { "until": string; "weekly": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhCohort> {
        const fetchArgs = AnalyticsApiFetchParamCreator.analyticsGetCohort(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AnalyticsApi - object-oriented interface
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @param until 
     * @param weekly 
     */
    analyticsGetCohort(params: {  "until": string; "weekly": boolean; }, options?: any) {
        return AnalyticsApiFp.analyticsGetCohort(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AnalyticsApi - factory interface
 */
export const AnalyticsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param until 
         * @param weekly 
         */
        analyticsGetCohort(params: {  "until": string; "weekly": boolean; }, options?: any) {
            return AnalyticsApiFp.analyticsGetCohort(params, options)(fetch, basePath);
        },
    };
};


/**
 * CampaignApi - fetch parameter creator
 */
export const CampaignApiFetchParamCreator = {
    /**
     * 
     * @param id 
     * @param userId 
     */
    campaignGet(params: {  "id": number; "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignGet");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling campaignGet");
        }
        const baseUrl = `/api/campaign/{id}/{userId}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param id 
     * @param model 
     */
    campaignPostEntry(params: {  "id": number; "model": CampaignEntryModel; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignPostEntry");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling campaignPostEntry");
        }
        const baseUrl = `/api/campaign/{id}/entry`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignApi - functional programming interface
 */
export const CampaignApiFp = {
    /**
     * 
     * @param id 
     * @param userId 
     */
    campaignGet(params: { "id": number; "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CampaignApiModel> {
        const fetchArgs = CampaignApiFetchParamCreator.campaignGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param id 
     * @param model 
     */
    campaignPostEntry(params: { "id": number; "model": CampaignEntryModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignApiFetchParamCreator.campaignPostEntry(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignApi - object-oriented interface
 */
export class CampaignApi extends BaseAPI {
    /**
     * 
     * @param id 
     * @param userId 
     */
    campaignGet(params: {  "id": number; "userId": number; }, options?: any) {
        return CampaignApiFp.campaignGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param id 
     * @param model 
     */
    campaignPostEntry(params: {  "id": number; "model": CampaignEntryModel; }, options?: any) {
        return CampaignApiFp.campaignPostEntry(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignApi - factory interface
 */
export const CampaignApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param id 
         * @param userId 
         */
        campaignGet(params: {  "id": number; "userId": number; }, options?: any) {
            return CampaignApiFp.campaignGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param id 
         * @param model 
         */
        campaignPostEntry(params: {  "id": number; "model": CampaignEntryModel; }, options?: any) {
            return CampaignApiFp.campaignPostEntry(params, options)(fetch, basePath);
        },
    };
};


/**
 * CheckoutApiApi - fetch parameter creator
 */
export const CheckoutApiApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param orderGuid 
     */
    checkoutApiCheckDoubleDownEligible(params: {  "sessionId": string; "orderGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiCheckDoubleDownEligible");
        }
        // verify required parameter "orderGuid" is set
        if (params["orderGuid"] == null) {
            throw new Error("Missing required parameter orderGuid when calling checkoutApiCheckDoubleDownEligible");
        }
        const baseUrl = `/api/session/{sessionId}/user-orders/{orderGuid}/spin-again`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"orderGuid"}}`, `${ params["orderGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Process a checkout operation to buy a gift card.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostBuyGiftCard(params: {  "sessionId": string; "offerCheckoutInfo": CreditCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPostBuyGiftCard");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPostBuyGiftCard");
        }
        const baseUrl = `/api/v3/session/{sessionId}/checkout-gc`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param orderGuid 
     */
    checkoutApiPostDoubleDown(params: {  "sessionId": string; "orderGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPostDoubleDown");
        }
        // verify required parameter "orderGuid" is set
        if (params["orderGuid"] == null) {
            throw new Error("Missing required parameter orderGuid when calling checkoutApiPostDoubleDown");
        }
        const baseUrl = `/api/session/{sessionId}/user-orders/{orderGuid}/spin-again`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"orderGuid"}}`, `${ params["orderGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPostFromSessionV3");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPostFromSessionV3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/checkout`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPostShipmentFromSessionV3");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPostShipmentFromSessionV3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/ship`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Simulate a checkout operation to buy a gift card.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutBuyGiftCard(params: {  "sessionId": string; "offerCheckoutInfo": CreditCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPutBuyGiftCard");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPutBuyGiftCard");
        }
        const baseUrl = `/api/v3/session/{sessionId}/checkout-gc`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPutFromSessionV3");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPutFromSessionV3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/checkout`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPutShipmentFromSessionV3");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPutShipmentFromSessionV3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/ship`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Process a checkout operation as new user.
     * @param sessionId 
     * @param model 
     */
    checkoutApiSignupAndCheckout(params: {  "sessionId": string; "model": NewUserCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiSignupAndCheckout");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling checkoutApiSignupAndCheckout");
        }
        const baseUrl = `/api/v3/session/{sessionId}/newUserCheckout`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CheckoutApiApi - functional programming interface
 */
export const CheckoutApiApiFp = {
    /**
     * 
     * @param sessionId 
     * @param orderGuid 
     */
    checkoutApiCheckDoubleDownEligible(params: { "sessionId": string; "orderGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiCheckDoubleDownEligible(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Process a checkout operation to buy a gift card.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostBuyGiftCard(params: { "sessionId": string; "offerCheckoutInfo": CreditCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultCreditOrderResult> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPostBuyGiftCard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param orderGuid 
     */
    checkoutApiPostDoubleDown(params: { "sessionId": string; "orderGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPostDoubleDown(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostFromSessionV3(params: { "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPostFromSessionV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSessionV3(params: { "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultCloudCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPostShipmentFromSessionV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Simulate a checkout operation to buy a gift card.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutBuyGiftCard(params: { "sessionId": string; "offerCheckoutInfo": CreditCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultCreditOrderResult> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPutBuyGiftCard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSessionV3(params: { "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPutFromSessionV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSessionV3(params: { "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultCloudCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPutShipmentFromSessionV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Process a checkout operation as new user.
     * @param sessionId 
     * @param model 
     */
    checkoutApiSignupAndCheckout(params: { "sessionId": string; "model": NewUserCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiSignupAndCheckout(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CheckoutApiApi - object-oriented interface
 */
export class CheckoutApiApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param orderGuid 
     */
    checkoutApiCheckDoubleDownEligible(params: {  "sessionId": string; "orderGuid": string; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiCheckDoubleDownEligible(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Process a checkout operation to buy a gift card.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostBuyGiftCard(params: {  "sessionId": string; "offerCheckoutInfo": CreditCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPostBuyGiftCard(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param orderGuid 
     */
    checkoutApiPostDoubleDown(params: {  "sessionId": string; "orderGuid": string; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPostDoubleDown(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPostFromSessionV3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPostShipmentFromSessionV3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Simulate a checkout operation to buy a gift card.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutBuyGiftCard(params: {  "sessionId": string; "offerCheckoutInfo": CreditCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPutBuyGiftCard(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPutFromSessionV3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPutShipmentFromSessionV3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Process a checkout operation as new user.
     * @param sessionId 
     * @param model 
     */
    checkoutApiSignupAndCheckout(params: {  "sessionId": string; "model": NewUserCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiSignupAndCheckout(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CheckoutApiApi - factory interface
 */
export const CheckoutApiApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param orderGuid 
         */
        checkoutApiCheckDoubleDownEligible(params: {  "sessionId": string; "orderGuid": string; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiCheckDoubleDownEligible(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Process a checkout operation to buy a gift card.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPostBuyGiftCard(params: {  "sessionId": string; "offerCheckoutInfo": CreditCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPostBuyGiftCard(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param orderGuid 
         */
        checkoutApiPostDoubleDown(params: {  "sessionId": string; "orderGuid": string; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPostDoubleDown(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Process a checkout operation.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPostFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPostFromSessionV3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Process a checkout operation.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPostShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPostShipmentFromSessionV3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulate a checkout operation to buy a gift card.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPutBuyGiftCard(params: {  "sessionId": string; "offerCheckoutInfo": CreditCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPutBuyGiftCard(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulate a checkout operation.
         * @param sessionId 
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPutFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPutFromSessionV3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulate a checkout operation.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPutShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPutShipmentFromSessionV3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Process a checkout operation as new user.
         * @param sessionId 
         * @param model 
         */
        checkoutApiSignupAndCheckout(params: {  "sessionId": string; "model": NewUserCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiSignupAndCheckout(params, options)(fetch, basePath);
        },
    };
};


/**
 * CloudCellarApi - fetch parameter creator
 */
export const CloudCellarApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param sku 
     * @param userEmail 
     */
    cloudCellarCloudCellarAdd(params: {  "sessionId": string; "sku": string; "userEmail": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling cloudCellarCloudCellarAdd");
        }
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling cloudCellarCloudCellarAdd");
        }
        // verify required parameter "userEmail" is set
        if (params["userEmail"] == null) {
            throw new Error("Missing required parameter userEmail when calling cloudCellarCloudCellarAdd");
        }
        const baseUrl = `/api/v3/admin/cloudcellar/bulk`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "sku": params["sku"],
            "userEmail": params["userEmail"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param search 
     */
    cloudCellarGetApiCloudcellarSearch(params: {  "search": string; }, options?: any): FetchArgs {
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling cloudCellarGetApiCloudcellarSearch");
        }
        const baseUrl = `/api/v2/admin/cloudcellar`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userName 
     * @param search 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param shipStatus 
     */
    cloudCellarGetV2(params: {  "userName": string; "search"?: string; "appellation"?: string; "varietal"?: string; "region"?: string; "shipStatus"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userName" is set
        if (params["userName"] == null) {
            throw new Error("Missing required parameter userName when calling cloudCellarGetV2");
        }
        const baseUrl = `/api/v2/cloudcellar/{userName}`
            .replace(`{${"userName"}}`, `${ params["userName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "appellation": params["appellation"],
            "varietal": params["varietal"],
            "region": params["region"],
            "shipStatus": params["shipStatus"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param prize 
     */
    cloudCellarHandleClaimPrize(params: {  "sessionId": string; "prize": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling cloudCellarHandleClaimPrize");
        }
        // verify required parameter "prize" is set
        if (params["prize"] == null) {
            throw new Error("Missing required parameter prize when calling cloudCellarHandleClaimPrize");
        }
        const baseUrl = `/api/session/{sessionId}/wordgame/{prize}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"prize"}}`, `${ params["prize"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    cloudCellarHandleGetLetters(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling cloudCellarHandleGetLetters");
        }
        const baseUrl = `/api/session/{sessionId}/wordgame`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CloudCellarApi - functional programming interface
 */
export const CloudCellarApiFp = {
    /**
     * 
     * @param sessionId 
     * @param sku 
     * @param userEmail 
     */
    cloudCellarCloudCellarAdd(params: { "sessionId": string; "sku": string; "userEmail": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultManifestList> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarCloudCellarAdd(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param search 
     */
    cloudCellarGetApiCloudcellarSearch(params: { "search": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPgCloudCellarRecord> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarGetApiCloudcellarSearch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userName 
     * @param search 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param shipStatus 
     */
    cloudCellarGetV2(params: { "userName": string; "search"?: string; "appellation"?: string; "varietal"?: string; "region"?: string; "shipStatus"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CloudCellarV2> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarGetV2(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param prize 
     */
    cloudCellarHandleClaimPrize(params: { "sessionId": string; "prize": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WordGame> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarHandleClaimPrize(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    cloudCellarHandleGetLetters(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WordGame> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarHandleGetLetters(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CloudCellarApi - object-oriented interface
 */
export class CloudCellarApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param sku 
     * @param userEmail 
     */
    cloudCellarCloudCellarAdd(params: {  "sessionId": string; "sku": string; "userEmail": string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarCloudCellarAdd(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param search 
     */
    cloudCellarGetApiCloudcellarSearch(params: {  "search": string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarGetApiCloudcellarSearch(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userName 
     * @param search 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param shipStatus 
     */
    cloudCellarGetV2(params: {  "userName": string; "search"?: string; "appellation"?: string; "varietal"?: string; "region"?: string; "shipStatus"?: string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarGetV2(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param prize 
     */
    cloudCellarHandleClaimPrize(params: {  "sessionId": string; "prize": string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarHandleClaimPrize(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    cloudCellarHandleGetLetters(params: {  "sessionId": string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarHandleGetLetters(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CloudCellarApi - factory interface
 */
export const CloudCellarApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param sku 
         * @param userEmail 
         */
        cloudCellarCloudCellarAdd(params: {  "sessionId": string; "sku": string; "userEmail": string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarCloudCellarAdd(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param search 
         */
        cloudCellarGetApiCloudcellarSearch(params: {  "search": string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarGetApiCloudcellarSearch(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userName 
         * @param search 
         * @param appellation 
         * @param varietal 
         * @param region 
         * @param shipStatus 
         */
        cloudCellarGetV2(params: {  "userName": string; "search"?: string; "appellation"?: string; "varietal"?: string; "region"?: string; "shipStatus"?: string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarGetV2(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param prize 
         */
        cloudCellarHandleClaimPrize(params: {  "sessionId": string; "prize": string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarHandleClaimPrize(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        cloudCellarHandleGetLetters(params: {  "sessionId": string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarHandleGetLetters(params, options)(fetch, basePath);
        },
    };
};


/**
 * CplSkuStockApi - fetch parameter creator
 */
export const CplSkuStockApiFetchParamCreator = {
    /**
     * 
     * @param overdue 
     */
    cplSkuStockGetArrivals(params: {  "overdue": boolean; }, options?: any): FetchArgs {
        // verify required parameter "overdue" is set
        if (params["overdue"] == null) {
            throw new Error("Missing required parameter overdue when calling cplSkuStockGetArrivals");
        }
        const baseUrl = `/api/admin/report/arrivals`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "overdue": params["overdue"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    cplSkuStockGetCplStock(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/cplstock`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param beyondDays 
     * @param qtyLessThan 
     */
    cplSkuStockHandleAdminReportDeficit(params: {  "sessionId": string; "beyondDays"?: number; "qtyLessThan"?: number; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling cplSkuStockHandleAdminReportDeficit");
        }
        const baseUrl = `/api/admin/report/deficit`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "beyondDays": params["beyondDays"],
            "qtyLessThan": params["qtyLessThan"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    cplSkuStockUpdateWarehouseStock(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/cplstock/update`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CplSkuStockApi - functional programming interface
 */
export const CplSkuStockApiFp = {
    /**
     * 
     * @param overdue 
     */
    cplSkuStockGetArrivals(params: { "overdue": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkuEntity>> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockGetArrivals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    cplSkuStockGetCplStock(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockGetCplStock(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param beyondDays 
     * @param qtyLessThan 
     */
    cplSkuStockHandleAdminReportDeficit(params: { "sessionId": string; "beyondDays"?: number; "qtyLessThan"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListDeficitItem> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockHandleAdminReportDeficit(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    cplSkuStockUpdateWarehouseStock(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultUpdateStockResult> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockUpdateWarehouseStock(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CplSkuStockApi - object-oriented interface
 */
export class CplSkuStockApi extends BaseAPI {
    /**
     * 
     * @param overdue 
     */
    cplSkuStockGetArrivals(params: {  "overdue": boolean; }, options?: any) {
        return CplSkuStockApiFp.cplSkuStockGetArrivals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    cplSkuStockGetCplStock(options?: any) {
        return CplSkuStockApiFp.cplSkuStockGetCplStock(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param beyondDays 
     * @param qtyLessThan 
     */
    cplSkuStockHandleAdminReportDeficit(params: {  "sessionId": string; "beyondDays"?: number; "qtyLessThan"?: number; }, options?: any) {
        return CplSkuStockApiFp.cplSkuStockHandleAdminReportDeficit(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    cplSkuStockUpdateWarehouseStock(options?: any) {
        return CplSkuStockApiFp.cplSkuStockUpdateWarehouseStock(options)(this.fetch, this.basePath);
    }
};

/**
 * CplSkuStockApi - factory interface
 */
export const CplSkuStockApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param overdue 
         */
        cplSkuStockGetArrivals(params: {  "overdue": boolean; }, options?: any) {
            return CplSkuStockApiFp.cplSkuStockGetArrivals(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        cplSkuStockGetCplStock(options?: any) {
            return CplSkuStockApiFp.cplSkuStockGetCplStock(options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param beyondDays 
         * @param qtyLessThan 
         */
        cplSkuStockHandleAdminReportDeficit(params: {  "sessionId": string; "beyondDays"?: number; "qtyLessThan"?: number; }, options?: any) {
            return CplSkuStockApiFp.cplSkuStockHandleAdminReportDeficit(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        cplSkuStockUpdateWarehouseStock(options?: any) {
            return CplSkuStockApiFp.cplSkuStockUpdateWarehouseStock(options)(fetch, basePath);
        },
    };
};


/**
 * EmailMarketingApi - fetch parameter creator
 */
export const EmailMarketingApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     */
    emailMarketingHandleGet(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling emailMarketingHandleGet");
        }
        const baseUrl = `/api/admin/v2/email/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    emailMarketingHandleGetAbandoned(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling emailMarketingHandleGetAbandoned");
        }
        const baseUrl = `/api/admin/v2/email/list/abandonedCheckout`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param send 
     */
    emailMarketingHandleGetExpiring(params: {  "sessionId": string; "skip"?: number; "take"?: number; "send"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling emailMarketingHandleGetExpiring");
        }
        const baseUrl = `/api/admin/v2/email/list/expiringCredits`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "skip": params["skip"],
            "take": params["take"],
            "send": params["send"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param message 
     */
    emailMarketingHandleSendPush(params: {  "sessionId": string; "message": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling emailMarketingHandleSendPush");
        }
        // verify required parameter "message" is set
        if (params["message"] == null) {
            throw new Error("Missing required parameter message when calling emailMarketingHandleSendPush");
        }
        const baseUrl = `/api/admin/v2/email/push`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "message": params["message"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param email 
     * @param unsubCampaignId 
     * @param unsubCampaignTitle 
     * @param unsubReason 
     */
    emailMarketingHandleUnsub(params: {  "email": string; "unsubCampaignId": string; "unsubCampaignTitle": string; "unsubReason": string; }, options?: any): FetchArgs {
        // verify required parameter "email" is set
        if (params["email"] == null) {
            throw new Error("Missing required parameter email when calling emailMarketingHandleUnsub");
        }
        // verify required parameter "unsubCampaignId" is set
        if (params["unsubCampaignId"] == null) {
            throw new Error("Missing required parameter unsubCampaignId when calling emailMarketingHandleUnsub");
        }
        // verify required parameter "unsubCampaignTitle" is set
        if (params["unsubCampaignTitle"] == null) {
            throw new Error("Missing required parameter unsubCampaignTitle when calling emailMarketingHandleUnsub");
        }
        // verify required parameter "unsubReason" is set
        if (params["unsubReason"] == null) {
            throw new Error("Missing required parameter unsubReason when calling emailMarketingHandleUnsub");
        }
        const baseUrl = `/api/admin/v2/email/list/unsub`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "email": params["email"],
            "unsubCampaignId": params["unsubCampaignId"],
            "unsubCampaignTitle": params["unsubCampaignTitle"],
            "unsubReason": params["unsubReason"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param page 
     */
    emailMarketingImportDotmailerIds(params: {  "page": number; }, options?: any): FetchArgs {
        // verify required parameter "page" is set
        if (params["page"] == null) {
            throw new Error("Missing required parameter page when calling emailMarketingImportDotmailerIds");
        }
        const baseUrl = `/api/admin/v2/dotmailer/pull/{page}`
            .replace(`{${"page"}}`, `${ params["page"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param toEmail 
     * @param toName 
     */
    emailMarketingSendTest(params: {  "sessionId": string; "toEmail": string; "toName": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling emailMarketingSendTest");
        }
        // verify required parameter "toEmail" is set
        if (params["toEmail"] == null) {
            throw new Error("Missing required parameter toEmail when calling emailMarketingSendTest");
        }
        // verify required parameter "toName" is set
        if (params["toName"] == null) {
            throw new Error("Missing required parameter toName when calling emailMarketingSendTest");
        }
        const baseUrl = `/api/admin/v2/email/test`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "toEmail": params["toEmail"],
            "toName": params["toName"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * EmailMarketingApi - functional programming interface
 */
export const EmailMarketingApiFp = {
    /**
     * 
     * @param sessionId 
     */
    emailMarketingHandleGet(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    emailMarketingHandleGetAbandoned(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleGetAbandoned(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param send 
     */
    emailMarketingHandleGetExpiring(params: { "sessionId": string; "skip"?: number; "take"?: number; "send"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleGetExpiring(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param message 
     */
    emailMarketingHandleSendPush(params: { "sessionId": string; "message": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleSendPush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param email 
     * @param unsubCampaignId 
     * @param unsubCampaignTitle 
     * @param unsubReason 
     */
    emailMarketingHandleUnsub(params: { "email": string; "unsubCampaignId": string; "unsubCampaignTitle": string; "unsubReason": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleUnsub(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param page 
     */
    emailMarketingImportDotmailerIds(params: { "page": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingImportDotmailerIds(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param toEmail 
     * @param toName 
     */
    emailMarketingSendTest(params: { "sessionId": string; "toEmail": string; "toName": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingSendTest(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * EmailMarketingApi - object-oriented interface
 */
export class EmailMarketingApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     */
    emailMarketingHandleGet(params: {  "sessionId": string; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    emailMarketingHandleGetAbandoned(params: {  "sessionId": string; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleGetAbandoned(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param send 
     */
    emailMarketingHandleGetExpiring(params: {  "sessionId": string; "skip"?: number; "take"?: number; "send"?: boolean; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleGetExpiring(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param message 
     */
    emailMarketingHandleSendPush(params: {  "sessionId": string; "message": string; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleSendPush(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param email 
     * @param unsubCampaignId 
     * @param unsubCampaignTitle 
     * @param unsubReason 
     */
    emailMarketingHandleUnsub(params: {  "email": string; "unsubCampaignId": string; "unsubCampaignTitle": string; "unsubReason": string; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleUnsub(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param page 
     */
    emailMarketingImportDotmailerIds(params: {  "page": number; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingImportDotmailerIds(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param toEmail 
     * @param toName 
     */
    emailMarketingSendTest(params: {  "sessionId": string; "toEmail": string; "toName": string; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingSendTest(params, options)(this.fetch, this.basePath);
    }
};

/**
 * EmailMarketingApi - factory interface
 */
export const EmailMarketingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         */
        emailMarketingHandleGet(params: {  "sessionId": string; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        emailMarketingHandleGetAbandoned(params: {  "sessionId": string; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleGetAbandoned(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param skip 
         * @param take 
         * @param send 
         */
        emailMarketingHandleGetExpiring(params: {  "sessionId": string; "skip"?: number; "take"?: number; "send"?: boolean; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleGetExpiring(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param message 
         */
        emailMarketingHandleSendPush(params: {  "sessionId": string; "message": string; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleSendPush(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param email 
         * @param unsubCampaignId 
         * @param unsubCampaignTitle 
         * @param unsubReason 
         */
        emailMarketingHandleUnsub(params: {  "email": string; "unsubCampaignId": string; "unsubCampaignTitle": string; "unsubReason": string; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleUnsub(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param page 
         */
        emailMarketingImportDotmailerIds(params: {  "page": number; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingImportDotmailerIds(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param toEmail 
         * @param toName 
         */
        emailMarketingSendTest(params: {  "sessionId": string; "toEmail": string; "toName": string; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingSendTest(params, options)(fetch, basePath);
        },
    };
};


/**
 * InviteApi - fetch parameter creator
 */
export const InviteApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param source 
     */
    inviteGetContactsByOauth(params: {  "sessionId": string; "source": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling inviteGetContactsByOauth");
        }
        // verify required parameter "source" is set
        if (params["source"] == null) {
            throw new Error("Missing required parameter source when calling inviteGetContactsByOauth");
        }
        const baseUrl = `/api/invite/byOauth/contacts/{sessionId}/{source}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"source"}}`, `${ params["source"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    inviteGetInvitations(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling inviteGetInvitations");
        }
        const baseUrl = `/api/session/{sessionId}/user-referral`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param input 
     */
    inviteInviteByEmail(params: {  "sessionId": string; "input": InviteByEmailModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling inviteInviteByEmail");
        }
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling inviteInviteByEmail");
        }
        const baseUrl = `/api/session/{sessionId}/user-referral`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param contacts 
     */
    inviteInviteContactsByEmail(params: {  "sessionId": string; "contacts": Array<InviteByEmailModel>; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling inviteInviteContactsByEmail");
        }
        // verify required parameter "contacts" is set
        if (params["contacts"] == null) {
            throw new Error("Missing required parameter contacts when calling inviteInviteContactsByEmail");
        }
        const baseUrl = `/api/invite/byOauth/invitations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["contacts"]) {
            fetchOptions.body = JSON.stringify(params["contacts"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param input 
     */
    inviteInvitebyOauth(params: {  "sessionId": string; "input": Oauthorization; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling inviteInvitebyOauth");
        }
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling inviteInvitebyOauth");
        }
        const baseUrl = `/api/invite/byOauth/register`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InviteApi - functional programming interface
 */
export const InviteApiFp = {
    /**
     * 
     * @param sessionId 
     * @param source 
     */
    inviteGetContactsByOauth(params: { "sessionId": string; "source": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InviteByEmailModel>> {
        const fetchArgs = InviteApiFetchParamCreator.inviteGetContactsByOauth(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    inviteGetInvitations(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListUserReferralModel> {
        const fetchArgs = InviteApiFetchParamCreator.inviteGetInvitations(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param input 
     */
    inviteInviteByEmail(params: { "sessionId": string; "input": InviteByEmailModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultInviteByEmailModel> {
        const fetchArgs = InviteApiFetchParamCreator.inviteInviteByEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param contacts 
     */
    inviteInviteContactsByEmail(params: { "sessionId": string; "contacts": Array<InviteByEmailModel>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListInviteByEmailModel> {
        const fetchArgs = InviteApiFetchParamCreator.inviteInviteContactsByEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param input 
     */
    inviteInvitebyOauth(params: { "sessionId": string; "input": Oauthorization;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOauthorization> {
        const fetchArgs = InviteApiFetchParamCreator.inviteInvitebyOauth(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InviteApi - object-oriented interface
 */
export class InviteApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param source 
     */
    inviteGetContactsByOauth(params: {  "sessionId": string; "source": string; }, options?: any) {
        return InviteApiFp.inviteGetContactsByOauth(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    inviteGetInvitations(params: {  "sessionId": string; }, options?: any) {
        return InviteApiFp.inviteGetInvitations(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param input 
     */
    inviteInviteByEmail(params: {  "sessionId": string; "input": InviteByEmailModel; }, options?: any) {
        return InviteApiFp.inviteInviteByEmail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param contacts 
     */
    inviteInviteContactsByEmail(params: {  "sessionId": string; "contacts": Array<InviteByEmailModel>; }, options?: any) {
        return InviteApiFp.inviteInviteContactsByEmail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param input 
     */
    inviteInvitebyOauth(params: {  "sessionId": string; "input": Oauthorization; }, options?: any) {
        return InviteApiFp.inviteInvitebyOauth(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InviteApi - factory interface
 */
export const InviteApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param source 
         */
        inviteGetContactsByOauth(params: {  "sessionId": string; "source": string; }, options?: any) {
            return InviteApiFp.inviteGetContactsByOauth(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        inviteGetInvitations(params: {  "sessionId": string; }, options?: any) {
            return InviteApiFp.inviteGetInvitations(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param input 
         */
        inviteInviteByEmail(params: {  "sessionId": string; "input": InviteByEmailModel; }, options?: any) {
            return InviteApiFp.inviteInviteByEmail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param contacts 
         */
        inviteInviteContactsByEmail(params: {  "sessionId": string; "contacts": Array<InviteByEmailModel>; }, options?: any) {
            return InviteApiFp.inviteInviteContactsByEmail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param input 
         */
        inviteInvitebyOauth(params: {  "sessionId": string; "input": Oauthorization; }, options?: any) {
            return InviteApiFp.inviteInvitebyOauth(params, options)(fetch, basePath);
        },
    };
};


/**
 * InvoiceApi - fetch parameter creator
 */
export const InvoiceApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param record 
     */
    invoiceCreateOrUpdateInvoiceIgnoringItems(params: {  "sessionId": string; "record": NhInvoice; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling invoiceCreateOrUpdateInvoiceIgnoringItems");
        }
        // verify required parameter "record" is set
        if (params["record"] == null) {
            throw new Error("Missing required parameter record when calling invoiceCreateOrUpdateInvoiceIgnoringItems");
        }
        const baseUrl = `/api/admin/invoice/collection`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["record"]) {
            fetchOptions.body = JSON.stringify(params["record"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param invItemGuid 
     */
    invoiceDeleteInvoiceItem(params: {  "sessionId": string; "invGuid": string; "invItemGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling invoiceDeleteInvoiceItem");
        }
        // verify required parameter "invGuid" is set
        if (params["invGuid"] == null) {
            throw new Error("Missing required parameter invGuid when calling invoiceDeleteInvoiceItem");
        }
        // verify required parameter "invItemGuid" is set
        if (params["invItemGuid"] == null) {
            throw new Error("Missing required parameter invItemGuid when calling invoiceDeleteInvoiceItem");
        }
        const baseUrl = `/api/admin/invoice/detail/{invGuid}`
            .replace(`{${"invGuid"}}`, `${ params["invGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "invItemGuid": params["invItemGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param sku 
     */
    invoiceGetEligibleTransferToLink(params: {  "sessionId": string; "invGuid": string; "sku": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling invoiceGetEligibleTransferToLink");
        }
        // verify required parameter "invGuid" is set
        if (params["invGuid"] == null) {
            throw new Error("Missing required parameter invGuid when calling invoiceGetEligibleTransferToLink");
        }
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling invoiceGetEligibleTransferToLink");
        }
        const baseUrl = `/api/admin/invoice/detail/{invGuid}`
            .replace(`{${"invGuid"}}`, `${ params["invGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "sku": params["sku"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param search 
     * @param skip 
     * @param take 
     * @param sort 
     * @param asc 
     */
    invoiceGetInvoiceItemsWithoutTransfer(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; "sort"?: string; "asc"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling invoiceGetInvoiceItemsWithoutTransfer");
        }
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling invoiceGetInvoiceItemsWithoutTransfer");
        }
        const baseUrl = `/api/admin/invoice/unmatched`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
            "sort": params["sort"],
            "asc": params["asc"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param search 
     * @param skip 
     * @param take 
     */
    invoiceGetTransferItemsWithoutInvoice(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling invoiceGetTransferItemsWithoutInvoice");
        }
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling invoiceGetTransferItemsWithoutInvoice");
        }
        const baseUrl = `/api/admin/transfer/unmatched`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param invItemGuid 
     * @param xiGuid 
     */
    invoiceLinkInvoiceItemToTransfer(params: {  "sessionId": string; "invGuid": string; "invItemGuid": string; "xiGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling invoiceLinkInvoiceItemToTransfer");
        }
        // verify required parameter "invGuid" is set
        if (params["invGuid"] == null) {
            throw new Error("Missing required parameter invGuid when calling invoiceLinkInvoiceItemToTransfer");
        }
        // verify required parameter "invItemGuid" is set
        if (params["invItemGuid"] == null) {
            throw new Error("Missing required parameter invItemGuid when calling invoiceLinkInvoiceItemToTransfer");
        }
        // verify required parameter "xiGuid" is set
        if (params["xiGuid"] == null) {
            throw new Error("Missing required parameter xiGuid when calling invoiceLinkInvoiceItemToTransfer");
        }
        const baseUrl = `/api/admin/invoice/detail/{invGuid}`
            .replace(`{${"invGuid"}}`, `${ params["invGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "invItemGuid": params["invItemGuid"],
            "xiGuid": params["xiGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    invoiceListInvoice(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling invoiceListInvoice");
        }
        const baseUrl = `/api/admin/invoice/collection`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param model 
     */
    invoiceSaveOrUpdateInvoiceItem(params: {  "sessionId": string; "invGuid": string; "model": NhInvoiceItem; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling invoiceSaveOrUpdateInvoiceItem");
        }
        // verify required parameter "invGuid" is set
        if (params["invGuid"] == null) {
            throw new Error("Missing required parameter invGuid when calling invoiceSaveOrUpdateInvoiceItem");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling invoiceSaveOrUpdateInvoiceItem");
        }
        const baseUrl = `/api/admin/invoice/detail/{invGuid}`
            .replace(`{${"invGuid"}}`, `${ params["invGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoiceApi - functional programming interface
 */
export const InvoiceApiFp = {
    /**
     * 
     * @param sessionId 
     * @param record 
     */
    invoiceCreateOrUpdateInvoiceIgnoringItems(params: { "sessionId": string; "record": NhInvoice;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhInvoice> {
        const fetchArgs = InvoiceApiFetchParamCreator.invoiceCreateOrUpdateInvoiceIgnoringItems(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param invItemGuid 
     */
    invoiceDeleteInvoiceItem(params: { "sessionId": string; "invGuid": string; "invItemGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhInvoiceItem> {
        const fetchArgs = InvoiceApiFetchParamCreator.invoiceDeleteInvoiceItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param sku 
     */
    invoiceGetEligibleTransferToLink(params: { "sessionId": string; "invGuid": string; "sku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListLinkTransferItem> {
        const fetchArgs = InvoiceApiFetchParamCreator.invoiceGetEligibleTransferToLink(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param search 
     * @param skip 
     * @param take 
     * @param sort 
     * @param asc 
     */
    invoiceGetInvoiceItemsWithoutTransfer(params: { "sessionId": string; "search": string; "skip"?: number; "take"?: number; "sort"?: string; "asc"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListLinkInvoiceItem> {
        const fetchArgs = InvoiceApiFetchParamCreator.invoiceGetInvoiceItemsWithoutTransfer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param search 
     * @param skip 
     * @param take 
     */
    invoiceGetTransferItemsWithoutInvoice(params: { "sessionId": string; "search": string; "skip"?: number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListLinkTransferItem> {
        const fetchArgs = InvoiceApiFetchParamCreator.invoiceGetTransferItemsWithoutInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param invItemGuid 
     * @param xiGuid 
     */
    invoiceLinkInvoiceItemToTransfer(params: { "sessionId": string; "invGuid": string; "invItemGuid": string; "xiGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhInvoiceItem> {
        const fetchArgs = InvoiceApiFetchParamCreator.invoiceLinkInvoiceItemToTransfer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    invoiceListInvoice(params: { "sessionId": string; "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhInvoice> {
        const fetchArgs = InvoiceApiFetchParamCreator.invoiceListInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param model 
     */
    invoiceSaveOrUpdateInvoiceItem(params: { "sessionId": string; "invGuid": string; "model": NhInvoiceItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhInvoiceItem> {
        const fetchArgs = InvoiceApiFetchParamCreator.invoiceSaveOrUpdateInvoiceItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoiceApi - object-oriented interface
 */
export class InvoiceApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param record 
     */
    invoiceCreateOrUpdateInvoiceIgnoringItems(params: {  "sessionId": string; "record": NhInvoice; }, options?: any) {
        return InvoiceApiFp.invoiceCreateOrUpdateInvoiceIgnoringItems(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param invItemGuid 
     */
    invoiceDeleteInvoiceItem(params: {  "sessionId": string; "invGuid": string; "invItemGuid": string; }, options?: any) {
        return InvoiceApiFp.invoiceDeleteInvoiceItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param sku 
     */
    invoiceGetEligibleTransferToLink(params: {  "sessionId": string; "invGuid": string; "sku": string; }, options?: any) {
        return InvoiceApiFp.invoiceGetEligibleTransferToLink(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param search 
     * @param skip 
     * @param take 
     * @param sort 
     * @param asc 
     */
    invoiceGetInvoiceItemsWithoutTransfer(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; "sort"?: string; "asc"?: boolean; }, options?: any) {
        return InvoiceApiFp.invoiceGetInvoiceItemsWithoutTransfer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param search 
     * @param skip 
     * @param take 
     */
    invoiceGetTransferItemsWithoutInvoice(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; }, options?: any) {
        return InvoiceApiFp.invoiceGetTransferItemsWithoutInvoice(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param invItemGuid 
     * @param xiGuid 
     */
    invoiceLinkInvoiceItemToTransfer(params: {  "sessionId": string; "invGuid": string; "invItemGuid": string; "xiGuid": string; }, options?: any) {
        return InvoiceApiFp.invoiceLinkInvoiceItemToTransfer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    invoiceListInvoice(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return InvoiceApiFp.invoiceListInvoice(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param invGuid 
     * @param model 
     */
    invoiceSaveOrUpdateInvoiceItem(params: {  "sessionId": string; "invGuid": string; "model": NhInvoiceItem; }, options?: any) {
        return InvoiceApiFp.invoiceSaveOrUpdateInvoiceItem(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InvoiceApi - factory interface
 */
export const InvoiceApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param record 
         */
        invoiceCreateOrUpdateInvoiceIgnoringItems(params: {  "sessionId": string; "record": NhInvoice; }, options?: any) {
            return InvoiceApiFp.invoiceCreateOrUpdateInvoiceIgnoringItems(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param invGuid 
         * @param invItemGuid 
         */
        invoiceDeleteInvoiceItem(params: {  "sessionId": string; "invGuid": string; "invItemGuid": string; }, options?: any) {
            return InvoiceApiFp.invoiceDeleteInvoiceItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param invGuid 
         * @param sku 
         */
        invoiceGetEligibleTransferToLink(params: {  "sessionId": string; "invGuid": string; "sku": string; }, options?: any) {
            return InvoiceApiFp.invoiceGetEligibleTransferToLink(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param search 
         * @param skip 
         * @param take 
         * @param sort 
         * @param asc 
         */
        invoiceGetInvoiceItemsWithoutTransfer(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; "sort"?: string; "asc"?: boolean; }, options?: any) {
            return InvoiceApiFp.invoiceGetInvoiceItemsWithoutTransfer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param search 
         * @param skip 
         * @param take 
         */
        invoiceGetTransferItemsWithoutInvoice(params: {  "sessionId": string; "search": string; "skip"?: number; "take"?: number; }, options?: any) {
            return InvoiceApiFp.invoiceGetTransferItemsWithoutInvoice(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param invGuid 
         * @param invItemGuid 
         * @param xiGuid 
         */
        invoiceLinkInvoiceItemToTransfer(params: {  "sessionId": string; "invGuid": string; "invItemGuid": string; "xiGuid": string; }, options?: any) {
            return InvoiceApiFp.invoiceLinkInvoiceItemToTransfer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param skip 
         * @param take 
         * @param search 
         */
        invoiceListInvoice(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return InvoiceApiFp.invoiceListInvoice(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param invGuid 
         * @param model 
         */
        invoiceSaveOrUpdateInvoiceItem(params: {  "sessionId": string; "invGuid": string; "model": NhInvoiceItem; }, options?: any) {
            return InvoiceApiFp.invoiceSaveOrUpdateInvoiceItem(params, options)(fetch, basePath);
        },
    };
};


/**
 * ItemDetailApi - fetch parameter creator
 */
export const ItemDetailApiFetchParamCreator = {
    /**
     * 
     * @param content 
     */
    itemDetailDelete(params: {  "content": ItemDetailEntity; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling itemDetailDelete");
        }
        const baseUrl = `/api/v2/itemdetail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param itemSef 
     */
    itemDetailGetBySefOrSku(params: {  "itemSef": string; }, options?: any): FetchArgs {
        // verify required parameter "itemSef" is set
        if (params["itemSef"] == null) {
            throw new Error("Missing required parameter itemSef when calling itemDetailGetBySefOrSku");
        }
        const baseUrl = `/api/v2/itemdetail/{itemSef}`
            .replace(`{${"itemSef"}}`, `${ params["itemSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param details 
     */
    itemDetailHttpBulkUpdateItemDetail(params: {  "sessionId": string; "details": ItemDetailBulkUpdate; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling itemDetailHttpBulkUpdateItemDetail");
        }
        // verify required parameter "details" is set
        if (params["details"] == null) {
            throw new Error("Missing required parameter details when calling itemDetailHttpBulkUpdateItemDetail");
        }
        const baseUrl = `/api/v2/admin/itemdetail/bulkUpdate`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["details"]) {
            fetchOptions.body = JSON.stringify(params["details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param brand 
     * @param mlMin 
     * @param mlMax 
     * @param priceMin 
     * @param priceMax 
     */
    itemDetailListItemDetail(params: {  "search"?: string; "skip"?: number; "take"?: number; "appellation"?: string; "varietal"?: string; "region"?: string; "brand"?: string; "mlMin"?: number; "mlMax"?: number; "priceMin"?: number; "priceMax"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/itemdetail`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
            "appellation": params["appellation"],
            "varietal": params["varietal"],
            "region": params["region"],
            "brand": params["brand"],
            "mlMin": params["mlMin"],
            "mlMax": params["mlMax"],
            "priceMin": params["priceMin"],
            "priceMax": params["priceMax"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param onlyBuyable 
     */
    itemDetailListItemDetailWithSku(params: {  "search"?: string; "skip"?: number; "take"?: number; "appellation"?: string; "varietal"?: string; "region"?: string; "onlyBuyable"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/itemWithSku`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
            "appellation": params["appellation"],
            "varietal": params["varietal"],
            "region": params["region"],
            "onlyBuyable": params["onlyBuyable"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param input 
     */
    itemDetailMergeItemDetailHandler(params: {  "input": string; }, options?: any): FetchArgs {
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling itemDetailMergeItemDetailHandler");
        }
        const baseUrl = `/api/v2/itemdetail/merge`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "input": params["input"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param content 
     */
    itemDetailPost(params: {  "content": ItemDetailEntity; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling itemDetailPost");
        }
        const baseUrl = `/api/v2/itemdetail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param file 
     */
    itemDetailPostItemDetailUploadImage(params: {  "file": any; }, options?: any): FetchArgs {
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling itemDetailPostItemDetailUploadImage");
        }
        const baseUrl = `/api/v2/itemdetail/uploadImage`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param content 
     */
    itemDetailPostV3(params: {  "content": ItemDetailEntity; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling itemDetailPostV3");
        }
        const baseUrl = `/api/v3/itemdetail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param itemSef 
     * @param content 
     */
    itemDetailPut(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any): FetchArgs {
        // verify required parameter "itemSef" is set
        if (params["itemSef"] == null) {
            throw new Error("Missing required parameter itemSef when calling itemDetailPut");
        }
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling itemDetailPut");
        }
        const baseUrl = `/api/v2/itemdetail/{itemSef}`
            .replace(`{${"itemSef"}}`, `${ params["itemSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param itemSef 
     * @param content 
     */
    itemDetailPutV3(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any): FetchArgs {
        // verify required parameter "itemSef" is set
        if (params["itemSef"] == null) {
            throw new Error("Missing required parameter itemSef when calling itemDetailPutV3");
        }
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling itemDetailPutV3");
        }
        const baseUrl = `/api/v3/itemdetail/{itemSef}`
            .replace(`{${"itemSef"}}`, `${ params["itemSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ItemDetailApi - functional programming interface
 */
export const ItemDetailApiFp = {
    /**
     * 
     * @param content 
     */
    itemDetailDelete(params: { "content": ItemDetailEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param itemSef 
     */
    itemDetailGetBySefOrSku(params: { "itemSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailGetBySefOrSku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param details 
     */
    itemDetailHttpBulkUpdateItemDetail(params: { "sessionId": string; "details": ItemDetailBulkUpdate;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailHttpBulkUpdateItemDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param brand 
     * @param mlMin 
     * @param mlMax 
     * @param priceMin 
     * @param priceMax 
     */
    itemDetailListItemDetail(params: { "search"?: string; "skip"?: number; "take"?: number; "appellation"?: string; "varietal"?: string; "region"?: string; "brand"?: string; "mlMin"?: number; "mlMax"?: number; "priceMin"?: number; "priceMax"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultAttributedItemList> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailListItemDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param onlyBuyable 
     */
    itemDetailListItemDetailWithSku(params: { "search"?: string; "skip"?: number; "take"?: number; "appellation"?: string; "varietal"?: string; "region"?: string; "onlyBuyable"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultAttributedItemList> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailListItemDetailWithSku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param input 
     */
    itemDetailMergeItemDetailHandler(params: { "input": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailMergeItemDetailHandler(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param content 
     */
    itemDetailPost(params: { "content": ItemDetailEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param file 
     */
    itemDetailPostItemDetailUploadImage(params: { "file": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailPostItemDetailUploadImage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param content 
     */
    itemDetailPostV3(params: { "content": ItemDetailEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailPostV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param itemSef 
     * @param content 
     */
    itemDetailPut(params: { "itemSef": string; "content": ItemDetailEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param itemSef 
     * @param content 
     */
    itemDetailPutV3(params: { "itemSef": string; "content": ItemDetailEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailPutV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ItemDetailApi - object-oriented interface
 */
export class ItemDetailApi extends BaseAPI {
    /**
     * 
     * @param content 
     */
    itemDetailDelete(params: {  "content": ItemDetailEntity; }, options?: any) {
        return ItemDetailApiFp.itemDetailDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param itemSef 
     */
    itemDetailGetBySefOrSku(params: {  "itemSef": string; }, options?: any) {
        return ItemDetailApiFp.itemDetailGetBySefOrSku(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param details 
     */
    itemDetailHttpBulkUpdateItemDetail(params: {  "sessionId": string; "details": ItemDetailBulkUpdate; }, options?: any) {
        return ItemDetailApiFp.itemDetailHttpBulkUpdateItemDetail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param brand 
     * @param mlMin 
     * @param mlMax 
     * @param priceMin 
     * @param priceMax 
     */
    itemDetailListItemDetail(params: {  "search"?: string; "skip"?: number; "take"?: number; "appellation"?: string; "varietal"?: string; "region"?: string; "brand"?: string; "mlMin"?: number; "mlMax"?: number; "priceMin"?: number; "priceMax"?: number; }, options?: any) {
        return ItemDetailApiFp.itemDetailListItemDetail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param appellation 
     * @param varietal 
     * @param region 
     * @param onlyBuyable 
     */
    itemDetailListItemDetailWithSku(params: {  "search"?: string; "skip"?: number; "take"?: number; "appellation"?: string; "varietal"?: string; "region"?: string; "onlyBuyable"?: boolean; }, options?: any) {
        return ItemDetailApiFp.itemDetailListItemDetailWithSku(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param input 
     */
    itemDetailMergeItemDetailHandler(params: {  "input": string; }, options?: any) {
        return ItemDetailApiFp.itemDetailMergeItemDetailHandler(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param content 
     */
    itemDetailPost(params: {  "content": ItemDetailEntity; }, options?: any) {
        return ItemDetailApiFp.itemDetailPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param file 
     */
    itemDetailPostItemDetailUploadImage(params: {  "file": any; }, options?: any) {
        return ItemDetailApiFp.itemDetailPostItemDetailUploadImage(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param content 
     */
    itemDetailPostV3(params: {  "content": ItemDetailEntity; }, options?: any) {
        return ItemDetailApiFp.itemDetailPostV3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param itemSef 
     * @param content 
     */
    itemDetailPut(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any) {
        return ItemDetailApiFp.itemDetailPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param itemSef 
     * @param content 
     */
    itemDetailPutV3(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any) {
        return ItemDetailApiFp.itemDetailPutV3(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ItemDetailApi - factory interface
 */
export const ItemDetailApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param content 
         */
        itemDetailDelete(params: {  "content": ItemDetailEntity; }, options?: any) {
            return ItemDetailApiFp.itemDetailDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param itemSef 
         */
        itemDetailGetBySefOrSku(params: {  "itemSef": string; }, options?: any) {
            return ItemDetailApiFp.itemDetailGetBySefOrSku(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param details 
         */
        itemDetailHttpBulkUpdateItemDetail(params: {  "sessionId": string; "details": ItemDetailBulkUpdate; }, options?: any) {
            return ItemDetailApiFp.itemDetailHttpBulkUpdateItemDetail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param search 
         * @param skip 
         * @param take 
         * @param appellation 
         * @param varietal 
         * @param region 
         * @param brand 
         * @param mlMin 
         * @param mlMax 
         * @param priceMin 
         * @param priceMax 
         */
        itemDetailListItemDetail(params: {  "search"?: string; "skip"?: number; "take"?: number; "appellation"?: string; "varietal"?: string; "region"?: string; "brand"?: string; "mlMin"?: number; "mlMax"?: number; "priceMin"?: number; "priceMax"?: number; }, options?: any) {
            return ItemDetailApiFp.itemDetailListItemDetail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param search 
         * @param skip 
         * @param take 
         * @param appellation 
         * @param varietal 
         * @param region 
         * @param onlyBuyable 
         */
        itemDetailListItemDetailWithSku(params: {  "search"?: string; "skip"?: number; "take"?: number; "appellation"?: string; "varietal"?: string; "region"?: string; "onlyBuyable"?: boolean; }, options?: any) {
            return ItemDetailApiFp.itemDetailListItemDetailWithSku(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param input 
         */
        itemDetailMergeItemDetailHandler(params: {  "input": string; }, options?: any) {
            return ItemDetailApiFp.itemDetailMergeItemDetailHandler(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param content 
         */
        itemDetailPost(params: {  "content": ItemDetailEntity; }, options?: any) {
            return ItemDetailApiFp.itemDetailPost(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param file 
         */
        itemDetailPostItemDetailUploadImage(params: {  "file": any; }, options?: any) {
            return ItemDetailApiFp.itemDetailPostItemDetailUploadImage(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param content 
         */
        itemDetailPostV3(params: {  "content": ItemDetailEntity; }, options?: any) {
            return ItemDetailApiFp.itemDetailPostV3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param itemSef 
         * @param content 
         */
        itemDetailPut(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any) {
            return ItemDetailApiFp.itemDetailPut(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param itemSef 
         * @param content 
         */
        itemDetailPutV3(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any) {
            return ItemDetailApiFp.itemDetailPutV3(params, options)(fetch, basePath);
        },
    };
};


/**
 * KeyMetricsApi - fetch parameter creator
 */
export const KeyMetricsApiFetchParamCreator = {
    /**
     * 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGet(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/usersummary`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "utmCampaign": params["utmCampaign"],
            "utmSource": params["utmSource"],
            "utmMedium": params["utmMedium"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    keyMetricsGetAdminReportBuyToShip(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/buyToShip`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    keyMetricsGetAdminReportOfferStats(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/names`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param reportName 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGetAdminReportOfferStats_1(params: {  "reportName": string; "startDate"?: Date; "endDate"?: Date; }, options?: any): FetchArgs {
        // verify required parameter "reportName" is set
        if (params["reportName"] == null) {
            throw new Error("Missing required parameter reportName when calling keyMetricsGetAdminReportOfferStats_1");
        }
        const baseUrl = `/api/admin/report/names/{reportName}`
            .replace(`{${"reportName"}}`, `${ params["reportName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "startDate": params["startDate"],
            "endDate": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromo(params: {  "promoCode": string; }, options?: any): FetchArgs {
        // verify required parameter "promoCode" is set
        if (params["promoCode"] == null) {
            throw new Error("Missing required parameter promoCode when calling keyMetricsGetAdminReportPromo");
        }
        const baseUrl = `/api/admin/report/promo`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "promoCode": params["promoCode"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromoUsers(params: {  "promoCode": string; }, options?: any): FetchArgs {
        // verify required parameter "promoCode" is set
        if (params["promoCode"] == null) {
            throw new Error("Missing required parameter promoCode when calling keyMetricsGetAdminReportPromoUsers");
        }
        const baseUrl = `/api/admin/report/promo/users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "promoCode": params["promoCode"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    keyMetricsGetCohortAnalysis(options?: any): FetchArgs {
        const baseUrl = `/api/admin/cohorts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param startMonth 
     * @param startYear 
     * @param minLifeSpend 
     */
    keyMetricsGetCohortsByFirstOrder(params: {  "startMonth": number; "startYear": number; "minLifeSpend": number; }, options?: any): FetchArgs {
        // verify required parameter "startMonth" is set
        if (params["startMonth"] == null) {
            throw new Error("Missing required parameter startMonth when calling keyMetricsGetCohortsByFirstOrder");
        }
        // verify required parameter "startYear" is set
        if (params["startYear"] == null) {
            throw new Error("Missing required parameter startYear when calling keyMetricsGetCohortsByFirstOrder");
        }
        // verify required parameter "minLifeSpend" is set
        if (params["minLifeSpend"] == null) {
            throw new Error("Missing required parameter minLifeSpend when calling keyMetricsGetCohortsByFirstOrder");
        }
        const baseUrl = `/api/admin/cohorts/byFirstOrder`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "startMonth": params["startMonth"],
            "startYear": params["startYear"],
            "minLifeSpend": params["minLifeSpend"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGetLtvReport(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/ltv`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "utmCampaign": params["utmCampaign"],
            "utmSource": params["utmSource"],
            "utmMedium": params["utmMedium"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGet_2(params: {  "startDate": Date; "endDate": Date; }, options?: any): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling keyMetricsGet_2");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling keyMetricsGet_2");
        }
        const baseUrl = `/api/admin/keymetrics`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "startDate": params["startDate"],
            "endDate": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * KeyMetricsApi - functional programming interface
 */
export const KeyMetricsApiFp = {
    /**
     * 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGet(params: { "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSummaryViewRecord>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    keyMetricsGetAdminReportBuyToShip(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportBuyToShip(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    keyMetricsGetAdminReportOfferStats(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportOfferStats(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param reportName 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGetAdminReportOfferStats_1(params: { "reportName": string; "startDate"?: Date; "endDate"?: Date;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportOfferStats_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromo(params: { "promoCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportPromo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromoUsers(params: { "promoCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhUserModel> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportPromoUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    keyMetricsGetCohortAnalysis(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhUserOrderCohort>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetCohortAnalysis(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param startMonth 
     * @param startYear 
     * @param minLifeSpend 
     */
    keyMetricsGetCohortsByFirstOrder(params: { "startMonth": number; "startYear": number; "minLifeSpend": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TimeSeriesCohortSummary> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetCohortsByFirstOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGetLtvReport(params: { "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserLifetimeViewRecord>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetLtvReport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGet_2(params: { "startDate": Date; "endDate": Date;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<KpiItem>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGet_2(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * KeyMetricsApi - object-oriented interface
 */
export class KeyMetricsApi extends BaseAPI {
    /**
     * 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGet(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    keyMetricsGetAdminReportBuyToShip(options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportBuyToShip(options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    keyMetricsGetAdminReportOfferStats(options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportOfferStats(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param reportName 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGetAdminReportOfferStats_1(params: {  "reportName": string; "startDate"?: Date; "endDate"?: Date; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportOfferStats_1(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromo(params: {  "promoCode": string; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportPromo(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromoUsers(params: {  "promoCode": string; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportPromoUsers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    keyMetricsGetCohortAnalysis(options?: any) {
        return KeyMetricsApiFp.keyMetricsGetCohortAnalysis(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param startMonth 
     * @param startYear 
     * @param minLifeSpend 
     */
    keyMetricsGetCohortsByFirstOrder(params: {  "startMonth": number; "startYear": number; "minLifeSpend": number; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGetCohortsByFirstOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGetLtvReport(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGetLtvReport(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGet_2(params: {  "startDate": Date; "endDate": Date; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGet_2(params, options)(this.fetch, this.basePath);
    }
};

/**
 * KeyMetricsApi - factory interface
 */
export const KeyMetricsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param utmCampaign 
         * @param utmSource 
         * @param utmMedium 
         */
        keyMetricsGet(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGet(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        keyMetricsGetAdminReportBuyToShip(options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportBuyToShip(options)(fetch, basePath);
        },
        /**
         * 
         */
        keyMetricsGetAdminReportOfferStats(options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportOfferStats(options)(fetch, basePath);
        },
        /**
         * 
         * @param reportName 
         * @param startDate 
         * @param endDate 
         */
        keyMetricsGetAdminReportOfferStats_1(params: {  "reportName": string; "startDate"?: Date; "endDate"?: Date; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportOfferStats_1(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param promoCode 
         */
        keyMetricsGetAdminReportPromo(params: {  "promoCode": string; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportPromo(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param promoCode 
         */
        keyMetricsGetAdminReportPromoUsers(params: {  "promoCode": string; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportPromoUsers(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        keyMetricsGetCohortAnalysis(options?: any) {
            return KeyMetricsApiFp.keyMetricsGetCohortAnalysis(options)(fetch, basePath);
        },
        /**
         * 
         * @param startMonth 
         * @param startYear 
         * @param minLifeSpend 
         */
        keyMetricsGetCohortsByFirstOrder(params: {  "startMonth": number; "startYear": number; "minLifeSpend": number; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGetCohortsByFirstOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param utmCampaign 
         * @param utmSource 
         * @param utmMedium 
         */
        keyMetricsGetLtvReport(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGetLtvReport(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param startDate 
         * @param endDate 
         */
        keyMetricsGet_2(params: {  "startDate": Date; "endDate": Date; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGet_2(params, options)(fetch, basePath);
        },
    };
};


/**
 * Leaderboard2Api - fetch parameter creator
 */
export const Leaderboard2ApiFetchParamCreator = {
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    leaderboard2LeaderSkuCounts(params: {  "sku": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling leaderboard2LeaderSkuCounts");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling leaderboard2LeaderSkuCounts");
        }
        const baseUrl = `/api/contest2`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sku": params["sku"],
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Leaderboard2Api - functional programming interface
 */
export const Leaderboard2ApiFp = {
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    leaderboard2LeaderSkuCounts(params: { "sku": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultLeaderboardModel> {
        const fetchArgs = Leaderboard2ApiFetchParamCreator.leaderboard2LeaderSkuCounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Leaderboard2Api - object-oriented interface
 */
export class Leaderboard2Api extends BaseAPI {
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    leaderboard2LeaderSkuCounts(params: {  "sku": string; "sessionId": string; }, options?: any) {
        return Leaderboard2ApiFp.leaderboard2LeaderSkuCounts(params, options)(this.fetch, this.basePath);
    }
};

/**
 * Leaderboard2Api - factory interface
 */
export const Leaderboard2ApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sku 
         * @param sessionId 
         */
        leaderboard2LeaderSkuCounts(params: {  "sku": string; "sessionId": string; }, options?: any) {
            return Leaderboard2ApiFp.leaderboard2LeaderSkuCounts(params, options)(fetch, basePath);
        },
    };
};


/**
 * ManifestAdminApi - fetch parameter creator
 */
export const ManifestAdminApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param manifestId 
     * @param isSuspended 
     * @param shouldCredit 
     * @param reason 
     */
    manifestAdminGetSuspend(params: {  "sessionId": string; "manifestId": string; "isSuspended": boolean; "shouldCredit": boolean; "reason": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling manifestAdminGetSuspend");
        }
        // verify required parameter "manifestId" is set
        if (params["manifestId"] == null) {
            throw new Error("Missing required parameter manifestId when calling manifestAdminGetSuspend");
        }
        // verify required parameter "isSuspended" is set
        if (params["isSuspended"] == null) {
            throw new Error("Missing required parameter isSuspended when calling manifestAdminGetSuspend");
        }
        // verify required parameter "shouldCredit" is set
        if (params["shouldCredit"] == null) {
            throw new Error("Missing required parameter shouldCredit when calling manifestAdminGetSuspend");
        }
        // verify required parameter "reason" is set
        if (params["reason"] == null) {
            throw new Error("Missing required parameter reason when calling manifestAdminGetSuspend");
        }
        const baseUrl = `/api/admin/manifests/{manifestId}/suspend`
            .replace(`{${"manifestId"}}`, `${ params["manifestId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "isSuspended": params["isSuspended"],
            "shouldCredit": params["shouldCredit"],
            "reason": params["reason"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param shipId 
     * @param orderId 
     * @param includeShipped 
     * @param includeUnshipped 
     * @param skip 
     * @param take 
     * @param search 
     */
    manifestAdminGetUserManifests(params: {  "sessionId": string; "userId": string; "shipId": string; "orderId": string; "includeShipped": boolean; "includeUnshipped": boolean; "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling manifestAdminGetUserManifests");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling manifestAdminGetUserManifests");
        }
        // verify required parameter "shipId" is set
        if (params["shipId"] == null) {
            throw new Error("Missing required parameter shipId when calling manifestAdminGetUserManifests");
        }
        // verify required parameter "orderId" is set
        if (params["orderId"] == null) {
            throw new Error("Missing required parameter orderId when calling manifestAdminGetUserManifests");
        }
        // verify required parameter "includeShipped" is set
        if (params["includeShipped"] == null) {
            throw new Error("Missing required parameter includeShipped when calling manifestAdminGetUserManifests");
        }
        // verify required parameter "includeUnshipped" is set
        if (params["includeUnshipped"] == null) {
            throw new Error("Missing required parameter includeUnshipped when calling manifestAdminGetUserManifests");
        }
        const baseUrl = `/api/admin/manifests/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "userId": params["userId"],
            "shipId": params["shipId"],
            "orderId": params["orderId"],
            "includeShipped": params["includeShipped"],
            "includeUnshipped": params["includeUnshipped"],
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ManifestAdminApi - functional programming interface
 */
export const ManifestAdminApiFp = {
    /**
     * 
     * @param sessionId 
     * @param manifestId 
     * @param isSuspended 
     * @param shouldCredit 
     * @param reason 
     */
    manifestAdminGetSuspend(params: { "sessionId": string; "manifestId": string; "isSuspended": boolean; "shouldCredit": boolean; "reason": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = ManifestAdminApiFetchParamCreator.manifestAdminGetSuspend(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param shipId 
     * @param orderId 
     * @param includeShipped 
     * @param includeUnshipped 
     * @param skip 
     * @param take 
     * @param search 
     */
    manifestAdminGetUserManifests(params: { "sessionId": string; "userId": string; "shipId": string; "orderId": string; "includeShipped": boolean; "includeUnshipped": boolean; "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPgCloudCellarRecord> {
        const fetchArgs = ManifestAdminApiFetchParamCreator.manifestAdminGetUserManifests(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ManifestAdminApi - object-oriented interface
 */
export class ManifestAdminApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param manifestId 
     * @param isSuspended 
     * @param shouldCredit 
     * @param reason 
     */
    manifestAdminGetSuspend(params: {  "sessionId": string; "manifestId": string; "isSuspended": boolean; "shouldCredit": boolean; "reason": string; }, options?: any) {
        return ManifestAdminApiFp.manifestAdminGetSuspend(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param shipId 
     * @param orderId 
     * @param includeShipped 
     * @param includeUnshipped 
     * @param skip 
     * @param take 
     * @param search 
     */
    manifestAdminGetUserManifests(params: {  "sessionId": string; "userId": string; "shipId": string; "orderId": string; "includeShipped": boolean; "includeUnshipped": boolean; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return ManifestAdminApiFp.manifestAdminGetUserManifests(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ManifestAdminApi - factory interface
 */
export const ManifestAdminApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param manifestId 
         * @param isSuspended 
         * @param shouldCredit 
         * @param reason 
         */
        manifestAdminGetSuspend(params: {  "sessionId": string; "manifestId": string; "isSuspended": boolean; "shouldCredit": boolean; "reason": string; }, options?: any) {
            return ManifestAdminApiFp.manifestAdminGetSuspend(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param userId 
         * @param shipId 
         * @param orderId 
         * @param includeShipped 
         * @param includeUnshipped 
         * @param skip 
         * @param take 
         * @param search 
         */
        manifestAdminGetUserManifests(params: {  "sessionId": string; "userId": string; "shipId": string; "orderId": string; "includeShipped": boolean; "includeUnshipped": boolean; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return ManifestAdminApiFp.manifestAdminGetUserManifests(params, options)(fetch, basePath);
        },
    };
};


/**
 * OfferApi - fetch parameter creator
 */
export const OfferApiFetchParamCreator = {
    /**
     * 
     * @param sku 
     * @param sessionId 
     * @param cogs 
     * @param qty 
     */
    offerApplySkuCogs(params: {  "sku": string; "sessionId": string; "cogs": number; "qty": number; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling offerApplySkuCogs");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerApplySkuCogs");
        }
        // verify required parameter "cogs" is set
        if (params["cogs"] == null) {
            throw new Error("Missing required parameter cogs when calling offerApplySkuCogs");
        }
        // verify required parameter "qty" is set
        if (params["qty"] == null) {
            throw new Error("Missing required parameter qty when calling offerApplySkuCogs");
        }
        const baseUrl = `/api/v2/admin/sku/manifests/{sku}/applyCogs`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "cogs": params["cogs"],
            "qty": params["qty"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param cacheKey 
     */
    offerGetDetail(params: {  "offerSef": string; "cacheKey"?: string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerGetDetail");
        }
        const baseUrl = `/api/v2/offer/{offerSef}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cacheKey": params["cacheKey"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerGetLiveFeed(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerGetLiveFeed");
        }
        const baseUrl = `/api/v2/offer/{offerSef}/feed`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    offerGetManifestsBySku(params: {  "sku": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling offerGetManifestsBySku");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerGetManifestsBySku");
        }
        const baseUrl = `/api/v2/admin/sku/manifests/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    offerHandleListAppellation(options?: any): FetchArgs {
        const baseUrl = `/api/v2/appellation`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    offerHandleListRegion(options?: any): FetchArgs {
        const baseUrl = `/api/v2/region`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param sessionId 
     */
    offerHttpDeleteAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpDeleteAdminV2OfferItemGroupById");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling offerHttpDeleteAdminV2OfferItemGroupById");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpDeleteAdminV2OfferItemGroupById");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/itemgroup/{id}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param search 
     * @param sessionId 
     */
    offerHttpGetAdminV2Offer(params: {  "search": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling offerHttpGetAdminV2Offer");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpGetAdminV2Offer");
        }
        const baseUrl = `/api/v2/admin/offer`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferItemGroup(params: {  "offerSef": string; "id": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferItemGroup");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling offerHttpGetAdminV2OfferItemGroup");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpGetAdminV2OfferItemGroup");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/itemgroup/{id}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferManifest(params: {  "offerSef": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferManifest");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpGetAdminV2OfferManifest");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/manifest`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferOverview(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferOverview");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/overview`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferSef(params: {  "offerSef": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferSef");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpGetAdminV2OfferSef");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuList(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferSkuList");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/sku`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferSkuSales(params: {  "offerSef": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferSkuSales");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpGetAdminV2OfferSkuSales");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/sku/sales`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param entity 
     * @param sessionId 
     */
    offerHttpPostAdminV2Offer(params: {  "entity": OfferV2Entity; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "entity" is set
        if (params["entity"] == null) {
            throw new Error("Missing required parameter entity when calling offerHttpPostAdminV2Offer");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpPostAdminV2Offer");
        }
        const baseUrl = `/api/v2/admin/offer`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entity"]) {
            fetchOptions.body = JSON.stringify(params["entity"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param itemGroupToAdd 
     * @param sessionId 
     */
    offerHttpPostAdminV2OfferSkuList(params: {  "offerSef": string; "itemGroupToAdd": NhItemGroupEntity; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpPostAdminV2OfferSkuList");
        }
        // verify required parameter "itemGroupToAdd" is set
        if (params["itemGroupToAdd"] == null) {
            throw new Error("Missing required parameter itemGroupToAdd when calling offerHttpPostAdminV2OfferSkuList");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpPostAdminV2OfferSkuList");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/sku`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemGroupToAdd"]) {
            fetchOptions.body = JSON.stringify(params["itemGroupToAdd"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param itemGroup 
     * @param sessionId 
     */
    offerHttpPutAdminV2OfferItemGroup(params: {  "offerSef": string; "id": string; "itemGroup": NhItemGroupEntity; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpPutAdminV2OfferItemGroup");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling offerHttpPutAdminV2OfferItemGroup");
        }
        // verify required parameter "itemGroup" is set
        if (params["itemGroup"] == null) {
            throw new Error("Missing required parameter itemGroup when calling offerHttpPutAdminV2OfferItemGroup");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpPutAdminV2OfferItemGroup");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/itemgroup/{id}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemGroup"]) {
            fetchOptions.body = JSON.stringify(params["itemGroup"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param model 
     * @param sessionId 
     */
    offerHttpPutAdminV2OfferSef(params: {  "offerSef": string; "model": OfferV2Entity; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpPutAdminV2OfferSef");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling offerHttpPutAdminV2OfferSef");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpPutAdminV2OfferSef");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param startDate 
     * @param endDate 
     * @param skuFilter 
     */
    offerHttpTaxRecords(params: {  "sessionId": string; "startDate": string; "endDate": string; "skuFilter": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerHttpTaxRecords");
        }
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling offerHttpTaxRecords");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling offerHttpTaxRecords");
        }
        // verify required parameter "skuFilter" is set
        if (params["skuFilter"] == null) {
            throw new Error("Missing required parameter skuFilter when calling offerHttpTaxRecords");
        }
        const baseUrl = `/api/v2/admin/tax`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "startDate": params["startDate"],
            "endDate": params["endDate"],
            "skuFilter": params["skuFilter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     * @param items 
     * @param isTest 
     */
    offerItemGroupBulkLoad(params: {  "offerSef": string; "sessionId": string; "items": Array<NhItemGroupViewEntity>; "isTest": boolean; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerItemGroupBulkLoad");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling offerItemGroupBulkLoad");
        }
        // verify required parameter "items" is set
        if (params["items"] == null) {
            throw new Error("Missing required parameter items when calling offerItemGroupBulkLoad");
        }
        // verify required parameter "isTest" is set
        if (params["isTest"] == null) {
            throw new Error("Missing required parameter isTest when calling offerItemGroupBulkLoad");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/itemgroupbulk`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "isTest": params["isTest"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["items"]) {
            fetchOptions.body = JSON.stringify(params["items"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param filter 
     * @param skip 
     * @param take 
     * @param forcePopulate 
     * @param search 
     */
    offerOfferListHandler(params: {  "filter"?: boolean; "skip"?: number; "take"?: number; "forcePopulate"?: boolean; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/offer`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
            "skip": params["skip"],
            "take": params["take"],
            "forcePopulate": params["forcePopulate"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OfferApi - functional programming interface
 */
export const OfferApiFp = {
    /**
     * 
     * @param sku 
     * @param sessionId 
     * @param cogs 
     * @param qty 
     */
    offerApplySkuCogs(params: { "sku": string; "sessionId": string; "cogs": number; "qty": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultManifestList> {
        const fetchArgs = OfferApiFetchParamCreator.offerApplySkuCogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param cacheKey 
     */
    offerGetDetail(params: { "offerSef": string; "cacheKey"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferDetailModel> {
        const fetchArgs = OfferApiFetchParamCreator.offerGetDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerGetLiveFeed(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LiveFeedItem>> {
        const fetchArgs = OfferApiFetchParamCreator.offerGetLiveFeed(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    offerGetManifestsBySku(params: { "sku": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListOfferV2AdminManifest> {
        const fetchArgs = OfferApiFetchParamCreator.offerGetManifestsBySku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    offerHandleListAppellation(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHandleListAppellation(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    offerHandleListRegion(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHandleListRegion(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param sessionId 
     */
    offerHttpDeleteAdminV2OfferItemGroupById(params: { "offerSef": string; "id": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpDeleteAdminV2OfferItemGroupById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param search 
     * @param sessionId 
     */
    offerHttpGetAdminV2Offer(params: { "search": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListOfferV2Entity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2Offer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferItemGroup(params: { "offerSef": string; "id": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhItemGroupEntity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferItemGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferManifest(params: { "offerSef": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListOfferV2AdminManifest> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferManifest(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferOverview(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminOfferOverviewModel> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferOverview(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferSef(params: { "offerSef": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferV2Entity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferSef(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuList(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhItemGroupEntity>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferSkuList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferSkuSales(params: { "offerSef": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListSkuSale> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferSkuSales(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param entity 
     * @param sessionId 
     */
    offerHttpPostAdminV2Offer(params: { "entity": OfferV2Entity; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferV2Entity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpPostAdminV2Offer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param itemGroupToAdd 
     * @param sessionId 
     */
    offerHttpPostAdminV2OfferSkuList(params: { "offerSef": string; "itemGroupToAdd": NhItemGroupEntity; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhItemGroupEntity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpPostAdminV2OfferSkuList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param itemGroup 
     * @param sessionId 
     */
    offerHttpPutAdminV2OfferItemGroup(params: { "offerSef": string; "id": string; "itemGroup": NhItemGroupEntity; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhItemGroupEntity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpPutAdminV2OfferItemGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param model 
     * @param sessionId 
     */
    offerHttpPutAdminV2OfferSef(params: { "offerSef": string; "model": OfferV2Entity; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferV2Entity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpPutAdminV2OfferSef(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param startDate 
     * @param endDate 
     * @param skuFilter 
     */
    offerHttpTaxRecords(params: { "sessionId": string; "startDate": string; "endDate": string; "skuFilter": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListTaxReportRecord> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpTaxRecords(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     * @param items 
     * @param isTest 
     */
    offerItemGroupBulkLoad(params: { "offerSef": string; "sessionId": string; "items": Array<NhItemGroupViewEntity>; "isTest": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhItemGroupViewEntity> {
        const fetchArgs = OfferApiFetchParamCreator.offerItemGroupBulkLoad(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param filter 
     * @param skip 
     * @param take 
     * @param forcePopulate 
     * @param search 
     */
    offerOfferListHandler(params: { "filter"?: boolean; "skip"?: number; "take"?: number; "forcePopulate"?: boolean; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OfferV2Entity>> {
        const fetchArgs = OfferApiFetchParamCreator.offerOfferListHandler(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OfferApi - object-oriented interface
 */
export class OfferApi extends BaseAPI {
    /**
     * 
     * @param sku 
     * @param sessionId 
     * @param cogs 
     * @param qty 
     */
    offerApplySkuCogs(params: {  "sku": string; "sessionId": string; "cogs": number; "qty": number; }, options?: any) {
        return OfferApiFp.offerApplySkuCogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param cacheKey 
     */
    offerGetDetail(params: {  "offerSef": string; "cacheKey"?: string; }, options?: any) {
        return OfferApiFp.offerGetDetail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     */
    offerGetLiveFeed(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerGetLiveFeed(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    offerGetManifestsBySku(params: {  "sku": string; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerGetManifestsBySku(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    offerHandleListAppellation(options?: any) {
        return OfferApiFp.offerHandleListAppellation(options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    offerHandleListRegion(options?: any) {
        return OfferApiFp.offerHandleListRegion(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param sessionId 
     */
    offerHttpDeleteAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpDeleteAdminV2OfferItemGroupById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param search 
     * @param sessionId 
     */
    offerHttpGetAdminV2Offer(params: {  "search": string; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2Offer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferItemGroup(params: {  "offerSef": string; "id": string; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferItemGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferManifest(params: {  "offerSef": string; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferManifest(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferOverview(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferOverview(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferSef(params: {  "offerSef": string; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferSef(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuList(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferSkuList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     */
    offerHttpGetAdminV2OfferSkuSales(params: {  "offerSef": string; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferSkuSales(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param entity 
     * @param sessionId 
     */
    offerHttpPostAdminV2Offer(params: {  "entity": OfferV2Entity; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpPostAdminV2Offer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param itemGroupToAdd 
     * @param sessionId 
     */
    offerHttpPostAdminV2OfferSkuList(params: {  "offerSef": string; "itemGroupToAdd": NhItemGroupEntity; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpPostAdminV2OfferSkuList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param id 
     * @param itemGroup 
     * @param sessionId 
     */
    offerHttpPutAdminV2OfferItemGroup(params: {  "offerSef": string; "id": string; "itemGroup": NhItemGroupEntity; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpPutAdminV2OfferItemGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param model 
     * @param sessionId 
     */
    offerHttpPutAdminV2OfferSef(params: {  "offerSef": string; "model": OfferV2Entity; "sessionId": string; }, options?: any) {
        return OfferApiFp.offerHttpPutAdminV2OfferSef(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param startDate 
     * @param endDate 
     * @param skuFilter 
     */
    offerHttpTaxRecords(params: {  "sessionId": string; "startDate": string; "endDate": string; "skuFilter": string; }, options?: any) {
        return OfferApiFp.offerHttpTaxRecords(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param sessionId 
     * @param items 
     * @param isTest 
     */
    offerItemGroupBulkLoad(params: {  "offerSef": string; "sessionId": string; "items": Array<NhItemGroupViewEntity>; "isTest": boolean; }, options?: any) {
        return OfferApiFp.offerItemGroupBulkLoad(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param filter 
     * @param skip 
     * @param take 
     * @param forcePopulate 
     * @param search 
     */
    offerOfferListHandler(params: {  "filter"?: boolean; "skip"?: number; "take"?: number; "forcePopulate"?: boolean; "search"?: string; }, options?: any) {
        return OfferApiFp.offerOfferListHandler(params, options)(this.fetch, this.basePath);
    }
};

/**
 * OfferApi - factory interface
 */
export const OfferApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sku 
         * @param sessionId 
         * @param cogs 
         * @param qty 
         */
        offerApplySkuCogs(params: {  "sku": string; "sessionId": string; "cogs": number; "qty": number; }, options?: any) {
            return OfferApiFp.offerApplySkuCogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param cacheKey 
         */
        offerGetDetail(params: {  "offerSef": string; "cacheKey"?: string; }, options?: any) {
            return OfferApiFp.offerGetDetail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         */
        offerGetLiveFeed(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerGetLiveFeed(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sku 
         * @param sessionId 
         */
        offerGetManifestsBySku(params: {  "sku": string; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerGetManifestsBySku(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        offerHandleListAppellation(options?: any) {
            return OfferApiFp.offerHandleListAppellation(options)(fetch, basePath);
        },
        /**
         * 
         */
        offerHandleListRegion(options?: any) {
            return OfferApiFp.offerHandleListRegion(options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param id 
         * @param sessionId 
         */
        offerHttpDeleteAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpDeleteAdminV2OfferItemGroupById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param search 
         * @param sessionId 
         */
        offerHttpGetAdminV2Offer(params: {  "search": string; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2Offer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param id 
         * @param sessionId 
         */
        offerHttpGetAdminV2OfferItemGroup(params: {  "offerSef": string; "id": string; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferItemGroup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param sessionId 
         */
        offerHttpGetAdminV2OfferManifest(params: {  "offerSef": string; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferManifest(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         */
        offerHttpGetAdminV2OfferOverview(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferOverview(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param sessionId 
         */
        offerHttpGetAdminV2OfferSef(params: {  "offerSef": string; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferSef(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         */
        offerHttpGetAdminV2OfferSkuList(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferSkuList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param sessionId 
         */
        offerHttpGetAdminV2OfferSkuSales(params: {  "offerSef": string; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferSkuSales(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param entity 
         * @param sessionId 
         */
        offerHttpPostAdminV2Offer(params: {  "entity": OfferV2Entity; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpPostAdminV2Offer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param itemGroupToAdd 
         * @param sessionId 
         */
        offerHttpPostAdminV2OfferSkuList(params: {  "offerSef": string; "itemGroupToAdd": NhItemGroupEntity; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpPostAdminV2OfferSkuList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param id 
         * @param itemGroup 
         * @param sessionId 
         */
        offerHttpPutAdminV2OfferItemGroup(params: {  "offerSef": string; "id": string; "itemGroup": NhItemGroupEntity; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpPutAdminV2OfferItemGroup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param model 
         * @param sessionId 
         */
        offerHttpPutAdminV2OfferSef(params: {  "offerSef": string; "model": OfferV2Entity; "sessionId": string; }, options?: any) {
            return OfferApiFp.offerHttpPutAdminV2OfferSef(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param startDate 
         * @param endDate 
         * @param skuFilter 
         */
        offerHttpTaxRecords(params: {  "sessionId": string; "startDate": string; "endDate": string; "skuFilter": string; }, options?: any) {
            return OfferApiFp.offerHttpTaxRecords(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param sessionId 
         * @param items 
         * @param isTest 
         */
        offerItemGroupBulkLoad(params: {  "offerSef": string; "sessionId": string; "items": Array<NhItemGroupViewEntity>; "isTest": boolean; }, options?: any) {
            return OfferApiFp.offerItemGroupBulkLoad(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param filter 
         * @param skip 
         * @param take 
         * @param forcePopulate 
         * @param search 
         */
        offerOfferListHandler(params: {  "filter"?: boolean; "skip"?: number; "take"?: number; "forcePopulate"?: boolean; "search"?: string; }, options?: any) {
            return OfferApiFp.offerOfferListHandler(params, options)(fetch, basePath);
        },
    };
};


/**
 * OfferDetailApi - fetch parameter creator
 */
export const OfferDetailApiFetchParamCreator = {
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetLiveFeedDetail(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerDetailGetLiveFeedDetail");
        }
        const baseUrl = `/api/offer/detail/{offerSef}/feed`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetOfferBottles(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerDetailGetOfferBottles");
        }
        const baseUrl = `/api/offer/detail/{offerSef}/bottles`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetOfferDetailBasic(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerDetailGetOfferDetailBasic");
        }
        const baseUrl = `/api/offer/detail/{offerSef}/basic`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param file 
     */
    offerDetailPostOfferUploadImage(params: {  "file": any; }, options?: any): FetchArgs {
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling offerDetailPostOfferUploadImage");
        }
        const baseUrl = `/api/offer/detail/uploadImage`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    offerDetailSitemapIndex(options?: any): FetchArgs {
        const baseUrl = `/api/offer/sitemapIndex`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OfferDetailApi - functional programming interface
 */
export const OfferDetailApiFp = {
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetLiveFeedDetail(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LiveFeedItem>> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailGetLiveFeedDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetOfferBottles(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhItemGroupViewEntity>> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailGetOfferBottles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetOfferDetailBasic(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferV2Entity> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailGetOfferDetailBasic(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param file 
     */
    offerDetailPostOfferUploadImage(params: { "file": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailPostOfferUploadImage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    offerDetailSitemapIndex(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailSitemapIndex(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OfferDetailApi - object-oriented interface
 */
export class OfferDetailApi extends BaseAPI {
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetLiveFeedDetail(params: {  "offerSef": string; }, options?: any) {
        return OfferDetailApiFp.offerDetailGetLiveFeedDetail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetOfferBottles(params: {  "offerSef": string; }, options?: any) {
        return OfferDetailApiFp.offerDetailGetOfferBottles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     */
    offerDetailGetOfferDetailBasic(params: {  "offerSef": string; }, options?: any) {
        return OfferDetailApiFp.offerDetailGetOfferDetailBasic(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param file 
     */
    offerDetailPostOfferUploadImage(params: {  "file": any; }, options?: any) {
        return OfferDetailApiFp.offerDetailPostOfferUploadImage(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    offerDetailSitemapIndex(options?: any) {
        return OfferDetailApiFp.offerDetailSitemapIndex(options)(this.fetch, this.basePath);
    }
};

/**
 * OfferDetailApi - factory interface
 */
export const OfferDetailApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param offerSef 
         */
        offerDetailGetLiveFeedDetail(params: {  "offerSef": string; }, options?: any) {
            return OfferDetailApiFp.offerDetailGetLiveFeedDetail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         */
        offerDetailGetOfferBottles(params: {  "offerSef": string; }, options?: any) {
            return OfferDetailApiFp.offerDetailGetOfferBottles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         */
        offerDetailGetOfferDetailBasic(params: {  "offerSef": string; }, options?: any) {
            return OfferDetailApiFp.offerDetailGetOfferDetailBasic(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param file 
         */
        offerDetailPostOfferUploadImage(params: {  "file": any; }, options?: any) {
            return OfferDetailApiFp.offerDetailPostOfferUploadImage(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        offerDetailSitemapIndex(options?: any) {
            return OfferDetailApiFp.offerDetailSitemapIndex(options)(fetch, basePath);
        },
    };
};


/**
 * OrderStatusApi - fetch parameter creator
 */
export const OrderStatusApiFetchParamCreator = {
    /**
     * 
     * @param orderId 
     */
    orderStatusGetOrder(params: {  "orderId": string; }, options?: any): FetchArgs {
        // verify required parameter "orderId" is set
        if (params["orderId"] == null) {
            throw new Error("Missing required parameter orderId when calling orderStatusGetOrder");
        }
        const baseUrl = `/api/order/{orderId}`
            .replace(`{${"orderId"}}`, `${ params["orderId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OrderStatusApi - functional programming interface
 */
export const OrderStatusApiFp = {
    /**
     * 
     * @param orderId 
     */
    orderStatusGetOrder(params: { "orderId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOrderViewModel> {
        const fetchArgs = OrderStatusApiFetchParamCreator.orderStatusGetOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OrderStatusApi - object-oriented interface
 */
export class OrderStatusApi extends BaseAPI {
    /**
     * 
     * @param orderId 
     */
    orderStatusGetOrder(params: {  "orderId": string; }, options?: any) {
        return OrderStatusApiFp.orderStatusGetOrder(params, options)(this.fetch, this.basePath);
    }
};

/**
 * OrderStatusApi - factory interface
 */
export const OrderStatusApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param orderId 
         */
        orderStatusGetOrder(params: {  "orderId": string; }, options?: any) {
            return OrderStatusApiFp.orderStatusGetOrder(params, options)(fetch, basePath);
        },
    };
};


/**
 * PageApi - fetch parameter creator
 */
export const PageApiFetchParamCreator = {
    /**
     * 
     * @param search 
     * @param onlyPublished 
     */
    pageGetPage(params: {  "search"?: string; "onlyPublished"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/api/page`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "onlyPublished": params["onlyPublished"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param id 
     */
    pageGetPageById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pageGetPageById");
        }
        const baseUrl = `/api/page/id/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param section 
     * @param id 
     */
    pageGetPageBySection(params: {  "section": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "section" is set
        if (params["section"] == null) {
            throw new Error("Missing required parameter section when calling pageGetPageBySection");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling pageGetPageBySection");
        }
        const baseUrl = `/api/page/section/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "section": params["section"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    pageGetSections(options?: any): FetchArgs {
        const baseUrl = `/api/page/section`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param file 
     */
    pagePostIPageUploadImage(params: {  "file": any; }, options?: any): FetchArgs {
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling pagePostIPageUploadImage");
        }
        const baseUrl = `/api/page/uploadimage`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     */
    pagePublishPageVersion(params: {  "model": Page; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling pagePublishPageVersion");
        }
        const baseUrl = `/api/page`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PageApi - functional programming interface
 */
export const PageApiFp = {
    /**
     * 
     * @param search 
     * @param onlyPublished 
     */
    pageGetPage(params: { "search"?: string; "onlyPublished"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPage> {
        const fetchArgs = PageApiFetchParamCreator.pageGetPage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param id 
     */
    pageGetPageById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPage> {
        const fetchArgs = PageApiFetchParamCreator.pageGetPageById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param section 
     * @param id 
     */
    pageGetPageBySection(params: { "section": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPage> {
        const fetchArgs = PageApiFetchParamCreator.pageGetPageBySection(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    pageGetSections(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListString> {
        const fetchArgs = PageApiFetchParamCreator.pageGetSections(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param file 
     */
    pagePostIPageUploadImage(params: { "file": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PageApiFetchParamCreator.pagePostIPageUploadImage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     */
    pagePublishPageVersion(params: { "model": Page;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPage> {
        const fetchArgs = PageApiFetchParamCreator.pagePublishPageVersion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PageApi - object-oriented interface
 */
export class PageApi extends BaseAPI {
    /**
     * 
     * @param search 
     * @param onlyPublished 
     */
    pageGetPage(params: {  "search"?: string; "onlyPublished"?: boolean; }, options?: any) {
        return PageApiFp.pageGetPage(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param id 
     */
    pageGetPageById(params: {  "id": string; }, options?: any) {
        return PageApiFp.pageGetPageById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param section 
     * @param id 
     */
    pageGetPageBySection(params: {  "section": string; "id": string; }, options?: any) {
        return PageApiFp.pageGetPageBySection(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    pageGetSections(options?: any) {
        return PageApiFp.pageGetSections(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param file 
     */
    pagePostIPageUploadImage(params: {  "file": any; }, options?: any) {
        return PageApiFp.pagePostIPageUploadImage(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     */
    pagePublishPageVersion(params: {  "model": Page; }, options?: any) {
        return PageApiFp.pagePublishPageVersion(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PageApi - factory interface
 */
export const PageApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param search 
         * @param onlyPublished 
         */
        pageGetPage(params: {  "search"?: string; "onlyPublished"?: boolean; }, options?: any) {
            return PageApiFp.pageGetPage(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param id 
         */
        pageGetPageById(params: {  "id": string; }, options?: any) {
            return PageApiFp.pageGetPageById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param section 
         * @param id 
         */
        pageGetPageBySection(params: {  "section": string; "id": string; }, options?: any) {
            return PageApiFp.pageGetPageBySection(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        pageGetSections(options?: any) {
            return PageApiFp.pageGetSections(options)(fetch, basePath);
        },
        /**
         * 
         * @param file 
         */
        pagePostIPageUploadImage(params: {  "file": any; }, options?: any) {
            return PageApiFp.pagePostIPageUploadImage(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         */
        pagePublishPageVersion(params: {  "model": Page; }, options?: any) {
            return PageApiFp.pagePublishPageVersion(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentApi - fetch parameter creator
 */
export const PaymentApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     */
    paymentGetAddressAndPayment(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentGetAddressAndPayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-address-and-payment`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Convenience method to create both an address and payment entry. Will reuse existing address if a match already  exists in the user's profile.
     * @param sessionId Session identifier.
     * @param model Specify address and payment to add.
     */
    paymentPostAddressAndPayment(params: {  "sessionId": string; "model": PaymentWithAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentPostAddressAndPayment");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling paymentPostAddressAndPayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-address-and-payment`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an authenticated user's payment profile. Also removes the profile from CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionDeletePayment(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionDeletePayment");
        }
        // verify required parameter "paymentProfileId" is set
        if (params["paymentProfileId"] == null) {
            throw new Error("Missing required parameter paymentProfileId when calling paymentSessionDeletePayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment/{paymentProfileId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"paymentProfileId"}}`, `${ params["paymentProfileId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets a detailed payment profile for the authenticated user.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionGetPaymentById(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionGetPaymentById");
        }
        // verify required parameter "paymentProfileId" is set
        if (params["paymentProfileId"] == null) {
            throw new Error("Missing required parameter paymentProfileId when calling paymentSessionGetPaymentById");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment/{paymentProfileId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"paymentProfileId"}}`, `${ params["paymentProfileId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPayments(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionGetPayments");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPaymentsList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionGetPaymentsList");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new payment entity in the authenticated user's profile. Also creates the payment entity in CIM. The  Address entity should have already been created.
     * @param sessionId Session identifier.
     * @param ccinfo Ccinfo.
     */
    paymentSessionPostPayment(params: {  "sessionId": string; "ccinfo": ApiBillingModelWithAuthnet; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionPostPayment");
        }
        // verify required parameter "ccinfo" is set
        if (params["ccinfo"] == null) {
            throw new Error("Missing required parameter ccinfo when calling paymentSessionPostPayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["ccinfo"]) {
            fetchOptions.body = JSON.stringify(params["ccinfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a user's payment profile. Also updates CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     * @param newInfo New payment info.
     */
    paymentSessionUpdatePayment(params: {  "sessionId": string; "paymentProfileId": string; "newInfo": ApiBillingModelWithAuthnet; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionUpdatePayment");
        }
        // verify required parameter "paymentProfileId" is set
        if (params["paymentProfileId"] == null) {
            throw new Error("Missing required parameter paymentProfileId when calling paymentSessionUpdatePayment");
        }
        // verify required parameter "newInfo" is set
        if (params["newInfo"] == null) {
            throw new Error("Missing required parameter newInfo when calling paymentSessionUpdatePayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment/{paymentProfileId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"paymentProfileId"}}`, `${ params["paymentProfileId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newInfo"]) {
            fetchOptions.body = JSON.stringify(params["newInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    paymentSetDefaultItem(params: {  "sessionId": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSetDefaultItem");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling paymentSetDefaultItem");
        }
        const baseUrl = `/api/session/{sessionId}/set-default/{id}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentApi - functional programming interface
 */
export const PaymentApiFp = {
    /**
     * 
     * @param sessionId 
     */
    paymentGetAddressAndPayment(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPaymentWithAddressModel> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentGetAddressAndPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Convenience method to create both an address and payment entry. Will reuse existing address if a match already  exists in the user's profile.
     * @param sessionId Session identifier.
     * @param model Specify address and payment to add.
     */
    paymentPostAddressAndPayment(params: { "sessionId": string; "model": PaymentWithAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPaymentWithAddressModel> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentPostAddressAndPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an authenticated user's payment profile. Also removes the profile from CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionDeletePayment(params: { "sessionId": string; "paymentProfileId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionDeletePayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets a detailed payment profile for the authenticated user.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionGetPaymentById(params: { "sessionId": string; "paymentProfileId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiBillingModelWithAuthnet> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionGetPaymentById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPayments(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: ApiBillingModelWithCardNumber; }> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionGetPayments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPaymentsList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApiBillingModelWithCardNumber>> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionGetPaymentsList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new payment entity in the authenticated user's profile. Also creates the payment entity in CIM. The  Address entity should have already been created.
     * @param sessionId Session identifier.
     * @param ccinfo Ccinfo.
     */
    paymentSessionPostPayment(params: { "sessionId": string; "ccinfo": ApiBillingModelWithAuthnet;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultApiBillingModelWithAuthnet> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionPostPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a user's payment profile. Also updates CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     * @param newInfo New payment info.
     */
    paymentSessionUpdatePayment(params: { "sessionId": string; "paymentProfileId": string; "newInfo": ApiBillingModelWithAuthnet;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiBillingModelWithAuthnet> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionUpdatePayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    paymentSetDefaultItem(params: { "sessionId": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSetDefaultItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentApi - object-oriented interface
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     */
    paymentGetAddressAndPayment(params: {  "sessionId": string; }, options?: any) {
        return PaymentApiFp.paymentGetAddressAndPayment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Convenience method to create both an address and payment entry. Will reuse existing address if a match already  exists in the user's profile.
     * @param sessionId Session identifier.
     * @param model Specify address and payment to add.
     */
    paymentPostAddressAndPayment(params: {  "sessionId": string; "model": PaymentWithAddressModel; }, options?: any) {
        return PaymentApiFp.paymentPostAddressAndPayment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an authenticated user's payment profile. Also removes the profile from CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionDeletePayment(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any) {
        return PaymentApiFp.paymentSessionDeletePayment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets a detailed payment profile for the authenticated user.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionGetPaymentById(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any) {
        return PaymentApiFp.paymentSessionGetPaymentById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPayments(params: {  "sessionId": string; }, options?: any) {
        return PaymentApiFp.paymentSessionGetPayments(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPaymentsList(params: {  "sessionId": string; }, options?: any) {
        return PaymentApiFp.paymentSessionGetPaymentsList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new payment entity in the authenticated user's profile. Also creates the payment entity in CIM. The  Address entity should have already been created.
     * @param sessionId Session identifier.
     * @param ccinfo Ccinfo.
     */
    paymentSessionPostPayment(params: {  "sessionId": string; "ccinfo": ApiBillingModelWithAuthnet; }, options?: any) {
        return PaymentApiFp.paymentSessionPostPayment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a user's payment profile. Also updates CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     * @param newInfo New payment info.
     */
    paymentSessionUpdatePayment(params: {  "sessionId": string; "paymentProfileId": string; "newInfo": ApiBillingModelWithAuthnet; }, options?: any) {
        return PaymentApiFp.paymentSessionUpdatePayment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param id 
     */
    paymentSetDefaultItem(params: {  "sessionId": string; "id": string; }, options?: any) {
        return PaymentApiFp.paymentSetDefaultItem(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentApi - factory interface
 */
export const PaymentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         */
        paymentGetAddressAndPayment(params: {  "sessionId": string; }, options?: any) {
            return PaymentApiFp.paymentGetAddressAndPayment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Convenience method to create both an address and payment entry. Will reuse existing address if a match already  exists in the user's profile.
         * @param sessionId Session identifier.
         * @param model Specify address and payment to add.
         */
        paymentPostAddressAndPayment(params: {  "sessionId": string; "model": PaymentWithAddressModel; }, options?: any) {
            return PaymentApiFp.paymentPostAddressAndPayment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an authenticated user's payment profile. Also removes the profile from CIM.
         * @param sessionId Session identifier.
         * @param paymentProfileId Payment profile identifier.
         */
        paymentSessionDeletePayment(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any) {
            return PaymentApiFp.paymentSessionDeletePayment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets a detailed payment profile for the authenticated user.
         * @param sessionId Session identifier.
         * @param paymentProfileId Payment profile identifier.
         */
        paymentSessionGetPaymentById(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any) {
            return PaymentApiFp.paymentSessionGetPaymentById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets a list of payment profiles for the authenticated user.
         * @param sessionId The session token of the logged-in user.
         */
        paymentSessionGetPayments(params: {  "sessionId": string; }, options?: any) {
            return PaymentApiFp.paymentSessionGetPayments(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets a list of payment profiles for the authenticated user.
         * @param sessionId The session token of the logged-in user.
         */
        paymentSessionGetPaymentsList(params: {  "sessionId": string; }, options?: any) {
            return PaymentApiFp.paymentSessionGetPaymentsList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new payment entity in the authenticated user's profile. Also creates the payment entity in CIM. The  Address entity should have already been created.
         * @param sessionId Session identifier.
         * @param ccinfo Ccinfo.
         */
        paymentSessionPostPayment(params: {  "sessionId": string; "ccinfo": ApiBillingModelWithAuthnet; }, options?: any) {
            return PaymentApiFp.paymentSessionPostPayment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a user's payment profile. Also updates CIM.
         * @param sessionId Session identifier.
         * @param paymentProfileId Payment profile identifier.
         * @param newInfo New payment info.
         */
        paymentSessionUpdatePayment(params: {  "sessionId": string; "paymentProfileId": string; "newInfo": ApiBillingModelWithAuthnet; }, options?: any) {
            return PaymentApiFp.paymentSessionUpdatePayment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param id 
         */
        paymentSetDefaultItem(params: {  "sessionId": string; "id": string; }, options?: any) {
            return PaymentApiFp.paymentSetDefaultItem(params, options)(fetch, basePath);
        },
    };
};


/**
 * PromoGroupApi - fetch parameter creator
 */
export const PromoGroupApiFetchParamCreator = {
    /**
     * 
     * @summary GET /api/promoGroup/
     * @param sessionId 
     */
    promoGroupGet(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling promoGroupGet");
        }
        const baseUrl = `/api/promogroup`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary GET /api/promoGroup/##
     * @param sessionId 
     * @param id id of the promo group to enumerate promo codes
     */
    promoGroupGet_1(params: {  "sessionId": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling promoGroupGet_1");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling promoGroupGet_1");
        }
        const baseUrl = `/api/promogroup/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PromoGroupApi - functional programming interface
 */
export const PromoGroupApiFp = {
    /**
     * 
     * @summary GET /api/promoGroup/
     * @param sessionId 
     */
    promoGroupGet(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = PromoGroupApiFetchParamCreator.promoGroupGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary GET /api/promoGroup/##
     * @param sessionId 
     * @param id id of the promo group to enumerate promo codes
     */
    promoGroupGet_1(params: { "sessionId": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhPromoCodeModel>> {
        const fetchArgs = PromoGroupApiFetchParamCreator.promoGroupGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PromoGroupApi - object-oriented interface
 */
export class PromoGroupApi extends BaseAPI {
    /**
     * 
     * @summary GET /api/promoGroup/
     * @param sessionId 
     */
    promoGroupGet(params: {  "sessionId": string; }, options?: any) {
        return PromoGroupApiFp.promoGroupGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary GET /api/promoGroup/##
     * @param sessionId 
     * @param id id of the promo group to enumerate promo codes
     */
    promoGroupGet_1(params: {  "sessionId": string; "id": string; }, options?: any) {
        return PromoGroupApiFp.promoGroupGet_1(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PromoGroupApi - factory interface
 */
export const PromoGroupApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary GET /api/promoGroup/
         * @param sessionId 
         */
        promoGroupGet(params: {  "sessionId": string; }, options?: any) {
            return PromoGroupApiFp.promoGroupGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary GET /api/promoGroup/##
         * @param sessionId 
         * @param id id of the promo group to enumerate promo codes
         */
        promoGroupGet_1(params: {  "sessionId": string; "id": string; }, options?: any) {
            return PromoGroupApiFp.promoGroupGet_1(params, options)(fetch, basePath);
        },
    };
};


/**
 * PurchaseOrderApi - fetch parameter creator
 */
export const PurchaseOrderApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     */
    purchaseOrderGetPurchaseOrderList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling purchaseOrderGetPurchaseOrderList");
        }
        const baseUrl = `/api/v2/admin/po/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    purchaseOrderGetPurchaseOrders(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling purchaseOrderGetPurchaseOrders");
        }
        const baseUrl = `/api/v2/admin/po`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param sku 
     */
    purchaseOrderGetPurchaseOrdersForSku(params: {  "sessionId": string; "sku": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling purchaseOrderGetPurchaseOrdersForSku");
        }
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling purchaseOrderGetPurchaseOrdersForSku");
        }
        const baseUrl = `/api/v2/admin/po/sku/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    purchaseOrderPostPurchaseOrder(params: {  "sessionId": string; "model": PurchaseOrderModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling purchaseOrderPostPurchaseOrder");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling purchaseOrderPostPurchaseOrder");
        }
        const baseUrl = `/api/v2/admin/po`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PurchaseOrderApi - functional programming interface
 */
export const PurchaseOrderApiFp = {
    /**
     * 
     * @param sessionId 
     */
    purchaseOrderGetPurchaseOrderList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListString> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderGetPurchaseOrderList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    purchaseOrderGetPurchaseOrders(params: { "sessionId": string; "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPurchaseOrderModel> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderGetPurchaseOrders(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param sku 
     */
    purchaseOrderGetPurchaseOrdersForSku(params: { "sessionId": string; "sku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPurchaseOrderModel> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderGetPurchaseOrdersForSku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    purchaseOrderPostPurchaseOrder(params: { "sessionId": string; "model": PurchaseOrderModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPurchaseOrderModel> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderPostPurchaseOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PurchaseOrderApi - object-oriented interface
 */
export class PurchaseOrderApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     */
    purchaseOrderGetPurchaseOrderList(params: {  "sessionId": string; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrderList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    purchaseOrderGetPurchaseOrders(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrders(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param sku 
     */
    purchaseOrderGetPurchaseOrdersForSku(params: {  "sessionId": string; "sku": string; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrdersForSku(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    purchaseOrderPostPurchaseOrder(params: {  "sessionId": string; "model": PurchaseOrderModel; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderPostPurchaseOrder(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PurchaseOrderApi - factory interface
 */
export const PurchaseOrderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         */
        purchaseOrderGetPurchaseOrderList(params: {  "sessionId": string; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrderList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param skip 
         * @param take 
         * @param search 
         */
        purchaseOrderGetPurchaseOrders(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrders(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param sku 
         */
        purchaseOrderGetPurchaseOrdersForSku(params: {  "sessionId": string; "sku": string; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrdersForSku(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param model 
         */
        purchaseOrderPostPurchaseOrder(params: {  "sessionId": string; "model": PurchaseOrderModel; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderPostPurchaseOrder(params, options)(fetch, basePath);
        },
    };
};


/**
 * SessionApi - fetch parameter creator
 */
export const SessionApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param qty 
     */
    sessionCartExpress(params: {  "sessionId": string; "qty": number; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionCartExpress");
        }
        // verify required parameter "qty" is set
        if (params["qty"] == null) {
            throw new Error("Missing required parameter qty when calling sessionCartExpress");
        }
        const baseUrl = `/api/session/{sessionId}/cart-express-pick`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "qty": params["qty"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param qty 
     */
    sessionCartExpressPreview(params: {  "sessionId": string; "qty": number; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionCartExpressPreview");
        }
        // verify required parameter "qty" is set
        if (params["qty"] == null) {
            throw new Error("Missing required parameter qty when calling sessionCartExpressPreview");
        }
        const baseUrl = `/api/session/{sessionId}/cart-express-pick`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "qty": params["qty"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionCartGet(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionCartGet");
        }
        const baseUrl = `/api/session/{sessionId}/cart`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionCartGetGrouped(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionCartGetGrouped");
        }
        const baseUrl = `/api/session/{sessionId}/cart-groups`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param item 
     */
    sessionCartPut(params: {  "sessionId": string; "item": CloudCheckoutItem; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionCartPut");
        }
        // verify required parameter "item" is set
        if (params["item"] == null) {
            throw new Error("Missing required parameter item when calling sessionCartPut");
        }
        const baseUrl = `/api/session/{sessionId}/cart`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["item"]) {
            fetchOptions.body = JSON.stringify(params["item"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param promo 
     */
    sessionClaimPromo(params: {  "sessionId": string; "promo": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionClaimPromo");
        }
        // verify required parameter "promo" is set
        if (params["promo"] == null) {
            throw new Error("Missing required parameter promo when calling sessionClaimPromo");
        }
        const baseUrl = `/api/session/{sessionId}/claim-promo`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "promo": params["promo"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Generates a new session id
     */
    sessionGet(options?: any): FetchArgs {
        const baseUrl = `/api/session`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetFeatures(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetFeatures");
        }
        const baseUrl = `/api/session/{sessionId}/features`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionGiftList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionGiftList");
        }
        const baseUrl = `/api/session/{sessionId}/gc/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserCredit(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserCredit");
        }
        const baseUrl = `/api/session/{sessionId}/user-credit`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserCreditHistory(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserCreditHistory");
        }
        const baseUrl = `/api/session/{sessionId}/user-credit/history`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets the session user detail.
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserDetail(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserDetail");
        }
        const baseUrl = `/api/session/{sessionId}/user-detail`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserEmailPreferences(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserEmailPreferences");
        }
        const baseUrl = `/api/session/{sessionId}/user-email-preferences`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets the list of en-route bottles that are overdue for the current user. You can then redeem any of these  bottles for credit by calling Routes.SessionUserEnRouteBottleRedeem
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserEnRouteBottleList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserEnRouteBottleList");
        }
        const baseUrl = `/api/session/{sessionId}/enroute/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionGetSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserEnRouteBottleRedeem");
        }
        // verify required parameter "manifestGuid" is set
        if (params["manifestGuid"] == null) {
            throw new Error("Missing required parameter manifestGuid when calling sessionGetSessionUserEnRouteBottleRedeem");
        }
        const baseUrl = `/api/session/{sessionId}/enroute/redeem`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "manifestGuid": params["manifestGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param includeCanceled 
     */
    sessionGetSessionUserOrders(params: {  "sessionId": string; "skip": number; "take": number; "includeCanceled": boolean; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserOrders");
        }
        // verify required parameter "skip" is set
        if (params["skip"] == null) {
            throw new Error("Missing required parameter skip when calling sessionGetSessionUserOrders");
        }
        // verify required parameter "take" is set
        if (params["take"] == null) {
            throw new Error("Missing required parameter take when calling sessionGetSessionUserOrders");
        }
        // verify required parameter "includeCanceled" is set
        if (params["includeCanceled"] == null) {
            throw new Error("Missing required parameter includeCanceled when calling sessionGetSessionUserOrders");
        }
        const baseUrl = `/api/session/{sessionId}/user-orders`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "includeCanceled": params["includeCanceled"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param req 
     */
    sessionGetSupport(params: {  "sessionId": string; "req": SupportRequest; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSupport");
        }
        // verify required parameter "req" is set
        if (params["req"] == null) {
            throw new Error("Missing required parameter req when calling sessionGetSupport");
        }
        const baseUrl = `/api/session/{sessionId}/support`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get the session with the specified id.
     * @param sessionId Session identifier.
     */
    sessionGet_1(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGet_1");
        }
        const baseUrl = `/api/session/{sessionId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    sessionHandleEnrollApplePush(params: {  "sessionId": string; "model": ApplePushEnroll; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionHandleEnrollApplePush");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling sessionHandleEnrollApplePush");
        }
        const baseUrl = `/api/session/{sessionId}/apn`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param modelDeviceToken 
     * @param modelDeviceUuid 
     * @param modelEntryPoint 
     */
    sessionHandleGetApplePush(params: {  "sessionId": string; "modelDeviceToken"?: string; "modelDeviceUuid"?: string; "modelEntryPoint"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionHandleGetApplePush");
        }
        const baseUrl = `/api/session/{sessionId}/apn`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "model.deviceToken": params["modelDeviceToken"],
            "model.deviceUuid": params["modelDeviceUuid"],
            "model.entryPoint": params["modelEntryPoint"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param claimCode 
     */
    sessionHandleSessionGiftRedeem(params: {  "sessionId": string; "claimCode": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionHandleSessionGiftRedeem");
        }
        // verify required parameter "claimCode" is set
        if (params["claimCode"] == null) {
            throw new Error("Missing required parameter claimCode when calling sessionHandleSessionGiftRedeem");
        }
        const baseUrl = `/api/session/{sessionId}/gc/redeem`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "claimCode": params["claimCode"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param features 
     */
    sessionPostFeatures(params: {  "sessionId": string; "features": Array<FeatureRestriction>; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPostFeatures");
        }
        // verify required parameter "features" is set
        if (params["features"] == null) {
            throw new Error("Missing required parameter features when calling sessionPostFeatures");
        }
        const baseUrl = `/api/session/{sessionId}/features`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["features"]) {
            fetchOptions.body = JSON.stringify(params["features"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param file 
     */
    sessionPostSessionUploadImage(params: {  "sessionId": string; "file": any; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPostSessionUploadImage");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling sessionPostSessionUploadImage");
        }
        const baseUrl = `/api/session/{sessionId}/user-image`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Store the session with the specified id.
     * @param sessionId Session identifier.
     * @param data Data.
     */
    sessionPut(params: {  "sessionId": string; "data": SessionModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPut");
        }
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling sessionPut");
        }
        const baseUrl = `/api/session/{sessionId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Puts the session user detail.
     * @param sessionId Session identifier.
     * @param model Model.
     */
    sessionPutSessionUserDetail(params: {  "sessionId": string; "model": UserModelExtended; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPutSessionUserDetail");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling sessionPutSessionUserDetail");
        }
        const baseUrl = `/api/session/{sessionId}/user-detail`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionPutSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPutSessionUserEnRouteBottleRedeem");
        }
        // verify required parameter "manifestGuid" is set
        if (params["manifestGuid"] == null) {
            throw new Error("Missing required parameter manifestGuid when calling sessionPutSessionUserEnRouteBottleRedeem");
        }
        const baseUrl = `/api/session/{sessionId}/enroute/redeem`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "manifestGuid": params["manifestGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionSessionDelete(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionSessionDelete");
        }
        const baseUrl = `/api/session/{sessionId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionSessionSignOut(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionSessionSignOut");
        }
        const baseUrl = `/api/session/{sessionId}/signout`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SessionApi - functional programming interface
 */
export const SessionApiFp = {
    /**
     * 
     * @param sessionId 
     * @param qty 
     */
    sessionCartExpress(params: { "sessionId": string; "qty": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCloudCheckoutItem> {
        const fetchArgs = SessionApiFetchParamCreator.sessionCartExpress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param qty 
     */
    sessionCartExpressPreview(params: { "sessionId": string; "qty": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCloudCheckoutItem> {
        const fetchArgs = SessionApiFetchParamCreator.sessionCartExpressPreview(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionCartGet(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCloudCheckoutItem> {
        const fetchArgs = SessionApiFetchParamCreator.sessionCartGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionCartGetGrouped(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultCloudCart> {
        const fetchArgs = SessionApiFetchParamCreator.sessionCartGetGrouped(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param item 
     */
    sessionCartPut(params: { "sessionId": string; "item": CloudCheckoutItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCloudCheckoutItem> {
        const fetchArgs = SessionApiFetchParamCreator.sessionCartPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param promo 
     */
    sessionClaimPromo(params: { "sessionId": string; "promo": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPromoResult> {
        const fetchArgs = SessionApiFetchParamCreator.sessionClaimPromo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Generates a new session id
     */
    sessionGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SessionModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetFeatures(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListFeatureRestriction> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetFeatures(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionGiftList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCodeWithOrder> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionGiftList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserCredit(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultDecimal> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserCredit(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserCreditHistory(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListUserCreditViewModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserCreditHistory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets the session user detail.
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserDetail(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhUserModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserEmailPreferences(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhUserEmailPreference> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserEmailPreferences(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets the list of en-route bottles that are overdue for the current user. You can then redeem any of these  bottles for credit by calling Routes.SessionUserEnRouteBottleRedeem
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserEnRouteBottleList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPgCloudCellarRecord> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserEnRouteBottleList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionGetSessionUserEnRouteBottleRedeem(params: { "sessionId": string; "manifestGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListPgCloudCellarRecord> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserEnRouteBottleRedeem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param includeCanceled 
     */
    sessionGetSessionUserOrders(params: { "sessionId": string; "skip": number; "take": number; "includeCanceled": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOrdersOverviewModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserOrders(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param req 
     */
    sessionGetSupport(params: { "sessionId": string; "req": SupportRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSupportRequest> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSupport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get the session with the specified id.
     * @param sessionId Session identifier.
     */
    sessionGet_1(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SessionModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    sessionHandleEnrollApplePush(params: { "sessionId": string; "model": ApplePushEnroll;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultApplePushEnroll> {
        const fetchArgs = SessionApiFetchParamCreator.sessionHandleEnrollApplePush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param modelDeviceToken 
     * @param modelDeviceUuid 
     * @param modelEntryPoint 
     */
    sessionHandleGetApplePush(params: { "sessionId": string; "modelDeviceToken"?: string; "modelDeviceUuid"?: string; "modelEntryPoint"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultApplePushEnroll> {
        const fetchArgs = SessionApiFetchParamCreator.sessionHandleGetApplePush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param claimCode 
     */
    sessionHandleSessionGiftRedeem(params: { "sessionId": string; "claimCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultCheckoutPromoCodeModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionHandleSessionGiftRedeem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param features 
     */
    sessionPostFeatures(params: { "sessionId": string; "features": Array<FeatureRestriction>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListFeatureRestriction> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPostFeatures(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param file 
     */
    sessionPostSessionUploadImage(params: { "sessionId": string; "file": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPostSessionUploadImage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Store the session with the specified id.
     * @param sessionId Session identifier.
     * @param data Data.
     */
    sessionPut(params: { "sessionId": string; "data": SessionModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Puts the session user detail.
     * @param sessionId Session identifier.
     * @param model Model.
     */
    sessionPutSessionUserDetail(params: { "sessionId": string; "model": UserModelExtended;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultUserModelExtended> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPutSessionUserDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionPutSessionUserEnRouteBottleRedeem(params: { "sessionId": string; "manifestGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhCreditModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPutSessionUserEnRouteBottleRedeem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionSessionDelete(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OkNegotiatedContentResultApiResultBoolean> {
        const fetchArgs = SessionApiFetchParamCreator.sessionSessionDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionSessionSignOut(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = SessionApiFetchParamCreator.sessionSessionSignOut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SessionApi - object-oriented interface
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param qty 
     */
    sessionCartExpress(params: {  "sessionId": string; "qty": number; }, options?: any) {
        return SessionApiFp.sessionCartExpress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param qty 
     */
    sessionCartExpressPreview(params: {  "sessionId": string; "qty": number; }, options?: any) {
        return SessionApiFp.sessionCartExpressPreview(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    sessionCartGet(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionCartGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    sessionCartGetGrouped(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionCartGetGrouped(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param item 
     */
    sessionCartPut(params: {  "sessionId": string; "item": CloudCheckoutItem; }, options?: any) {
        return SessionApiFp.sessionCartPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param promo 
     */
    sessionClaimPromo(params: {  "sessionId": string; "promo": string; }, options?: any) {
        return SessionApiFp.sessionClaimPromo(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Generates a new session id
     */
    sessionGet(options?: any) {
        return SessionApiFp.sessionGet(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    sessionGetFeatures(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetFeatures(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionGiftList(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionGiftList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserCredit(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserCredit(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserCreditHistory(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserCreditHistory(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets the session user detail.
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserDetail(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserDetail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    sessionGetSessionUserEmailPreferences(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserEmailPreferences(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets the list of en-route bottles that are overdue for the current user. You can then redeem any of these  bottles for credit by calling Routes.SessionUserEnRouteBottleRedeem
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserEnRouteBottleList(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserEnRouteBottleList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionGetSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserEnRouteBottleRedeem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param includeCanceled 
     */
    sessionGetSessionUserOrders(params: {  "sessionId": string; "skip": number; "take": number; "includeCanceled": boolean; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserOrders(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param req 
     */
    sessionGetSupport(params: {  "sessionId": string; "req": SupportRequest; }, options?: any) {
        return SessionApiFp.sessionGetSupport(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get the session with the specified id.
     * @param sessionId Session identifier.
     */
    sessionGet_1(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGet_1(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    sessionHandleEnrollApplePush(params: {  "sessionId": string; "model": ApplePushEnroll; }, options?: any) {
        return SessionApiFp.sessionHandleEnrollApplePush(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param modelDeviceToken 
     * @param modelDeviceUuid 
     * @param modelEntryPoint 
     */
    sessionHandleGetApplePush(params: {  "sessionId": string; "modelDeviceToken"?: string; "modelDeviceUuid"?: string; "modelEntryPoint"?: string; }, options?: any) {
        return SessionApiFp.sessionHandleGetApplePush(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param claimCode 
     */
    sessionHandleSessionGiftRedeem(params: {  "sessionId": string; "claimCode": string; }, options?: any) {
        return SessionApiFp.sessionHandleSessionGiftRedeem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param features 
     */
    sessionPostFeatures(params: {  "sessionId": string; "features": Array<FeatureRestriction>; }, options?: any) {
        return SessionApiFp.sessionPostFeatures(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param file 
     */
    sessionPostSessionUploadImage(params: {  "sessionId": string; "file": any; }, options?: any) {
        return SessionApiFp.sessionPostSessionUploadImage(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Store the session with the specified id.
     * @param sessionId Session identifier.
     * @param data Data.
     */
    sessionPut(params: {  "sessionId": string; "data": SessionModel; }, options?: any) {
        return SessionApiFp.sessionPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Puts the session user detail.
     * @param sessionId Session identifier.
     * @param model Model.
     */
    sessionPutSessionUserDetail(params: {  "sessionId": string; "model": UserModelExtended; }, options?: any) {
        return SessionApiFp.sessionPutSessionUserDetail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionPutSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any) {
        return SessionApiFp.sessionPutSessionUserEnRouteBottleRedeem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionSessionDelete(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionSessionDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionSessionSignOut(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionSessionSignOut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SessionApi - factory interface
 */
export const SessionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param qty 
         */
        sessionCartExpress(params: {  "sessionId": string; "qty": number; }, options?: any) {
            return SessionApiFp.sessionCartExpress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param qty 
         */
        sessionCartExpressPreview(params: {  "sessionId": string; "qty": number; }, options?: any) {
            return SessionApiFp.sessionCartExpressPreview(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        sessionCartGet(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionCartGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        sessionCartGetGrouped(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionCartGetGrouped(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param item 
         */
        sessionCartPut(params: {  "sessionId": string; "item": CloudCheckoutItem; }, options?: any) {
            return SessionApiFp.sessionCartPut(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param promo 
         */
        sessionClaimPromo(params: {  "sessionId": string; "promo": string; }, options?: any) {
            return SessionApiFp.sessionClaimPromo(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Generates a new session id
         */
        sessionGet(options?: any) {
            return SessionApiFp.sessionGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        sessionGetFeatures(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetFeatures(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        sessionGetSessionGiftList(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionGiftList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        sessionGetSessionUserCredit(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserCredit(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        sessionGetSessionUserCreditHistory(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserCreditHistory(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the session user detail.
         * @param sessionId Session identifier.
         */
        sessionGetSessionUserDetail(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserDetail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        sessionGetSessionUserEmailPreferences(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserEmailPreferences(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the list of en-route bottles that are overdue for the current user. You can then redeem any of these  bottles for credit by calling Routes.SessionUserEnRouteBottleRedeem
         * @param sessionId Session identifier.
         */
        sessionGetSessionUserEnRouteBottleList(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserEnRouteBottleList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param manifestGuid 
         */
        sessionGetSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserEnRouteBottleRedeem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param skip 
         * @param take 
         * @param includeCanceled 
         */
        sessionGetSessionUserOrders(params: {  "sessionId": string; "skip": number; "take": number; "includeCanceled": boolean; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserOrders(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param req 
         */
        sessionGetSupport(params: {  "sessionId": string; "req": SupportRequest; }, options?: any) {
            return SessionApiFp.sessionGetSupport(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the session with the specified id.
         * @param sessionId Session identifier.
         */
        sessionGet_1(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGet_1(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param model 
         */
        sessionHandleEnrollApplePush(params: {  "sessionId": string; "model": ApplePushEnroll; }, options?: any) {
            return SessionApiFp.sessionHandleEnrollApplePush(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param modelDeviceToken 
         * @param modelDeviceUuid 
         * @param modelEntryPoint 
         */
        sessionHandleGetApplePush(params: {  "sessionId": string; "modelDeviceToken"?: string; "modelDeviceUuid"?: string; "modelEntryPoint"?: string; }, options?: any) {
            return SessionApiFp.sessionHandleGetApplePush(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param claimCode 
         */
        sessionHandleSessionGiftRedeem(params: {  "sessionId": string; "claimCode": string; }, options?: any) {
            return SessionApiFp.sessionHandleSessionGiftRedeem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param features 
         */
        sessionPostFeatures(params: {  "sessionId": string; "features": Array<FeatureRestriction>; }, options?: any) {
            return SessionApiFp.sessionPostFeatures(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param file 
         */
        sessionPostSessionUploadImage(params: {  "sessionId": string; "file": any; }, options?: any) {
            return SessionApiFp.sessionPostSessionUploadImage(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Store the session with the specified id.
         * @param sessionId Session identifier.
         * @param data Data.
         */
        sessionPut(params: {  "sessionId": string; "data": SessionModel; }, options?: any) {
            return SessionApiFp.sessionPut(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Puts the session user detail.
         * @param sessionId Session identifier.
         * @param model Model.
         */
        sessionPutSessionUserDetail(params: {  "sessionId": string; "model": UserModelExtended; }, options?: any) {
            return SessionApiFp.sessionPutSessionUserDetail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param manifestGuid 
         */
        sessionPutSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any) {
            return SessionApiFp.sessionPutSessionUserEnRouteBottleRedeem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the session with the specified id, along with any other sessions which have expired.
         * @param sessionId Session identifier.
         */
        sessionSessionDelete(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionSessionDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the session with the specified id, along with any other sessions which have expired.
         * @param sessionId Session identifier.
         */
        sessionSessionSignOut(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionSessionSignOut(params, options)(fetch, basePath);
        },
    };
};


/**
 * ShipManagerApi - fetch parameter creator
 */
export const ShipManagerApiFetchParamCreator = {
    /**
     * 
     * @param id 
     * @param trackingNumber 
     * @param status 
     * @param force 
     */
    shipManagerAdminTrackingManualUpdateCpl(params: {  "id": string; "trackingNumber": string; "status": string; "force"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling shipManagerAdminTrackingManualUpdateCpl");
        }
        // verify required parameter "trackingNumber" is set
        if (params["trackingNumber"] == null) {
            throw new Error("Missing required parameter trackingNumber when calling shipManagerAdminTrackingManualUpdateCpl");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling shipManagerAdminTrackingManualUpdateCpl");
        }
        const baseUrl = `/api/admin/shipment/updateTrackingByCplId`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "id": params["id"],
            "trackingNumber": params["trackingNumber"],
            "status": params["status"],
            "force": params["force"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param id 
     */
    shipManagerCancelShipment(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling shipManagerCancelShipment");
        }
        const baseUrl = `/api/admin/shipment/cancel/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param isAdminHold 
     * @param willCallOnly 
     * @param startDate 
     * @param endDate 
     */
    shipManagerGet(params: {  "search": string; "skip": number; "take"?: number; "isAdminHold"?: boolean; "willCallOnly"?: boolean; "startDate"?: string; "endDate"?: string; }, options?: any): FetchArgs {
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling shipManagerGet");
        }
        // verify required parameter "skip" is set
        if (params["skip"] == null) {
            throw new Error("Missing required parameter skip when calling shipManagerGet");
        }
        const baseUrl = `/api/admin/shipment/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
            "isAdminHold": params["isAdminHold"],
            "willCallOnly": params["willCallOnly"],
            "startDate": params["startDate"],
            "endDate": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    shipManagerGetMissingShipments(options?: any): FetchArgs {
        const baseUrl = `/api/admin/shipment/updateTracking/missing`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param shipmentId 
     */
    shipManagerGetShipmentDetail(params: {  "shipmentId": string; }, options?: any): FetchArgs {
        // verify required parameter "shipmentId" is set
        if (params["shipmentId"] == null) {
            throw new Error("Missing required parameter shipmentId when calling shipManagerGetShipmentDetail");
        }
        const baseUrl = `/api/shipment/item/{shipmentId}`
            .replace(`{${"shipmentId"}}`, `${ params["shipmentId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param search 
     */
    shipManagerGetUpsEmail(params: {  "sessionId": string; "search": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling shipManagerGetUpsEmail");
        }
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling shipManagerGetUpsEmail");
        }
        const baseUrl = `/api/ups-tracking`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     */
    shipManagerPostManifestsByIdShip(params: {  "model": ShippingModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling shipManagerPostManifestsByIdShip");
        }
        const baseUrl = `/api/admin/manifests/ship`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param email 
     */
    shipManagerPostUpsEmail(params: {  "email": ParsedShipmentEmail; }, options?: any): FetchArgs {
        // verify required parameter "email" is set
        if (params["email"] == null) {
            throw new Error("Missing required parameter email when calling shipManagerPostUpsEmail");
        }
        const baseUrl = `/api/ups-tracking`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["email"]) {
            fetchOptions.body = JSON.stringify(params["email"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    shipManagerUpdateTracking(options?: any): FetchArgs {
        const baseUrl = `/api/admin/shipment/updateTracking/all`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param shipmentId 
     */
    shipManagerUpdateTrackingById(params: {  "shipmentId": string; }, options?: any): FetchArgs {
        // verify required parameter "shipmentId" is set
        if (params["shipmentId"] == null) {
            throw new Error("Missing required parameter shipmentId when calling shipManagerUpdateTrackingById");
        }
        const baseUrl = `/api/admin/shipment/updateTracking/id/{shipmentId}`
            .replace(`{${"shipmentId"}}`, `${ params["shipmentId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param id 
     * @param trackingNumber 
     * @param status 
     */
    shipManagerUpdateTrackingManually(params: {  "id": string; "trackingNumber": string; "status": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling shipManagerUpdateTrackingManually");
        }
        // verify required parameter "trackingNumber" is set
        if (params["trackingNumber"] == null) {
            throw new Error("Missing required parameter trackingNumber when calling shipManagerUpdateTrackingManually");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling shipManagerUpdateTrackingManually");
        }
        const baseUrl = `/api/admin/shipment/updateTrackingManually`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "id": params["id"],
            "trackingNumber": params["trackingNumber"],
            "status": params["status"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ShipManagerApi - functional programming interface
 */
export const ShipManagerApiFp = {
    /**
     * 
     * @param id 
     * @param trackingNumber 
     * @param status 
     * @param force 
     */
    shipManagerAdminTrackingManualUpdateCpl(params: { "id": string; "trackingNumber": string; "status": string; "force"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultShippingModel> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerAdminTrackingManualUpdateCpl(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param id 
     */
    shipManagerCancelShipment(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerCancelShipment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param isAdminHold 
     * @param willCallOnly 
     * @param startDate 
     * @param endDate 
     */
    shipManagerGet(params: { "search": string; "skip": number; "take"?: number; "isAdminHold"?: boolean; "willCallOnly"?: boolean; "startDate"?: string; "endDate"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ShippingModel>> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    shipManagerGetMissingShipments(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListShippingModel> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerGetMissingShipments(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param shipmentId 
     */
    shipManagerGetShipmentDetail(params: { "shipmentId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOrderViewModel> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerGetShipmentDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param search 
     */
    shipManagerGetUpsEmail(params: { "sessionId": string; "search": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListParsedShipmentEmail> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerGetUpsEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     */
    shipManagerPostManifestsByIdShip(params: { "model": ShippingModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShippingModel> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerPostManifestsByIdShip(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param email 
     */
    shipManagerPostUpsEmail(params: { "email": ParsedShipmentEmail;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultShippingModel> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerPostUpsEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    shipManagerUpdateTracking(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TupleStringStringString>> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerUpdateTracking(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param shipmentId 
     */
    shipManagerUpdateTrackingById(params: { "shipmentId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultShippingModel> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerUpdateTrackingById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param id 
     * @param trackingNumber 
     * @param status 
     */
    shipManagerUpdateTrackingManually(params: { "id": string; "trackingNumber": string; "status": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultShippingModel> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerUpdateTrackingManually(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ShipManagerApi - object-oriented interface
 */
export class ShipManagerApi extends BaseAPI {
    /**
     * 
     * @param id 
     * @param trackingNumber 
     * @param status 
     * @param force 
     */
    shipManagerAdminTrackingManualUpdateCpl(params: {  "id": string; "trackingNumber": string; "status": string; "force"?: boolean; }, options?: any) {
        return ShipManagerApiFp.shipManagerAdminTrackingManualUpdateCpl(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param id 
     */
    shipManagerCancelShipment(params: {  "id": string; }, options?: any) {
        return ShipManagerApiFp.shipManagerCancelShipment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param search 
     * @param skip 
     * @param take 
     * @param isAdminHold 
     * @param willCallOnly 
     * @param startDate 
     * @param endDate 
     */
    shipManagerGet(params: {  "search": string; "skip": number; "take"?: number; "isAdminHold"?: boolean; "willCallOnly"?: boolean; "startDate"?: string; "endDate"?: string; }, options?: any) {
        return ShipManagerApiFp.shipManagerGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    shipManagerGetMissingShipments(options?: any) {
        return ShipManagerApiFp.shipManagerGetMissingShipments(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param shipmentId 
     */
    shipManagerGetShipmentDetail(params: {  "shipmentId": string; }, options?: any) {
        return ShipManagerApiFp.shipManagerGetShipmentDetail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param search 
     */
    shipManagerGetUpsEmail(params: {  "sessionId": string; "search": string; }, options?: any) {
        return ShipManagerApiFp.shipManagerGetUpsEmail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     */
    shipManagerPostManifestsByIdShip(params: {  "model": ShippingModel; }, options?: any) {
        return ShipManagerApiFp.shipManagerPostManifestsByIdShip(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param email 
     */
    shipManagerPostUpsEmail(params: {  "email": ParsedShipmentEmail; }, options?: any) {
        return ShipManagerApiFp.shipManagerPostUpsEmail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    shipManagerUpdateTracking(options?: any) {
        return ShipManagerApiFp.shipManagerUpdateTracking(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param shipmentId 
     */
    shipManagerUpdateTrackingById(params: {  "shipmentId": string; }, options?: any) {
        return ShipManagerApiFp.shipManagerUpdateTrackingById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param id 
     * @param trackingNumber 
     * @param status 
     */
    shipManagerUpdateTrackingManually(params: {  "id": string; "trackingNumber": string; "status": string; }, options?: any) {
        return ShipManagerApiFp.shipManagerUpdateTrackingManually(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ShipManagerApi - factory interface
 */
export const ShipManagerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param id 
         * @param trackingNumber 
         * @param status 
         * @param force 
         */
        shipManagerAdminTrackingManualUpdateCpl(params: {  "id": string; "trackingNumber": string; "status": string; "force"?: boolean; }, options?: any) {
            return ShipManagerApiFp.shipManagerAdminTrackingManualUpdateCpl(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param id 
         */
        shipManagerCancelShipment(params: {  "id": string; }, options?: any) {
            return ShipManagerApiFp.shipManagerCancelShipment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param search 
         * @param skip 
         * @param take 
         * @param isAdminHold 
         * @param willCallOnly 
         * @param startDate 
         * @param endDate 
         */
        shipManagerGet(params: {  "search": string; "skip": number; "take"?: number; "isAdminHold"?: boolean; "willCallOnly"?: boolean; "startDate"?: string; "endDate"?: string; }, options?: any) {
            return ShipManagerApiFp.shipManagerGet(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        shipManagerGetMissingShipments(options?: any) {
            return ShipManagerApiFp.shipManagerGetMissingShipments(options)(fetch, basePath);
        },
        /**
         * 
         * @param shipmentId 
         */
        shipManagerGetShipmentDetail(params: {  "shipmentId": string; }, options?: any) {
            return ShipManagerApiFp.shipManagerGetShipmentDetail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param search 
         */
        shipManagerGetUpsEmail(params: {  "sessionId": string; "search": string; }, options?: any) {
            return ShipManagerApiFp.shipManagerGetUpsEmail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         */
        shipManagerPostManifestsByIdShip(params: {  "model": ShippingModel; }, options?: any) {
            return ShipManagerApiFp.shipManagerPostManifestsByIdShip(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param email 
         */
        shipManagerPostUpsEmail(params: {  "email": ParsedShipmentEmail; }, options?: any) {
            return ShipManagerApiFp.shipManagerPostUpsEmail(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        shipManagerUpdateTracking(options?: any) {
            return ShipManagerApiFp.shipManagerUpdateTracking(options)(fetch, basePath);
        },
        /**
         * 
         * @param shipmentId 
         */
        shipManagerUpdateTrackingById(params: {  "shipmentId": string; }, options?: any) {
            return ShipManagerApiFp.shipManagerUpdateTrackingById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param id 
         * @param trackingNumber 
         * @param status 
         */
        shipManagerUpdateTrackingManually(params: {  "id": string; "trackingNumber": string; "status": string; }, options?: any) {
            return ShipManagerApiFp.shipManagerUpdateTrackingManually(params, options)(fetch, basePath);
        },
    };
};


/**
 * SkuApi - fetch parameter creator
 */
export const SkuApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param skuId 
     * @param replacementSku 
     * @param useAllStock 
     */
    skuAddBackup(params: {  "sessionId": string; "skuId": string; "replacementSku": string; "useAllStock"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling skuAddBackup");
        }
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuAddBackup");
        }
        // verify required parameter "replacementSku" is set
        if (params["replacementSku"] == null) {
            throw new Error("Missing required parameter replacementSku when calling skuAddBackup");
        }
        const baseUrl = `/api/v3/admin/sku/byId/{skuId}/backup`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "replacementSku": params["replacementSku"],
            "useAllStock": params["useAllStock"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sku 
     * @param skuId 
     */
    skuDelete(params: {  "sku": string; "skuId": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling skuDelete");
        }
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuDelete");
        }
        const baseUrl = `/api/v2/admin/sku/byId/{skuId}`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sku": params["sku"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skuId 
     * @param replacementSku 
     */
    skuDeleteBackup(params: {  "sessionId": string; "skuId": string; "replacementSku": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling skuDeleteBackup");
        }
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuDeleteBackup");
        }
        // verify required parameter "replacementSku" is set
        if (params["replacementSku"] == null) {
            throw new Error("Missing required parameter replacementSku when calling skuDeleteBackup");
        }
        const baseUrl = `/api/v3/admin/sku/byId/{skuId}/backup`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "replacementSku": params["replacementSku"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param daysNoPurchase 
     * @param neverBought 
     * @param defected 
     */
    skuGetAbandoned(params: {  "sessionId": string; "daysNoPurchase": number; "neverBought": boolean; "defected": boolean; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling skuGetAbandoned");
        }
        // verify required parameter "daysNoPurchase" is set
        if (params["daysNoPurchase"] == null) {
            throw new Error("Missing required parameter daysNoPurchase when calling skuGetAbandoned");
        }
        // verify required parameter "neverBought" is set
        if (params["neverBought"] == null) {
            throw new Error("Missing required parameter neverBought when calling skuGetAbandoned");
        }
        // verify required parameter "defected" is set
        if (params["defected"] == null) {
            throw new Error("Missing required parameter defected when calling skuGetAbandoned");
        }
        const baseUrl = `/api/v2/admin/sku/abandoned`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "daysNoPurchase": params["daysNoPurchase"],
            "neverBought": params["neverBought"],
            "defected": params["defected"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skuId 
     */
    skuGetBackup(params: {  "sessionId": string; "skuId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling skuGetBackup");
        }
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuGetBackup");
        }
        const baseUrl = `/api/v3/admin/sku/byId/{skuId}/backup`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    skuGetDashboard(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling skuGetDashboard");
        }
        const baseUrl = `/api/v2/admin/sku/dashboard`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     * @param varietals 
     */
    skuGetInstantBuy(params: {  "skip"?: number; "take"?: number; "search"?: string; "varietals"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/instantbuy`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
            "varietals": params["varietals"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param adminSessionId 
     * @param userGuid 
     * @param qty 
     */
    skuGetPlanForUser(params: {  "adminSessionId": string; "userGuid": string; "qty": number; }, options?: any): FetchArgs {
        // verify required parameter "adminSessionId" is set
        if (params["adminSessionId"] == null) {
            throw new Error("Missing required parameter adminSessionId when calling skuGetPlanForUser");
        }
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling skuGetPlanForUser");
        }
        // verify required parameter "qty" is set
        if (params["qty"] == null) {
            throw new Error("Missing required parameter qty when calling skuGetPlanForUser");
        }
        const baseUrl = `/api/v2/admin/sku/freeLocations/forUser`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "adminSessionId": params["adminSessionId"],
            "userGuid": params["userGuid"],
            "qty": params["qty"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     * @param sort 
     * @param reverse 
     * @param minSurplus 
     * @param maxSurplus 
     * @param minPrice 
     * @param maxPrice 
     * @param varietals 
     * @param hasComment 
     * @param hideZeroes 
     * @param showDeprecated 
     * @param includePallet 
     * @param includeNonPallet 
     */
    skuGetSkuList(params: {  "skip"?: number; "take"?: number; "search"?: string; "sort"?: string; "reverse"?: boolean; "minSurplus"?: number; "maxSurplus"?: number; "minPrice"?: number; "maxPrice"?: number; "varietals"?: string; "hasComment"?: boolean; "hideZeroes"?: boolean; "showDeprecated"?: boolean; "includePallet"?: boolean; "includeNonPallet"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
            "sort": params["sort"],
            "reverse": params["reverse"],
            "minSurplus": params["minSurplus"],
            "maxSurplus": params["maxSurplus"],
            "minPrice": params["minPrice"],
            "maxPrice": params["maxPrice"],
            "varietals": params["varietals"],
            "hasComment": params["hasComment"],
            "hideZeroes": params["hideZeroes"],
            "showDeprecated": params["showDeprecated"],
            "includePallet": params["includePallet"],
            "includeNonPallet": params["includeNonPallet"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     */
    skuGetSkuListDeficit(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/deficit`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    skuGetSkuListFreeLocations(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/freeLocations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sku 
     */
    skuGetSkuStats(params: {  "sku": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling skuGetSkuStats");
        }
        const baseUrl = `/api/v2/admin/sku/stats/forSku/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    skuGetSkuStatsByVarietal(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/stats/byVarietal`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param content 
     */
    skuPost(params: {  "content": SkuEntity; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling skuPost");
        }
        const baseUrl = `/api/v2/admin/sku/create`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sku 
     */
    skuPreviewWineDirectData(params: {  "sku": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling skuPreviewWineDirectData");
        }
        const baseUrl = `/api/v2/admin/sku/wd-preview/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sku 
     * @param isTest 
     */
    skuPushSkuToWineDirect(params: {  "sku": string; "isTest": boolean; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling skuPushSkuToWineDirect");
        }
        // verify required parameter "isTest" is set
        if (params["isTest"] == null) {
            throw new Error("Missing required parameter isTest when calling skuPushSkuToWineDirect");
        }
        const baseUrl = `/api/v2/admin/sku/wd-push/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "isTest": params["isTest"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param skuId 
     * @param content 
     * @param updateCogsHistorically 
     */
    skuPut(params: {  "skuId": string; "content": SkuEntity; "updateCogsHistorically"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuPut");
        }
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling skuPut");
        }
        const baseUrl = `/api/v2/admin/sku/byId/{skuId}`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "updateCogsHistorically": params["updateCogsHistorically"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param items 
     */
    skuReclaimForCredit(params: {  "sessionId": string; "items": Array<NhAbandonedBottle>; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling skuReclaimForCredit");
        }
        // verify required parameter "items" is set
        if (params["items"] == null) {
            throw new Error("Missing required parameter items when calling skuReclaimForCredit");
        }
        const baseUrl = `/api/v2/admin/sku/abandoned`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["items"]) {
            fetchOptions.body = JSON.stringify(params["items"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param skuId 
     * @param allowCache 
     */
    skuSkuDetailV3(params: {  "skuId": string; "allowCache": boolean; }, options?: any): FetchArgs {
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuSkuDetailV3");
        }
        // verify required parameter "allowCache" is set
        if (params["allowCache"] == null) {
            throw new Error("Missing required parameter allowCache when calling skuSkuDetailV3");
        }
        const baseUrl = `/api/v3/admin/sku/byId/{skuId}`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "allowCache": params["allowCache"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param itemDetailSef 
     */
    skuSkuListByItemDetail(params: {  "itemDetailSef": string; }, options?: any): FetchArgs {
        // verify required parameter "itemDetailSef" is set
        if (params["itemDetailSef"] == null) {
            throw new Error("Missing required parameter itemDetailSef when calling skuSkuListByItemDetail");
        }
        const baseUrl = `/api/v2/sku/byItemDetail/{itemDetailSef}`
            .replace(`{${"itemDetailSef"}}`, `${ params["itemDetailSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    skuSkuSwapGet(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/swap`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    skuSkuSwapPost(params: {  "sessionId": string; "model": SkuSwapModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling skuSkuSwapPost");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling skuSkuSwapPost");
        }
        const baseUrl = `/api/v2/admin/sku/swap`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    skuSkuSwapPut(params: {  "sessionId": string; "model": SkuSwapModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling skuSkuSwapPut");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling skuSkuSwapPut");
        }
        const baseUrl = `/api/v2/admin/sku/swap`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param skuId 
     */
    skuSkuV3GetOffers(params: {  "skuId": string; }, options?: any): FetchArgs {
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuSkuV3GetOffers");
        }
        const baseUrl = `/api/v3/sku/byId/{skuId}/offers`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SkuApi - functional programming interface
 */
export const SkuApiFp = {
    /**
     * 
     * @param sessionId 
     * @param skuId 
     * @param replacementSku 
     * @param useAllStock 
     */
    skuAddBackup(params: { "sessionId": string; "skuId": string; "replacementSku": string; "useAllStock"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuBackup> {
        const fetchArgs = SkuApiFetchParamCreator.skuAddBackup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sku 
     * @param skuId 
     */
    skuDelete(params: { "sku": string; "skuId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SkuApiFetchParamCreator.skuDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skuId 
     * @param replacementSku 
     */
    skuDeleteBackup(params: { "sessionId": string; "skuId": string; "replacementSku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListSkuBackup> {
        const fetchArgs = SkuApiFetchParamCreator.skuDeleteBackup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param daysNoPurchase 
     * @param neverBought 
     * @param defected 
     */
    skuGetAbandoned(params: { "sessionId": string; "daysNoPurchase": number; "neverBought": boolean; "defected": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhAbandonedBottle> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetAbandoned(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skuId 
     */
    skuGetBackup(params: { "sessionId": string; "skuId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListSkuBackup> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetBackup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    skuGetDashboard(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuDashboard> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetDashboard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     * @param varietals 
     */
    skuGetInstantBuy(params: { "skip"?: number; "take"?: number; "search"?: string; "varietals"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttributedItemList> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetInstantBuy(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param adminSessionId 
     * @param userGuid 
     * @param qty 
     */
    skuGetPlanForUser(params: { "adminSessionId": string; "userGuid": string; "qty": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCloudCheckoutItem> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetPlanForUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     * @param sort 
     * @param reverse 
     * @param minSurplus 
     * @param maxSurplus 
     * @param minPrice 
     * @param maxPrice 
     * @param varietals 
     * @param hasComment 
     * @param hideZeroes 
     * @param showDeprecated 
     * @param includePallet 
     * @param includeNonPallet 
     */
    skuGetSkuList(params: { "skip"?: number; "take"?: number; "search"?: string; "sort"?: string; "reverse"?: boolean; "minSurplus"?: number; "maxSurplus"?: number; "minPrice"?: number; "maxPrice"?: number; "varietals"?: string; "hasComment"?: boolean; "hideZeroes"?: boolean; "showDeprecated"?: boolean; "includePallet"?: boolean; "includeNonPallet"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListSkuEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     */
    skuGetSkuListDeficit(params: { "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListSkuEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuListDeficit(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    skuGetSkuListFreeLocations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OverallPlan> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuListFreeLocations(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sku 
     */
    skuGetSkuStats(params: { "sku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SurplusItemDateTime>> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuStats(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    skuGetSkuStatsByVarietal(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SurplusItemString>> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuStatsByVarietal(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param content 
     */
    skuPost(params: { "content": SkuEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sku 
     */
    skuPreviewWineDirectData(params: { "sku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultTupleWineProductDataNonWineProductData> {
        const fetchArgs = SkuApiFetchParamCreator.skuPreviewWineDirectData(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sku 
     * @param isTest 
     */
    skuPushSkuToWineDirect(params: { "sku": string; "isTest": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuPushSkuToWineDirect(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param skuId 
     * @param content 
     * @param updateCogsHistorically 
     */
    skuPut(params: { "skuId": string; "content": SkuEntity; "updateCogsHistorically"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param items 
     */
    skuReclaimForCredit(params: { "sessionId": string; "items": Array<NhAbandonedBottle>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhCreditModel> {
        const fetchArgs = SkuApiFetchParamCreator.skuReclaimForCredit(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param skuId 
     * @param allowCache 
     */
    skuSkuDetailV3(params: { "skuId": string; "allowCache": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuDetailV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param itemDetailSef 
     */
    skuSkuListByItemDetail(params: { "itemDetailSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkuEntity>> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuListByItemDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    skuSkuSwapGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuSwapModel> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuSwapGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    skuSkuSwapPost(params: { "sessionId": string; "model": SkuSwapModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuSwapModel> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuSwapPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    skuSkuSwapPut(params: { "sessionId": string; "model": SkuSwapModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuSwapModel> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuSwapPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param skuId 
     */
    skuSkuV3GetOffers(params: { "skuId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListOfferV2Entity> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuV3GetOffers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SkuApi - object-oriented interface
 */
export class SkuApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param skuId 
     * @param replacementSku 
     * @param useAllStock 
     */
    skuAddBackup(params: {  "sessionId": string; "skuId": string; "replacementSku": string; "useAllStock"?: boolean; }, options?: any) {
        return SkuApiFp.skuAddBackup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sku 
     * @param skuId 
     */
    skuDelete(params: {  "sku": string; "skuId": string; }, options?: any) {
        return SkuApiFp.skuDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param skuId 
     * @param replacementSku 
     */
    skuDeleteBackup(params: {  "sessionId": string; "skuId": string; "replacementSku": string; }, options?: any) {
        return SkuApiFp.skuDeleteBackup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param daysNoPurchase 
     * @param neverBought 
     * @param defected 
     */
    skuGetAbandoned(params: {  "sessionId": string; "daysNoPurchase": number; "neverBought": boolean; "defected": boolean; }, options?: any) {
        return SkuApiFp.skuGetAbandoned(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param skuId 
     */
    skuGetBackup(params: {  "sessionId": string; "skuId": string; }, options?: any) {
        return SkuApiFp.skuGetBackup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    skuGetDashboard(params: {  "sessionId": string; }, options?: any) {
        return SkuApiFp.skuGetDashboard(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     * @param varietals 
     */
    skuGetInstantBuy(params: {  "skip"?: number; "take"?: number; "search"?: string; "varietals"?: string; }, options?: any) {
        return SkuApiFp.skuGetInstantBuy(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param adminSessionId 
     * @param userGuid 
     * @param qty 
     */
    skuGetPlanForUser(params: {  "adminSessionId": string; "userGuid": string; "qty": number; }, options?: any) {
        return SkuApiFp.skuGetPlanForUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     * @param sort 
     * @param reverse 
     * @param minSurplus 
     * @param maxSurplus 
     * @param minPrice 
     * @param maxPrice 
     * @param varietals 
     * @param hasComment 
     * @param hideZeroes 
     * @param showDeprecated 
     * @param includePallet 
     * @param includeNonPallet 
     */
    skuGetSkuList(params: {  "skip"?: number; "take"?: number; "search"?: string; "sort"?: string; "reverse"?: boolean; "minSurplus"?: number; "maxSurplus"?: number; "minPrice"?: number; "maxPrice"?: number; "varietals"?: string; "hasComment"?: boolean; "hideZeroes"?: boolean; "showDeprecated"?: boolean; "includePallet"?: boolean; "includeNonPallet"?: boolean; }, options?: any) {
        return SkuApiFp.skuGetSkuList(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param skip 
     * @param take 
     * @param search 
     */
    skuGetSkuListDeficit(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return SkuApiFp.skuGetSkuListDeficit(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    skuGetSkuListFreeLocations(options?: any) {
        return SkuApiFp.skuGetSkuListFreeLocations(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sku 
     */
    skuGetSkuStats(params: {  "sku": string; }, options?: any) {
        return SkuApiFp.skuGetSkuStats(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    skuGetSkuStatsByVarietal(options?: any) {
        return SkuApiFp.skuGetSkuStatsByVarietal(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param content 
     */
    skuPost(params: {  "content": SkuEntity; }, options?: any) {
        return SkuApiFp.skuPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sku 
     */
    skuPreviewWineDirectData(params: {  "sku": string; }, options?: any) {
        return SkuApiFp.skuPreviewWineDirectData(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sku 
     * @param isTest 
     */
    skuPushSkuToWineDirect(params: {  "sku": string; "isTest": boolean; }, options?: any) {
        return SkuApiFp.skuPushSkuToWineDirect(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param skuId 
     * @param content 
     * @param updateCogsHistorically 
     */
    skuPut(params: {  "skuId": string; "content": SkuEntity; "updateCogsHistorically"?: boolean; }, options?: any) {
        return SkuApiFp.skuPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param items 
     */
    skuReclaimForCredit(params: {  "sessionId": string; "items": Array<NhAbandonedBottle>; }, options?: any) {
        return SkuApiFp.skuReclaimForCredit(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param skuId 
     * @param allowCache 
     */
    skuSkuDetailV3(params: {  "skuId": string; "allowCache": boolean; }, options?: any) {
        return SkuApiFp.skuSkuDetailV3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param itemDetailSef 
     */
    skuSkuListByItemDetail(params: {  "itemDetailSef": string; }, options?: any) {
        return SkuApiFp.skuSkuListByItemDetail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    skuSkuSwapGet(options?: any) {
        return SkuApiFp.skuSkuSwapGet(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    skuSkuSwapPost(params: {  "sessionId": string; "model": SkuSwapModel; }, options?: any) {
        return SkuApiFp.skuSkuSwapPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param model 
     */
    skuSkuSwapPut(params: {  "sessionId": string; "model": SkuSwapModel; }, options?: any) {
        return SkuApiFp.skuSkuSwapPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param skuId 
     */
    skuSkuV3GetOffers(params: {  "skuId": string; }, options?: any) {
        return SkuApiFp.skuSkuV3GetOffers(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SkuApi - factory interface
 */
export const SkuApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param skuId 
         * @param replacementSku 
         * @param useAllStock 
         */
        skuAddBackup(params: {  "sessionId": string; "skuId": string; "replacementSku": string; "useAllStock"?: boolean; }, options?: any) {
            return SkuApiFp.skuAddBackup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sku 
         * @param skuId 
         */
        skuDelete(params: {  "sku": string; "skuId": string; }, options?: any) {
            return SkuApiFp.skuDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param skuId 
         * @param replacementSku 
         */
        skuDeleteBackup(params: {  "sessionId": string; "skuId": string; "replacementSku": string; }, options?: any) {
            return SkuApiFp.skuDeleteBackup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param daysNoPurchase 
         * @param neverBought 
         * @param defected 
         */
        skuGetAbandoned(params: {  "sessionId": string; "daysNoPurchase": number; "neverBought": boolean; "defected": boolean; }, options?: any) {
            return SkuApiFp.skuGetAbandoned(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param skuId 
         */
        skuGetBackup(params: {  "sessionId": string; "skuId": string; }, options?: any) {
            return SkuApiFp.skuGetBackup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        skuGetDashboard(params: {  "sessionId": string; }, options?: any) {
            return SkuApiFp.skuGetDashboard(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param skip 
         * @param take 
         * @param search 
         * @param varietals 
         */
        skuGetInstantBuy(params: {  "skip"?: number; "take"?: number; "search"?: string; "varietals"?: string; }, options?: any) {
            return SkuApiFp.skuGetInstantBuy(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param adminSessionId 
         * @param userGuid 
         * @param qty 
         */
        skuGetPlanForUser(params: {  "adminSessionId": string; "userGuid": string; "qty": number; }, options?: any) {
            return SkuApiFp.skuGetPlanForUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param skip 
         * @param take 
         * @param search 
         * @param sort 
         * @param reverse 
         * @param minSurplus 
         * @param maxSurplus 
         * @param minPrice 
         * @param maxPrice 
         * @param varietals 
         * @param hasComment 
         * @param hideZeroes 
         * @param showDeprecated 
         * @param includePallet 
         * @param includeNonPallet 
         */
        skuGetSkuList(params: {  "skip"?: number; "take"?: number; "search"?: string; "sort"?: string; "reverse"?: boolean; "minSurplus"?: number; "maxSurplus"?: number; "minPrice"?: number; "maxPrice"?: number; "varietals"?: string; "hasComment"?: boolean; "hideZeroes"?: boolean; "showDeprecated"?: boolean; "includePallet"?: boolean; "includeNonPallet"?: boolean; }, options?: any) {
            return SkuApiFp.skuGetSkuList(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param skip 
         * @param take 
         * @param search 
         */
        skuGetSkuListDeficit(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return SkuApiFp.skuGetSkuListDeficit(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        skuGetSkuListFreeLocations(options?: any) {
            return SkuApiFp.skuGetSkuListFreeLocations(options)(fetch, basePath);
        },
        /**
         * 
         * @param sku 
         */
        skuGetSkuStats(params: {  "sku": string; }, options?: any) {
            return SkuApiFp.skuGetSkuStats(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        skuGetSkuStatsByVarietal(options?: any) {
            return SkuApiFp.skuGetSkuStatsByVarietal(options)(fetch, basePath);
        },
        /**
         * 
         * @param content 
         */
        skuPost(params: {  "content": SkuEntity; }, options?: any) {
            return SkuApiFp.skuPost(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sku 
         */
        skuPreviewWineDirectData(params: {  "sku": string; }, options?: any) {
            return SkuApiFp.skuPreviewWineDirectData(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sku 
         * @param isTest 
         */
        skuPushSkuToWineDirect(params: {  "sku": string; "isTest": boolean; }, options?: any) {
            return SkuApiFp.skuPushSkuToWineDirect(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param skuId 
         * @param content 
         * @param updateCogsHistorically 
         */
        skuPut(params: {  "skuId": string; "content": SkuEntity; "updateCogsHistorically"?: boolean; }, options?: any) {
            return SkuApiFp.skuPut(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param items 
         */
        skuReclaimForCredit(params: {  "sessionId": string; "items": Array<NhAbandonedBottle>; }, options?: any) {
            return SkuApiFp.skuReclaimForCredit(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param skuId 
         * @param allowCache 
         */
        skuSkuDetailV3(params: {  "skuId": string; "allowCache": boolean; }, options?: any) {
            return SkuApiFp.skuSkuDetailV3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param itemDetailSef 
         */
        skuSkuListByItemDetail(params: {  "itemDetailSef": string; }, options?: any) {
            return SkuApiFp.skuSkuListByItemDetail(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        skuSkuSwapGet(options?: any) {
            return SkuApiFp.skuSkuSwapGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param model 
         */
        skuSkuSwapPost(params: {  "sessionId": string; "model": SkuSwapModel; }, options?: any) {
            return SkuApiFp.skuSkuSwapPost(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param model 
         */
        skuSkuSwapPut(params: {  "sessionId": string; "model": SkuSwapModel; }, options?: any) {
            return SkuApiFp.skuSkuSwapPut(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param skuId 
         */
        skuSkuV3GetOffers(params: {  "skuId": string; }, options?: any) {
            return SkuApiFp.skuSkuV3GetOffers(params, options)(fetch, basePath);
        },
    };
};


/**
 * TelegramBotApi - fetch parameter creator
 */
export const TelegramBotApiFetchParamCreator = {
    /**
     * 
     * @param update 
     */
    telegramBotPost(params: {  "update": Update; }, options?: any): FetchArgs {
        // verify required parameter "update" is set
        if (params["update"] == null) {
            throw new Error("Missing required parameter update when calling telegramBotPost");
        }
        const baseUrl = `/api/telegram`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["update"]) {
            fetchOptions.body = JSON.stringify(params["update"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TelegramBotApi - functional programming interface
 */
export const TelegramBotApiFp = {
    /**
     * 
     * @param update 
     */
    telegramBotPost(params: { "update": Update;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TelegramBotApiFetchParamCreator.telegramBotPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TelegramBotApi - object-oriented interface
 */
export class TelegramBotApi extends BaseAPI {
    /**
     * 
     * @param update 
     */
    telegramBotPost(params: {  "update": Update; }, options?: any) {
        return TelegramBotApiFp.telegramBotPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TelegramBotApi - factory interface
 */
export const TelegramBotApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param update 
         */
        telegramBotPost(params: {  "update": Update; }, options?: any) {
            return TelegramBotApiFp.telegramBotPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * TimeSeriesApi - fetch parameter creator
 */
export const TimeSeriesApiFetchParamCreator = {
    /**
     * 
     * @param start 
     * @param end 
     * @param includeTestUsers 
     * @param utm 
     */
    timeSeriesBeginGenerateSeries(params: {  "start": Date; "end": Date; "includeTestUsers": boolean; "utm": string; }, options?: any): FetchArgs {
        // verify required parameter "start" is set
        if (params["start"] == null) {
            throw new Error("Missing required parameter start when calling timeSeriesBeginGenerateSeries");
        }
        // verify required parameter "end" is set
        if (params["end"] == null) {
            throw new Error("Missing required parameter end when calling timeSeriesBeginGenerateSeries");
        }
        // verify required parameter "includeTestUsers" is set
        if (params["includeTestUsers"] == null) {
            throw new Error("Missing required parameter includeTestUsers when calling timeSeriesBeginGenerateSeries");
        }
        // verify required parameter "utm" is set
        if (params["utm"] == null) {
            throw new Error("Missing required parameter utm when calling timeSeriesBeginGenerateSeries");
        }
        const baseUrl = `/api/report/timeseries/build`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start": params["start"],
            "end": params["end"],
            "includeTestUsers": params["includeTestUsers"],
            "utm": params["utm"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    timeSeriesGetList(options?: any): FetchArgs {
        const baseUrl = `/api/report/timeseries/list`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param entityGuid 
     */
    timeSeriesGetSeries(params: {  "entityGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "entityGuid" is set
        if (params["entityGuid"] == null) {
            throw new Error("Missing required parameter entityGuid when calling timeSeriesGetSeries");
        }
        const baseUrl = `/api/report/timeseries/view/{entityGuid}`
            .replace(`{${"entityGuid"}}`, `${ params["entityGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param entityGuid 
     */
    timeSeriesGetSeriesRecords(params: {  "entityGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "entityGuid" is set
        if (params["entityGuid"] == null) {
            throw new Error("Missing required parameter entityGuid when calling timeSeriesGetSeriesRecords");
        }
        const baseUrl = `/api/report/timeseries/view/{entityGuid}/records`
            .replace(`{${"entityGuid"}}`, `${ params["entityGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TimeSeriesApi - functional programming interface
 */
export const TimeSeriesApiFp = {
    /**
     * 
     * @param start 
     * @param end 
     * @param includeTestUsers 
     * @param utm 
     */
    timeSeriesBeginGenerateSeries(params: { "start": Date; "end": Date; "includeTestUsers": boolean; "utm": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TimeSeriesReport> {
        const fetchArgs = TimeSeriesApiFetchParamCreator.timeSeriesBeginGenerateSeries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    timeSeriesGetList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TimeSeriesApiFetchParamCreator.timeSeriesGetList(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param entityGuid 
     */
    timeSeriesGetSeries(params: { "entityGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TimeSeriesApiFetchParamCreator.timeSeriesGetSeries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param entityGuid 
     */
    timeSeriesGetSeriesRecords(params: { "entityGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TimeSeriesApiFetchParamCreator.timeSeriesGetSeriesRecords(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TimeSeriesApi - object-oriented interface
 */
export class TimeSeriesApi extends BaseAPI {
    /**
     * 
     * @param start 
     * @param end 
     * @param includeTestUsers 
     * @param utm 
     */
    timeSeriesBeginGenerateSeries(params: {  "start": Date; "end": Date; "includeTestUsers": boolean; "utm": string; }, options?: any) {
        return TimeSeriesApiFp.timeSeriesBeginGenerateSeries(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    timeSeriesGetList(options?: any) {
        return TimeSeriesApiFp.timeSeriesGetList(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param entityGuid 
     */
    timeSeriesGetSeries(params: {  "entityGuid": string; }, options?: any) {
        return TimeSeriesApiFp.timeSeriesGetSeries(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param entityGuid 
     */
    timeSeriesGetSeriesRecords(params: {  "entityGuid": string; }, options?: any) {
        return TimeSeriesApiFp.timeSeriesGetSeriesRecords(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TimeSeriesApi - factory interface
 */
export const TimeSeriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param start 
         * @param end 
         * @param includeTestUsers 
         * @param utm 
         */
        timeSeriesBeginGenerateSeries(params: {  "start": Date; "end": Date; "includeTestUsers": boolean; "utm": string; }, options?: any) {
            return TimeSeriesApiFp.timeSeriesBeginGenerateSeries(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        timeSeriesGetList(options?: any) {
            return TimeSeriesApiFp.timeSeriesGetList(options)(fetch, basePath);
        },
        /**
         * 
         * @param entityGuid 
         */
        timeSeriesGetSeries(params: {  "entityGuid": string; }, options?: any) {
            return TimeSeriesApiFp.timeSeriesGetSeries(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param entityGuid 
         */
        timeSeriesGetSeriesRecords(params: {  "entityGuid": string; }, options?: any) {
            return TimeSeriesApiFp.timeSeriesGetSeriesRecords(params, options)(fetch, basePath);
        },
    };
};


/**
 * TransferApi - fetch parameter creator
 */
export const TransferApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     * @param xiGuid 
     */
    transferGetLinkEligibleReceipts(params: {  "sessionId": string; "xiGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling transferGetLinkEligibleReceipts");
        }
        // verify required parameter "xiGuid" is set
        if (params["xiGuid"] == null) {
            throw new Error("Missing required parameter xiGuid when calling transferGetLinkEligibleReceipts");
        }
        const baseUrl = `/api/admin/transferItem/unlinked/{xiGuid}`
            .replace(`{${"xiGuid"}}`, `${ params["xiGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    transferListTransfer(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling transferListTransfer");
        }
        const baseUrl = `/api/admin/transfer/collection`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param xferGuid 
     * @param model 
     */
    transferSaveOrUpdateTransferItem(params: {  "sessionId": string; "xferGuid": string; "model": NhTransferItem; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling transferSaveOrUpdateTransferItem");
        }
        // verify required parameter "xferGuid" is set
        if (params["xferGuid"] == null) {
            throw new Error("Missing required parameter xferGuid when calling transferSaveOrUpdateTransferItem");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling transferSaveOrUpdateTransferItem");
        }
        const baseUrl = `/api/admin/transfer/detail/{xferGuid}`
            .replace(`{${"xferGuid"}}`, `${ params["xferGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param record 
     */
    transferSaveTransferIgnoringLinks(params: {  "sessionId": string; "record": NhTransfer; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling transferSaveTransferIgnoringLinks");
        }
        // verify required parameter "record" is set
        if (params["record"] == null) {
            throw new Error("Missing required parameter record when calling transferSaveTransferIgnoringLinks");
        }
        const baseUrl = `/api/admin/transfer/collection`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["record"]) {
            fetchOptions.body = JSON.stringify(params["record"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param transferXiGuid 
     * @param skuHistoryGuid 
     */
    transferSetReceiptLink(params: {  "sessionId": string; "transferXiGuid": string; "skuHistoryGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling transferSetReceiptLink");
        }
        // verify required parameter "transferXiGuid" is set
        if (params["transferXiGuid"] == null) {
            throw new Error("Missing required parameter transferXiGuid when calling transferSetReceiptLink");
        }
        // verify required parameter "skuHistoryGuid" is set
        if (params["skuHistoryGuid"] == null) {
            throw new Error("Missing required parameter skuHistoryGuid when calling transferSetReceiptLink");
        }
        const baseUrl = `/api/admin/transfer/linkHistory`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "transferXiGuid": params["transferXiGuid"],
            "skuHistoryGuid": params["skuHistoryGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TransferApi - functional programming interface
 */
export const TransferApiFp = {
    /**
     * 
     * @param sessionId 
     * @param xiGuid 
     */
    transferGetLinkEligibleReceipts(params: { "sessionId": string; "xiGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListSkuHistory> {
        const fetchArgs = TransferApiFetchParamCreator.transferGetLinkEligibleReceipts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    transferListTransfer(params: { "sessionId": string; "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhTransfer> {
        const fetchArgs = TransferApiFetchParamCreator.transferListTransfer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param xferGuid 
     * @param model 
     */
    transferSaveOrUpdateTransferItem(params: { "sessionId": string; "xferGuid": string; "model": NhTransferItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhTransferItem> {
        const fetchArgs = TransferApiFetchParamCreator.transferSaveOrUpdateTransferItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param record 
     */
    transferSaveTransferIgnoringLinks(params: { "sessionId": string; "record": NhTransfer;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhTransfer> {
        const fetchArgs = TransferApiFetchParamCreator.transferSaveTransferIgnoringLinks(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param transferXiGuid 
     * @param skuHistoryGuid 
     */
    transferSetReceiptLink(params: { "sessionId": string; "transferXiGuid": string; "skuHistoryGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSkuHistory> {
        const fetchArgs = TransferApiFetchParamCreator.transferSetReceiptLink(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TransferApi - object-oriented interface
 */
export class TransferApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     * @param xiGuid 
     */
    transferGetLinkEligibleReceipts(params: {  "sessionId": string; "xiGuid": string; }, options?: any) {
        return TransferApiFp.transferGetLinkEligibleReceipts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     */
    transferListTransfer(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return TransferApiFp.transferListTransfer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param xferGuid 
     * @param model 
     */
    transferSaveOrUpdateTransferItem(params: {  "sessionId": string; "xferGuid": string; "model": NhTransferItem; }, options?: any) {
        return TransferApiFp.transferSaveOrUpdateTransferItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param record 
     */
    transferSaveTransferIgnoringLinks(params: {  "sessionId": string; "record": NhTransfer; }, options?: any) {
        return TransferApiFp.transferSaveTransferIgnoringLinks(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param transferXiGuid 
     * @param skuHistoryGuid 
     */
    transferSetReceiptLink(params: {  "sessionId": string; "transferXiGuid": string; "skuHistoryGuid": string; }, options?: any) {
        return TransferApiFp.transferSetReceiptLink(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TransferApi - factory interface
 */
export const TransferApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         * @param xiGuid 
         */
        transferGetLinkEligibleReceipts(params: {  "sessionId": string; "xiGuid": string; }, options?: any) {
            return TransferApiFp.transferGetLinkEligibleReceipts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param skip 
         * @param take 
         * @param search 
         */
        transferListTransfer(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return TransferApiFp.transferListTransfer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param xferGuid 
         * @param model 
         */
        transferSaveOrUpdateTransferItem(params: {  "sessionId": string; "xferGuid": string; "model": NhTransferItem; }, options?: any) {
            return TransferApiFp.transferSaveOrUpdateTransferItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param record 
         */
        transferSaveTransferIgnoringLinks(params: {  "sessionId": string; "record": NhTransfer; }, options?: any) {
            return TransferApiFp.transferSaveTransferIgnoringLinks(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param transferXiGuid 
         * @param skuHistoryGuid 
         */
        transferSetReceiptLink(params: {  "sessionId": string; "transferXiGuid": string; "skuHistoryGuid": string; }, options?: any) {
            return TransferApiFp.transferSetReceiptLink(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * 
     * @param sessionId 
     */
    userCanClaimFreeLetter(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userCanClaimFreeLetter");
        }
        const baseUrl = `/api/session/{sessionId}/freeletter`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param email 
     */
    userCaptureEmail(params: {  "sessionId": string; "email": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userCaptureEmail");
        }
        // verify required parameter "email" is set
        if (params["email"] == null) {
            throw new Error("Missing required parameter email when calling userCaptureEmail");
        }
        const baseUrl = `/api/user/captureDotmailerEmail`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["email"]) {
            fetchOptions.body = JSON.stringify(params["email"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Change the password for the current user (based on sessionId)
     * @param sessionId 
     * @param input 
     */
    userChangePassword(params: {  "sessionId": string; "input": PasswordChangeModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userChangePassword");
        }
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling userChangePassword");
        }
        const baseUrl = `/api/session/{sessionId}/user-passwd`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Change the password for the given user (based on userGuid); restricted to Admin only.
     * @param userGuid 
     * @param input 
     * @param sessionId 
     */
    userChangePasswordAdmin(params: {  "userGuid": string; "input": PasswordResetAdminModel; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userChangePasswordAdmin");
        }
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling userChangePasswordAdmin");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userChangePasswordAdmin");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/setPassword`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userClaimFreeLetter(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userClaimFreeLetter");
        }
        const baseUrl = `/api/session/{sessionId}/freeletter`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     */
    userHttpUserCaptureEmail(params: {  "model": EmailCapture; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userHttpUserCaptureEmail");
        }
        const baseUrl = `/api/user/captureEmail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Initiate a password reset operation.
     * @param input 
     */
    userResetPassword(params: {  "input": PasswordResetModel; }, options?: any): FetchArgs {
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling userResetPassword");
        }
        const baseUrl = `/api/resetpassword`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param model 
     */
    userSetEmailPreferences(params: {  "userGuid": string; "model": NhUserEmailPreference; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userSetEmailPreferences");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSetEmailPreferences");
        }
        const baseUrl = `/api/v2/user/{userGuid}/email`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     */
    userSignIn(params: {  "model": UserAuthModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSignIn");
        }
        const baseUrl = `/api/user/auth`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     */
    userSignIn3(params: {  "model": UserAuthModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSignIn3");
        }
        const baseUrl = `/api/v3/user/auth`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     */
    userSignup(params: {  "model": UserAuthModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSignup");
        }
        const baseUrl = `/api/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     */
    userSignup3(params: {  "model": UserAuthModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSignup3");
        }
        const baseUrl = `/api/v3/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * 
     * @param sessionId 
     */
    userCanClaimFreeLetter(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = UserApiFetchParamCreator.userCanClaimFreeLetter(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param email 
     */
    userCaptureEmail(params: { "sessionId": string; "email": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
        const fetchArgs = UserApiFetchParamCreator.userCaptureEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Change the password for the current user (based on sessionId)
     * @param sessionId 
     * @param input 
     */
    userChangePassword(params: { "sessionId": string; "input": PasswordChangeModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPasswordChangeModel> {
        const fetchArgs = UserApiFetchParamCreator.userChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Change the password for the given user (based on userGuid); restricted to Admin only.
     * @param userGuid 
     * @param input 
     * @param sessionId 
     */
    userChangePasswordAdmin(params: { "userGuid": string; "input": PasswordResetAdminModel; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
        const fetchArgs = UserApiFetchParamCreator.userChangePasswordAdmin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userClaimFreeLetter(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
        const fetchArgs = UserApiFetchParamCreator.userClaimFreeLetter(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     */
    userHttpUserCaptureEmail(params: { "model": EmailCapture;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCapture> {
        const fetchArgs = UserApiFetchParamCreator.userHttpUserCaptureEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Initiate a password reset operation.
     * @param input 
     */
    userResetPassword(params: { "input": PasswordResetModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
        const fetchArgs = UserApiFetchParamCreator.userResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param model 
     */
    userSetEmailPreferences(params: { "userGuid": string; "model": NhUserEmailPreference;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhUserEmailPreference> {
        const fetchArgs = UserApiFetchParamCreator.userSetEmailPreferences(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     */
    userSignIn(params: { "model": UserAuthModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAuthResultModel> {
        const fetchArgs = UserApiFetchParamCreator.userSignIn(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     */
    userSignIn3(params: { "model": UserAuthModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultUserAuthResultModel> {
        const fetchArgs = UserApiFetchParamCreator.userSignIn3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     */
    userSignup(params: { "model": UserAuthModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAuthResultModel> {
        const fetchArgs = UserApiFetchParamCreator.userSignup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     */
    userSignup3(params: { "model": UserAuthModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultUserAuthResultModel> {
        const fetchArgs = UserApiFetchParamCreator.userSignup3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param sessionId 
     */
    userCanClaimFreeLetter(params: {  "sessionId": string; }, options?: any) {
        return UserApiFp.userCanClaimFreeLetter(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param email 
     */
    userCaptureEmail(params: {  "sessionId": string; "email": string; }, options?: any) {
        return UserApiFp.userCaptureEmail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Change the password for the current user (based on sessionId)
     * @param sessionId 
     * @param input 
     */
    userChangePassword(params: {  "sessionId": string; "input": PasswordChangeModel; }, options?: any) {
        return UserApiFp.userChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Change the password for the given user (based on userGuid); restricted to Admin only.
     * @param userGuid 
     * @param input 
     * @param sessionId 
     */
    userChangePasswordAdmin(params: {  "userGuid": string; "input": PasswordResetAdminModel; "sessionId": string; }, options?: any) {
        return UserApiFp.userChangePasswordAdmin(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    userClaimFreeLetter(params: {  "sessionId": string; }, options?: any) {
        return UserApiFp.userClaimFreeLetter(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     */
    userHttpUserCaptureEmail(params: {  "model": EmailCapture; }, options?: any) {
        return UserApiFp.userHttpUserCaptureEmail(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Initiate a password reset operation.
     * @param input 
     */
    userResetPassword(params: {  "input": PasswordResetModel; }, options?: any) {
        return UserApiFp.userResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param model 
     */
    userSetEmailPreferences(params: {  "userGuid": string; "model": NhUserEmailPreference; }, options?: any) {
        return UserApiFp.userSetEmailPreferences(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     */
    userSignIn(params: {  "model": UserAuthModel; }, options?: any) {
        return UserApiFp.userSignIn(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     */
    userSignIn3(params: {  "model": UserAuthModel; }, options?: any) {
        return UserApiFp.userSignIn3(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     */
    userSignup(params: {  "model": UserAuthModel; }, options?: any) {
        return UserApiFp.userSignup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     */
    userSignup3(params: {  "model": UserAuthModel; }, options?: any) {
        return UserApiFp.userSignup3(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param sessionId 
         */
        userCanClaimFreeLetter(params: {  "sessionId": string; }, options?: any) {
            return UserApiFp.userCanClaimFreeLetter(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param email 
         */
        userCaptureEmail(params: {  "sessionId": string; "email": string; }, options?: any) {
            return UserApiFp.userCaptureEmail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change the password for the current user (based on sessionId)
         * @param sessionId 
         * @param input 
         */
        userChangePassword(params: {  "sessionId": string; "input": PasswordChangeModel; }, options?: any) {
            return UserApiFp.userChangePassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change the password for the given user (based on userGuid); restricted to Admin only.
         * @param userGuid 
         * @param input 
         * @param sessionId 
         */
        userChangePasswordAdmin(params: {  "userGuid": string; "input": PasswordResetAdminModel; "sessionId": string; }, options?: any) {
            return UserApiFp.userChangePasswordAdmin(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        userClaimFreeLetter(params: {  "sessionId": string; }, options?: any) {
            return UserApiFp.userClaimFreeLetter(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         */
        userHttpUserCaptureEmail(params: {  "model": EmailCapture; }, options?: any) {
            return UserApiFp.userHttpUserCaptureEmail(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Initiate a password reset operation.
         * @param input 
         */
        userResetPassword(params: {  "input": PasswordResetModel; }, options?: any) {
            return UserApiFp.userResetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param model 
         */
        userSetEmailPreferences(params: {  "userGuid": string; "model": NhUserEmailPreference; }, options?: any) {
            return UserApiFp.userSetEmailPreferences(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         */
        userSignIn(params: {  "model": UserAuthModel; }, options?: any) {
            return UserApiFp.userSignIn(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         */
        userSignIn3(params: {  "model": UserAuthModel; }, options?: any) {
            return UserApiFp.userSignIn3(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         */
        userSignup(params: {  "model": UserAuthModel; }, options?: any) {
            return UserApiFp.userSignup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         */
        userSignup3(params: {  "model": UserAuthModel; }, options?: any) {
            return UserApiFp.userSignup3(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserAdminApi - fetch parameter creator
 */
export const UserAdminApiFetchParamCreator = {
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminAddressGet(params: {  "userGuid": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminAddressGet");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminAddressGet");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/addresses`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param addressGuid 
     * @param sessionId 
     */
    userAdminAddressGetById(params: {  "addressGuid": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "addressGuid" is set
        if (params["addressGuid"] == null) {
            throw new Error("Missing required parameter addressGuid when calling userAdminAddressGetById");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminAddressGetById");
        }
        const baseUrl = `/api/admin/address/byGuid/{addressGuid}`
            .replace(`{${"addressGuid"}}`, `${ params["addressGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param addressGuid 
     * @param addressModel 
     * @param sessionId 
     */
    userAdminAddressPutById(params: {  "addressGuid": string; "addressModel": NhAddressModel; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "addressGuid" is set
        if (params["addressGuid"] == null) {
            throw new Error("Missing required parameter addressGuid when calling userAdminAddressPutById");
        }
        // verify required parameter "addressModel" is set
        if (params["addressModel"] == null) {
            throw new Error("Missing required parameter addressModel when calling userAdminAddressPutById");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminAddressPutById");
        }
        const baseUrl = `/api/admin/address/byGuid/{addressGuid}`
            .replace(`{${"addressGuid"}}`, `${ params["addressGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["addressModel"]) {
            fetchOptions.body = JSON.stringify(params["addressModel"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     * @param giveLetters 
     */
    userAdminAdminGetWordGame(params: {  "sessionId": string; "userGuid": string; "giveLetters"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminAdminGetWordGame");
        }
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminAdminGetWordGame");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/wordgame`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "giveLetters": params["giveLetters"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminAdminRevokeWordGame(params: {  "userGuid": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminAdminRevokeWordGame");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminAdminRevokeWordGame");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/wordgame`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param comment 
     * @param sessionId 
     */
    userAdminCreateAdminUserComment(params: {  "userGuid": string; "comment": CommentJsonObject; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreateAdminUserComment");
        }
        // verify required parameter "comment" is set
        if (params["comment"] == null) {
            throw new Error("Missing required parameter comment when calling userAdminCreateAdminUserComment");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminCreateAdminUserComment");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/comment`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["comment"]) {
            fetchOptions.body = JSON.stringify(params["comment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param creditGuid 
     * @param sessionId 
     */
    userAdminCreditDelete(params: {  "userGuid": string; "creditGuid": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreditDelete");
        }
        // verify required parameter "creditGuid" is set
        if (params["creditGuid"] == null) {
            throw new Error("Missing required parameter creditGuid when calling userAdminCreditDelete");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminCreditDelete");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/credits/{creditGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"creditGuid"}}`, `${ params["creditGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminCreditGet(params: {  "userGuid": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreditGet");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminCreditGet");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/credits`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param newCredit 
     * @param sessionId 
     */
    userAdminCreditPost(params: {  "userGuid": string; "newCredit": NhCreditModel; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreditPost");
        }
        // verify required parameter "newCredit" is set
        if (params["newCredit"] == null) {
            throw new Error("Missing required parameter newCredit when calling userAdminCreditPost");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminCreditPost");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/credits`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newCredit"]) {
            fetchOptions.body = JSON.stringify(params["newCredit"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param creditGuid 
     * @param credit 
     * @param sessionId 
     */
    userAdminCreditPut(params: {  "userGuid": string; "creditGuid": string; "credit": NhCreditModel; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreditPut");
        }
        // verify required parameter "creditGuid" is set
        if (params["creditGuid"] == null) {
            throw new Error("Missing required parameter creditGuid when calling userAdminCreditPut");
        }
        // verify required parameter "credit" is set
        if (params["credit"] == null) {
            throw new Error("Missing required parameter credit when calling userAdminCreditPut");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminCreditPut");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/credits/{creditGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"creditGuid"}}`, `${ params["creditGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credit"]) {
            fetchOptions.body = JSON.stringify(params["credit"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     * @param needsOutreach 
     */
    userAdminGet(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; "needsOutreach"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminGet");
        }
        const baseUrl = `/api/admin/user/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
            "needsOutreach": params["needsOutreach"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userAdminGetAdminUserExpired(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminGetAdminUserExpired");
        }
        const baseUrl = `/api/admin/user/listExpired`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userAdminGetAdminUserForGiftBox(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminGetAdminUserForGiftBox");
        }
        const baseUrl = `/api/admin/user/forGiftBox`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     */
    userAdminGetById(params: {  "sessionId": string; "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminGetById");
        }
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminGetById");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    userAdminGetUsersbySku(params: {  "sku": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling userAdminGetUsersbySku");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminGetUsersbySku");
        }
        const baseUrl = `/api/admin/user/bySku/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param qty 
     */
    userAdminGiveExtraLettersToUser(params: {  "sessionId": string; "userId": string; "qty": number; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminGiveExtraLettersToUser");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling userAdminGiveExtraLettersToUser");
        }
        // verify required parameter "qty" is set
        if (params["qty"] == null) {
            throw new Error("Missing required parameter qty when calling userAdminGiveExtraLettersToUser");
        }
        const baseUrl = `/api/session/{sessionId}admin/give-extra-letters/{userId}/{qty}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"userId"}}`, `${ params["userId"] }`)
            .replace(`{${"qty"}}`, `${ params["qty"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param claimCodes 
     * @param sessionId 
     */
    userAdminHandleAdminGiftRedeem(params: {  "userGuid": string; "claimCodes": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminHandleAdminGiftRedeem");
        }
        // verify required parameter "claimCodes" is set
        if (params["claimCodes"] == null) {
            throw new Error("Missing required parameter claimCodes when calling userAdminHandleAdminGiftRedeem");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminHandleAdminGiftRedeem");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/redeemGc`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "claimCodes": params["claimCodes"],
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     */
    userAdminHandleAdminUserTicket(params: {  "model": SupportTicket; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userAdminHandleAdminUserTicket");
        }
        const baseUrl = `/api/admin/user/ticket`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userAdminHandleCreditsAboutToExpire(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminHandleCreditsAboutToExpire");
        }
        const baseUrl = `/api/admin/creditsAboutToExpire`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     * @param sessionId 
     */
    userAdminHttpPostAdminUserPush(params: {  "model": AdminUserPushModel; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userAdminHttpPostAdminUserPush");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminHttpPostAdminUserPush");
        }
        const baseUrl = `/api/admin/user/push`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param model 
     * @param sessionId 
     */
    userAdminHttpPutAdminUserPush(params: {  "model": AdminUserPushModel; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userAdminHttpPutAdminUserPush");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminHttpPutAdminUserPush");
        }
        const baseUrl = `/api/admin/user/push`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminListAdminUserComment(params: {  "userGuid": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminListAdminUserComment");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminListAdminUserComment");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/comment`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param oldUserGuid 
     * @param newUserGuid 
     * @param sessionId 
     */
    userAdminMergeUsers(params: {  "oldUserGuid": string; "newUserGuid": string; "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "oldUserGuid" is set
        if (params["oldUserGuid"] == null) {
            throw new Error("Missing required parameter oldUserGuid when calling userAdminMergeUsers");
        }
        // verify required parameter "newUserGuid" is set
        if (params["newUserGuid"] == null) {
            throw new Error("Missing required parameter newUserGuid when calling userAdminMergeUsers");
        }
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminMergeUsers");
        }
        const baseUrl = `/api/admin/user/merge/{oldUserGuid}/into/{newUserGuid}`
            .replace(`{${"oldUserGuid"}}`, `${ params["oldUserGuid"] }`)
            .replace(`{${"newUserGuid"}}`, `${ params["newUserGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     */
    userAdminPaymentsGet(params: {  "sessionId": string; "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminPaymentsGet");
        }
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminPaymentsGet");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/payments`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userAdminPostAdminUserExpired(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminPostAdminUserExpired");
        }
        const baseUrl = `/api/admin/user/listExpired`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     * @param userGuid 
     */
    userAdminPutById(params: {  "sessionId": string; "model": UserModelExtended; "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userAdminPutById");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userAdminPutById");
        }
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminPutById");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sessionId": params["sessionId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserAdminApi - functional programming interface
 */
export const UserAdminApiFp = {
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminAddressGet(params: { "userGuid": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhAddressModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAddressGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param addressGuid 
     * @param sessionId 
     */
    userAdminAddressGetById(params: { "addressGuid": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhAddressModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAddressGetById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param addressGuid 
     * @param addressModel 
     * @param sessionId 
     */
    userAdminAddressPutById(params: { "addressGuid": string; "addressModel": NhAddressModel; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhAddressModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAddressPutById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     * @param giveLetters 
     */
    userAdminAdminGetWordGame(params: { "sessionId": string; "userGuid": string; "giveLetters"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWordGame> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAdminGetWordGame(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminAdminRevokeWordGame(params: { "userGuid": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAdminRevokeWordGame(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param comment 
     * @param sessionId 
     */
    userAdminCreateAdminUserComment(params: { "userGuid": string; "comment": CommentJsonObject; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCommentJsonObject> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreateAdminUserComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param creditGuid 
     * @param sessionId 
     */
    userAdminCreditDelete(params: { "userGuid": string; "creditGuid": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreditDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminCreditGet(params: { "userGuid": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhCreditModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreditGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param newCredit 
     * @param sessionId 
     */
    userAdminCreditPost(params: { "userGuid": string; "newCredit": NhCreditModel; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhCreditModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreditPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param creditGuid 
     * @param credit 
     * @param sessionId 
     */
    userAdminCreditPut(params: { "userGuid": string; "creditGuid": string; "credit": NhCreditModel; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhCreditModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreditPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     * @param needsOutreach 
     */
    userAdminGet(params: { "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; "needsOutreach"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListUserModelExtended> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userAdminGetAdminUserExpired(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListUserSummaryViewRecord> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGetAdminUserExpired(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userAdminGetAdminUserForGiftBox(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhAddressModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGetAdminUserForGiftBox(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     */
    userAdminGetById(params: { "sessionId": string; "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhUserModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGetById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    userAdminGetUsersbySku(params: { "sku": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListNhUserModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGetUsersbySku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param qty 
     */
    userAdminGiveExtraLettersToUser(params: { "sessionId": string; "userId": string; "qty": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGiveExtraLettersToUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param claimCodes 
     * @param sessionId 
     */
    userAdminHandleAdminGiftRedeem(params: { "userGuid": string; "claimCodes": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCheckoutPromoCodeModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminHandleAdminGiftRedeem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     */
    userAdminHandleAdminUserTicket(params: { "model": SupportTicket;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultSupportTicket> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminHandleAdminUserTicket(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userAdminHandleCreditsAboutToExpire(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListMarketingExpiringCredits> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminHandleCreditsAboutToExpire(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     * @param sessionId 
     */
    userAdminHttpPostAdminUserPush(params: { "model": AdminUserPushModel; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultAdminUserPushModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminHttpPostAdminUserPush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param model 
     * @param sessionId 
     */
    userAdminHttpPutAdminUserPush(params: { "model": AdminUserPushModel; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultAdminUserPushModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminHttpPutAdminUserPush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminListAdminUserComment(params: { "userGuid": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListCommentJsonObject> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminListAdminUserComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param oldUserGuid 
     * @param newUserGuid 
     * @param sessionId 
     */
    userAdminMergeUsers(params: { "oldUserGuid": string; "newUserGuid": string; "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminMergeUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     */
    userAdminPaymentsGet(params: { "sessionId": string; "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListApiBillingModelWithCardNumber> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminPaymentsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    userAdminPostAdminUserExpired(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListUserSummaryViewRecord> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminPostAdminUserExpired(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param model 
     * @param userGuid 
     */
    userAdminPutById(params: { "sessionId": string; "model": UserModelExtended; "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultUserModelExtended> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminPutById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserAdminApi - object-oriented interface
 */
export class UserAdminApi extends BaseAPI {
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminAddressGet(params: {  "userGuid": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminAddressGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param addressGuid 
     * @param sessionId 
     */
    userAdminAddressGetById(params: {  "addressGuid": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminAddressGetById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param addressGuid 
     * @param addressModel 
     * @param sessionId 
     */
    userAdminAddressPutById(params: {  "addressGuid": string; "addressModel": NhAddressModel; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminAddressPutById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     * @param giveLetters 
     */
    userAdminAdminGetWordGame(params: {  "sessionId": string; "userGuid": string; "giveLetters"?: string; }, options?: any) {
        return UserAdminApiFp.userAdminAdminGetWordGame(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminAdminRevokeWordGame(params: {  "userGuid": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminAdminRevokeWordGame(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param comment 
     * @param sessionId 
     */
    userAdminCreateAdminUserComment(params: {  "userGuid": string; "comment": CommentJsonObject; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminCreateAdminUserComment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param creditGuid 
     * @param sessionId 
     */
    userAdminCreditDelete(params: {  "userGuid": string; "creditGuid": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminCreditDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminCreditGet(params: {  "userGuid": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminCreditGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param newCredit 
     * @param sessionId 
     */
    userAdminCreditPost(params: {  "userGuid": string; "newCredit": NhCreditModel; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminCreditPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param creditGuid 
     * @param credit 
     * @param sessionId 
     */
    userAdminCreditPut(params: {  "userGuid": string; "creditGuid": string; "credit": NhCreditModel; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminCreditPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param skip 
     * @param take 
     * @param search 
     * @param needsOutreach 
     */
    userAdminGet(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; "needsOutreach"?: boolean; }, options?: any) {
        return UserAdminApiFp.userAdminGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    userAdminGetAdminUserExpired(params: {  "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminGetAdminUserExpired(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    userAdminGetAdminUserForGiftBox(params: {  "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminGetAdminUserForGiftBox(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     */
    userAdminGetById(params: {  "sessionId": string; "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminGetById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sku 
     * @param sessionId 
     */
    userAdminGetUsersbySku(params: {  "sku": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminGetUsersbySku(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param userId 
     * @param qty 
     */
    userAdminGiveExtraLettersToUser(params: {  "sessionId": string; "userId": string; "qty": number; }, options?: any) {
        return UserAdminApiFp.userAdminGiveExtraLettersToUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param claimCodes 
     * @param sessionId 
     */
    userAdminHandleAdminGiftRedeem(params: {  "userGuid": string; "claimCodes": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminHandleAdminGiftRedeem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     */
    userAdminHandleAdminUserTicket(params: {  "model": SupportTicket; }, options?: any) {
        return UserAdminApiFp.userAdminHandleAdminUserTicket(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    userAdminHandleCreditsAboutToExpire(params: {  "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminHandleCreditsAboutToExpire(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     * @param sessionId 
     */
    userAdminHttpPostAdminUserPush(params: {  "model": AdminUserPushModel; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminHttpPostAdminUserPush(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param model 
     * @param sessionId 
     */
    userAdminHttpPutAdminUserPush(params: {  "model": AdminUserPushModel; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminHttpPutAdminUserPush(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     * @param sessionId 
     */
    userAdminListAdminUserComment(params: {  "userGuid": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminListAdminUserComment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param oldUserGuid 
     * @param newUserGuid 
     * @param sessionId 
     */
    userAdminMergeUsers(params: {  "oldUserGuid": string; "newUserGuid": string; "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminMergeUsers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param userGuid 
     */
    userAdminPaymentsGet(params: {  "sessionId": string; "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminPaymentsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    userAdminPostAdminUserExpired(params: {  "sessionId": string; }, options?: any) {
        return UserAdminApiFp.userAdminPostAdminUserExpired(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param model 
     * @param userGuid 
     */
    userAdminPutById(params: {  "sessionId": string; "model": UserModelExtended; "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminPutById(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserAdminApi - factory interface
 */
export const UserAdminApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param userGuid 
         * @param sessionId 
         */
        userAdminAddressGet(params: {  "userGuid": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminAddressGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param addressGuid 
         * @param sessionId 
         */
        userAdminAddressGetById(params: {  "addressGuid": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminAddressGetById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param addressGuid 
         * @param addressModel 
         * @param sessionId 
         */
        userAdminAddressPutById(params: {  "addressGuid": string; "addressModel": NhAddressModel; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminAddressPutById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param userGuid 
         * @param giveLetters 
         */
        userAdminAdminGetWordGame(params: {  "sessionId": string; "userGuid": string; "giveLetters"?: string; }, options?: any) {
            return UserAdminApiFp.userAdminAdminGetWordGame(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param sessionId 
         */
        userAdminAdminRevokeWordGame(params: {  "userGuid": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminAdminRevokeWordGame(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param comment 
         * @param sessionId 
         */
        userAdminCreateAdminUserComment(params: {  "userGuid": string; "comment": CommentJsonObject; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminCreateAdminUserComment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param creditGuid 
         * @param sessionId 
         */
        userAdminCreditDelete(params: {  "userGuid": string; "creditGuid": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminCreditDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param sessionId 
         */
        userAdminCreditGet(params: {  "userGuid": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminCreditGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param newCredit 
         * @param sessionId 
         */
        userAdminCreditPost(params: {  "userGuid": string; "newCredit": NhCreditModel; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminCreditPost(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param creditGuid 
         * @param credit 
         * @param sessionId 
         */
        userAdminCreditPut(params: {  "userGuid": string; "creditGuid": string; "credit": NhCreditModel; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminCreditPut(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param skip 
         * @param take 
         * @param search 
         * @param needsOutreach 
         */
        userAdminGet(params: {  "sessionId": string; "skip"?: number; "take"?: number; "search"?: string; "needsOutreach"?: boolean; }, options?: any) {
            return UserAdminApiFp.userAdminGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        userAdminGetAdminUserExpired(params: {  "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminGetAdminUserExpired(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        userAdminGetAdminUserForGiftBox(params: {  "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminGetAdminUserForGiftBox(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param userGuid 
         */
        userAdminGetById(params: {  "sessionId": string; "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminGetById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sku 
         * @param sessionId 
         */
        userAdminGetUsersbySku(params: {  "sku": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminGetUsersbySku(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param userId 
         * @param qty 
         */
        userAdminGiveExtraLettersToUser(params: {  "sessionId": string; "userId": string; "qty": number; }, options?: any) {
            return UserAdminApiFp.userAdminGiveExtraLettersToUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param claimCodes 
         * @param sessionId 
         */
        userAdminHandleAdminGiftRedeem(params: {  "userGuid": string; "claimCodes": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminHandleAdminGiftRedeem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         */
        userAdminHandleAdminUserTicket(params: {  "model": SupportTicket; }, options?: any) {
            return UserAdminApiFp.userAdminHandleAdminUserTicket(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        userAdminHandleCreditsAboutToExpire(params: {  "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminHandleCreditsAboutToExpire(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         * @param sessionId 
         */
        userAdminHttpPostAdminUserPush(params: {  "model": AdminUserPushModel; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminHttpPostAdminUserPush(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param model 
         * @param sessionId 
         */
        userAdminHttpPutAdminUserPush(params: {  "model": AdminUserPushModel; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminHttpPutAdminUserPush(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         * @param sessionId 
         */
        userAdminListAdminUserComment(params: {  "userGuid": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminListAdminUserComment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param oldUserGuid 
         * @param newUserGuid 
         * @param sessionId 
         */
        userAdminMergeUsers(params: {  "oldUserGuid": string; "newUserGuid": string; "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminMergeUsers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param userGuid 
         */
        userAdminPaymentsGet(params: {  "sessionId": string; "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminPaymentsGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        userAdminPostAdminUserExpired(params: {  "sessionId": string; }, options?: any) {
            return UserAdminApiFp.userAdminPostAdminUserExpired(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param model 
         * @param userGuid 
         */
        userAdminPutById(params: {  "sessionId": string; "model": UserModelExtended; "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminPutById(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserCreditApi - fetch parameter creator
 */
export const UserCreditApiFetchParamCreator = {
    /**
     * 
     * @param userGuid 
     */
    userCreditGet(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userCreditGet");
        }
        const baseUrl = `/api/user/{userGuid}/credit`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param userGuid 
     */
    userCreditGetTransactions(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userCreditGetTransactions");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/transactions/list`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserCreditApi - functional programming interface
 */
export const UserCreditApiFp = {
    /**
     * 
     * @param userGuid 
     */
    userCreditGet(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserCreditApiFetchParamCreator.userCreditGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param userGuid 
     */
    userCreditGetTransactions(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserCreditApiFetchParamCreator.userCreditGetTransactions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserCreditApi - object-oriented interface
 */
export class UserCreditApi extends BaseAPI {
    /**
     * 
     * @param userGuid 
     */
    userCreditGet(params: {  "userGuid": string; }, options?: any) {
        return UserCreditApiFp.userCreditGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param userGuid 
     */
    userCreditGetTransactions(params: {  "userGuid": string; }, options?: any) {
        return UserCreditApiFp.userCreditGetTransactions(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserCreditApi - factory interface
 */
export const UserCreditApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param userGuid 
         */
        userCreditGet(params: {  "userGuid": string; }, options?: any) {
            return UserCreditApiFp.userCreditGet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param userGuid 
         */
        userCreditGetTransactions(params: {  "userGuid": string; }, options?: any) {
            return UserCreditApiFp.userCreditGetTransactions(params, options)(fetch, basePath);
        },
    };
};


/**
 * V2GroupApi - fetch parameter creator
 */
export const V2GroupApiFetchParamCreator = {
    /**
     * 
     * @param content 
     */
    v2GroupDelete(params: {  "content": Array<GroupItemEntity>; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling v2GroupDelete");
        }
        const baseUrl = `/api/v2/admin/grouping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    v2GroupGet(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/grouping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param id 
     */
    v2GroupGet_1(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling v2GroupGet_1");
        }
        const baseUrl = `/api/v2/admin/grouping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param content 
     */
    v2GroupPost(params: {  "content": Array<GroupItemEntity>; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling v2GroupPost");
        }
        const baseUrl = `/api/v2/admin/grouping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param content 
     */
    v2GroupPut(params: {  "content": Array<GroupItemEntity>; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling v2GroupPut");
        }
        const baseUrl = `/api/v2/admin/grouping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * V2GroupApi - functional programming interface
 */
export const V2GroupApiFp = {
    /**
     * 
     * @param content 
     */
    v2GroupDelete(params: { "content": Array<GroupItemEntity>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    v2GroupGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupItemEntity>> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param id 
     */
    v2GroupGet_1(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupItemEntity> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param content 
     */
    v2GroupPost(params: { "content": Array<GroupItemEntity>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupItemEntity>> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param content 
     */
    v2GroupPut(params: { "content": Array<GroupItemEntity>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupItemEntity>> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * V2GroupApi - object-oriented interface
 */
export class V2GroupApi extends BaseAPI {
    /**
     * 
     * @param content 
     */
    v2GroupDelete(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
        return V2GroupApiFp.v2GroupDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    v2GroupGet(options?: any) {
        return V2GroupApiFp.v2GroupGet(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param id 
     */
    v2GroupGet_1(params: {  "id": string; }, options?: any) {
        return V2GroupApiFp.v2GroupGet_1(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param content 
     */
    v2GroupPost(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
        return V2GroupApiFp.v2GroupPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param content 
     */
    v2GroupPut(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
        return V2GroupApiFp.v2GroupPut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * V2GroupApi - factory interface
 */
export const V2GroupApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param content 
         */
        v2GroupDelete(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
            return V2GroupApiFp.v2GroupDelete(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        v2GroupGet(options?: any) {
            return V2GroupApiFp.v2GroupGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param id 
         */
        v2GroupGet_1(params: {  "id": string; }, options?: any) {
            return V2GroupApiFp.v2GroupGet_1(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param content 
         */
        v2GroupPost(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
            return V2GroupApiFp.v2GroupPost(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param content 
         */
        v2GroupPut(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
            return V2GroupApiFp.v2GroupPut(params, options)(fetch, basePath);
        },
    };
};


/**
 * WineGeniusApi - fetch parameter creator
 */
export const WineGeniusApiFetchParamCreator = {
    /**
     * 
     * @summary Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusDeleteSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusDeleteSessionOfferReservation");
        }
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling wineGeniusDeleteSessionOfferReservation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/picks/forOffer/{offerSef}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusGetSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusGetSessionOfferReservation");
        }
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling wineGeniusGetSessionOfferReservation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/picks/forOffer/{offerSef}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    wineGeniusGetSessionWineGeniusData(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusGetSessionWineGeniusData");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/data`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     */
    wineGeniusGetWineGeniusUsersForOffer(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling wineGeniusGetWineGeniusUsersForOffer");
        }
        const baseUrl = `/api/v3/admin/genius/{offerSef}/orders`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    wineGeniusHandleGetMessages(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusHandleGetMessages");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/message`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param vacationDateSet 
     * @param vacationSuspendOn 
     * @param vacationResumeOn 
     * @param vacationVacationGuid 
     */
    wineGeniusHandleGetVacation(params: {  "sessionId": string; "vacationDateSet"?: Date; "vacationSuspendOn"?: Date; "vacationResumeOn"?: Date; "vacationVacationGuid"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusHandleGetVacation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/vacation`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "vacation.dateSet": params["vacationDateSet"],
            "vacation.suspendOn": params["vacationSuspendOn"],
            "vacation.resumeOn": params["vacationResumeOn"],
            "vacation.vacationGuid": params["vacationVacationGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param message 
     */
    wineGeniusHandlePostMessage(params: {  "sessionId": string; "message": WineGeniusMessage; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusHandlePostMessage");
        }
        // verify required parameter "message" is set
        if (params["message"] == null) {
            throw new Error("Missing required parameter message when calling wineGeniusHandlePostMessage");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/message`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["message"]) {
            fetchOptions.body = JSON.stringify(params["message"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param vacation 
     */
    wineGeniusHandlePostVacation(params: {  "sessionId": string; "vacation": WineGeniusVacation; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusHandlePostVacation");
        }
        // verify required parameter "vacation" is set
        if (params["vacation"] == null) {
            throw new Error("Missing required parameter vacation when calling wineGeniusHandlePostVacation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/vacation`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vacation"]) {
            fetchOptions.body = JSON.stringify(params["vacation"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     */
    wineGeniusListSessionOfferReservation(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusListSessionOfferReservation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/picks/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param offerSef 
     * @param model 
     */
    wineGeniusPostWineGeniusIncludeOrExclude(params: {  "offerSef": string; "model": GeniusExcl; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling wineGeniusPostWineGeniusIncludeOrExclude");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling wineGeniusPostWineGeniusIncludeOrExclude");
        }
        const baseUrl = `/api/v3/admin/genius/{offerSef}/orders`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusPutSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusPutSessionOfferReservation");
        }
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling wineGeniusPutSessionOfferReservation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/picks/forOffer/{offerSef}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param data 
     */
    wineGeniusSetSessionWineGeniusData(params: {  "sessionId": string; "data": WineGeniusData; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusSetSessionWineGeniusData");
        }
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling wineGeniusSetSessionWineGeniusData");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/data`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param sessionId 
     * @param postData 
     */
    wineGeniusWineGeniusPost(params: {  "sessionId": string; "postData": WineGeniusData; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusWineGeniusPost");
        }
        // verify required parameter "postData" is set
        if (params["postData"] == null) {
            throw new Error("Missing required parameter postData when calling wineGeniusWineGeniusPost");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/survey`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["postData"]) {
            fetchOptions.body = JSON.stringify(params["postData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * WineGeniusApi - functional programming interface
 */
export const WineGeniusApiFp = {
    /**
     * 
     * @summary Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusDeleteSessionOfferReservation(params: { "sessionId": string; "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListOrderGeniusState> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusDeleteSessionOfferReservation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusGetSessionOfferReservation(params: { "sessionId": string; "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListOrderGeniusState> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusGetSessionOfferReservation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    wineGeniusGetSessionWineGeniusData(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWineGeniusData> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusGetSessionWineGeniusData(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     */
    wineGeniusGetWineGeniusUsersForOffer(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListGeniusGuess> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusGetWineGeniusUsersForOffer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    wineGeniusHandleGetMessages(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListWineGeniusMessage> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusHandleGetMessages(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param vacationDateSet 
     * @param vacationSuspendOn 
     * @param vacationResumeOn 
     * @param vacationVacationGuid 
     */
    wineGeniusHandleGetVacation(params: { "sessionId": string; "vacationDateSet"?: Date; "vacationSuspendOn"?: Date; "vacationResumeOn"?: Date; "vacationVacationGuid"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListWineGeniusVacation> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusHandleGetVacation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param message 
     */
    wineGeniusHandlePostMessage(params: { "sessionId": string; "message": WineGeniusMessage;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWineGeniusMessage> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusHandlePostMessage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param vacation 
     */
    wineGeniusHandlePostVacation(params: { "sessionId": string; "vacation": WineGeniusVacation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWineGeniusVacation> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusHandlePostVacation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     */
    wineGeniusListSessionOfferReservation(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListOrderGeniusState> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusListSessionOfferReservation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param offerSef 
     * @param model 
     */
    wineGeniusPostWineGeniusIncludeOrExclude(params: { "offerSef": string; "model": GeniusExcl;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultGeniusExcl> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusPostWineGeniusIncludeOrExclude(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusPutSessionOfferReservation(params: { "sessionId": string; "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListOrderGeniusState> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusPutSessionOfferReservation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param data 
     */
    wineGeniusSetSessionWineGeniusData(params: { "sessionId": string; "data": WineGeniusData;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWineGeniusData> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusSetSessionWineGeniusData(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param sessionId 
     * @param postData 
     */
    wineGeniusWineGeniusPost(params: { "sessionId": string; "postData": WineGeniusData;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWineGeniusData> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusWineGeniusPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * WineGeniusApi - object-oriented interface
 */
export class WineGeniusApi extends BaseAPI {
    /**
     * 
     * @summary Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusDeleteSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusDeleteSessionOfferReservation(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusGetSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusGetSessionOfferReservation(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    wineGeniusGetSessionWineGeniusData(params: {  "sessionId": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusGetSessionWineGeniusData(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     */
    wineGeniusGetWineGeniusUsersForOffer(params: {  "offerSef": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusGetWineGeniusUsersForOffer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    wineGeniusHandleGetMessages(params: {  "sessionId": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusHandleGetMessages(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param vacationDateSet 
     * @param vacationSuspendOn 
     * @param vacationResumeOn 
     * @param vacationVacationGuid 
     */
    wineGeniusHandleGetVacation(params: {  "sessionId": string; "vacationDateSet"?: Date; "vacationSuspendOn"?: Date; "vacationResumeOn"?: Date; "vacationVacationGuid"?: string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusHandleGetVacation(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param message 
     */
    wineGeniusHandlePostMessage(params: {  "sessionId": string; "message": WineGeniusMessage; }, options?: any) {
        return WineGeniusApiFp.wineGeniusHandlePostMessage(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param vacation 
     */
    wineGeniusHandlePostVacation(params: {  "sessionId": string; "vacation": WineGeniusVacation; }, options?: any) {
        return WineGeniusApiFp.wineGeniusHandlePostVacation(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     */
    wineGeniusListSessionOfferReservation(params: {  "sessionId": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusListSessionOfferReservation(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param offerSef 
     * @param model 
     */
    wineGeniusPostWineGeniusIncludeOrExclude(params: {  "offerSef": string; "model": GeniusExcl; }, options?: any) {
        return WineGeniusApiFp.wineGeniusPostWineGeniusIncludeOrExclude(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusPutSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusPutSessionOfferReservation(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param data 
     */
    wineGeniusSetSessionWineGeniusData(params: {  "sessionId": string; "data": WineGeniusData; }, options?: any) {
        return WineGeniusApiFp.wineGeniusSetSessionWineGeniusData(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param sessionId 
     * @param postData 
     */
    wineGeniusWineGeniusPost(params: {  "sessionId": string; "postData": WineGeniusData; }, options?: any) {
        return WineGeniusApiFp.wineGeniusWineGeniusPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * WineGeniusApi - factory interface
 */
export const WineGeniusApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Reveals the allocated items for an order, and finalizes the order.
         * @param sessionId 
         * @param offerSef 
         */
        wineGeniusDeleteSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusDeleteSessionOfferReservation(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param offerSef 
         */
        wineGeniusGetSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusGetSessionOfferReservation(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        wineGeniusGetSessionWineGeniusData(params: {  "sessionId": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusGetSessionWineGeniusData(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         */
        wineGeniusGetWineGeniusUsersForOffer(params: {  "offerSef": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusGetWineGeniusUsersForOffer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        wineGeniusHandleGetMessages(params: {  "sessionId": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusHandleGetMessages(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param vacationDateSet 
         * @param vacationSuspendOn 
         * @param vacationResumeOn 
         * @param vacationVacationGuid 
         */
        wineGeniusHandleGetVacation(params: {  "sessionId": string; "vacationDateSet"?: Date; "vacationSuspendOn"?: Date; "vacationResumeOn"?: Date; "vacationVacationGuid"?: string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusHandleGetVacation(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param message 
         */
        wineGeniusHandlePostMessage(params: {  "sessionId": string; "message": WineGeniusMessage; }, options?: any) {
            return WineGeniusApiFp.wineGeniusHandlePostMessage(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param vacation 
         */
        wineGeniusHandlePostVacation(params: {  "sessionId": string; "vacation": WineGeniusVacation; }, options?: any) {
            return WineGeniusApiFp.wineGeniusHandlePostVacation(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         */
        wineGeniusListSessionOfferReservation(params: {  "sessionId": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusListSessionOfferReservation(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param offerSef 
         * @param model 
         */
        wineGeniusPostWineGeniusIncludeOrExclude(params: {  "offerSef": string; "model": GeniusExcl; }, options?: any) {
            return WineGeniusApiFp.wineGeniusPostWineGeniusIncludeOrExclude(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reveals the allocated items for an order, and finalizes the order.
         * @param sessionId 
         * @param offerSef 
         */
        wineGeniusPutSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusPutSessionOfferReservation(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param data 
         */
        wineGeniusSetSessionWineGeniusData(params: {  "sessionId": string; "data": WineGeniusData; }, options?: any) {
            return WineGeniusApiFp.wineGeniusSetSessionWineGeniusData(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param sessionId 
         * @param postData 
         */
        wineGeniusWineGeniusPost(params: {  "sessionId": string; "postData": WineGeniusData; }, options?: any) {
            return WineGeniusApiFp.wineGeniusWineGeniusPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * WineryApi - fetch parameter creator
 */
export const WineryApiFetchParamCreator = {
    /**
     * 
     * @summary Gets a winery by its id.
     * @param winerySef 
     */
    wineryHandleGetWinery(params: {  "winerySef": string; }, options?: any): FetchArgs {
        // verify required parameter "winerySef" is set
        if (params["winerySef"] == null) {
            throw new Error("Missing required parameter winerySef when calling wineryHandleGetWinery");
        }
        const baseUrl = `/api/v2/winery/{winerySef}`
            .replace(`{${"winerySef"}}`, `${ params["winerySef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets the list of wineries.
     * @param skip 
     * @param take 
     * @param filter 
     * @param search 
     */
    wineryHandleListWinery(params: {  "skip"?: number; "take"?: number; "filter"?: string; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/winery`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "filter": params["filter"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Gets the list of wines made by a winery.
     * @param winerySef 
     */
    wineryHandleListWinery_1(params: {  "winerySef": string; }, options?: any): FetchArgs {
        // verify required parameter "winerySef" is set
        if (params["winerySef"] == null) {
            throw new Error("Missing required parameter winerySef when calling wineryHandleListWinery_1");
        }
        const baseUrl = `/api/v2/winery/{winerySef}/items`
            .replace(`{${"winerySef"}}`, `${ params["winerySef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new winery.
     * @param winery 
     */
    wineryHandlePostWinery(params: {  "winery": WineryModel; }, options?: any): FetchArgs {
        // verify required parameter "winery" is set
        if (params["winery"] == null) {
            throw new Error("Missing required parameter winery when calling wineryHandlePostWinery");
        }
        const baseUrl = `/api/v2/winery`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["winery"]) {
            fetchOptions.body = JSON.stringify(params["winery"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Updates an existing winery.
     * @param winerySef 
     * @param winery 
     */
    wineryHandlePutWinery(params: {  "winerySef": string; "winery": WineryModel; }, options?: any): FetchArgs {
        // verify required parameter "winerySef" is set
        if (params["winerySef"] == null) {
            throw new Error("Missing required parameter winerySef when calling wineryHandlePutWinery");
        }
        // verify required parameter "winery" is set
        if (params["winery"] == null) {
            throw new Error("Missing required parameter winery when calling wineryHandlePutWinery");
        }
        const baseUrl = `/api/v2/winery/{winerySef}`
            .replace(`{${"winerySef"}}`, `${ params["winerySef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["winery"]) {
            fetchOptions.body = JSON.stringify(params["winery"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * WineryApi - functional programming interface
 */
export const WineryApiFp = {
    /**
     * 
     * @summary Gets a winery by its id.
     * @param winerySef 
     */
    wineryHandleGetWinery(params: { "winerySef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWineryModel> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandleGetWinery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets the list of wineries.
     * @param skip 
     * @param take 
     * @param filter 
     * @param search 
     */
    wineryHandleListWinery(params: { "skip"?: number; "take"?: number; "filter"?: string; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListWineryModel> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandleListWinery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Gets the list of wines made by a winery.
     * @param winerySef 
     */
    wineryHandleListWinery_1(params: { "winerySef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultListWineryModel> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandleListWinery_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new winery.
     * @param winery 
     */
    wineryHandlePostWinery(params: { "winery": WineryModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWineryModel> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandlePostWinery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Updates an existing winery.
     * @param winerySef 
     * @param winery 
     */
    wineryHandlePutWinery(params: { "winerySef": string; "winery": WineryModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultWineryModel> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandlePutWinery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * WineryApi - object-oriented interface
 */
export class WineryApi extends BaseAPI {
    /**
     * 
     * @summary Gets a winery by its id.
     * @param winerySef 
     */
    wineryHandleGetWinery(params: {  "winerySef": string; }, options?: any) {
        return WineryApiFp.wineryHandleGetWinery(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets the list of wineries.
     * @param skip 
     * @param take 
     * @param filter 
     * @param search 
     */
    wineryHandleListWinery(params: {  "skip"?: number; "take"?: number; "filter"?: string; "search"?: string; }, options?: any) {
        return WineryApiFp.wineryHandleListWinery(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Gets the list of wines made by a winery.
     * @param winerySef 
     */
    wineryHandleListWinery_1(params: {  "winerySef": string; }, options?: any) {
        return WineryApiFp.wineryHandleListWinery_1(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new winery.
     * @param winery 
     */
    wineryHandlePostWinery(params: {  "winery": WineryModel; }, options?: any) {
        return WineryApiFp.wineryHandlePostWinery(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Updates an existing winery.
     * @param winerySef 
     * @param winery 
     */
    wineryHandlePutWinery(params: {  "winerySef": string; "winery": WineryModel; }, options?: any) {
        return WineryApiFp.wineryHandlePutWinery(params, options)(this.fetch, this.basePath);
    }
};

/**
 * WineryApi - factory interface
 */
export const WineryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Gets a winery by its id.
         * @param winerySef 
         */
        wineryHandleGetWinery(params: {  "winerySef": string; }, options?: any) {
            return WineryApiFp.wineryHandleGetWinery(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the list of wineries.
         * @param skip 
         * @param take 
         * @param filter 
         * @param search 
         */
        wineryHandleListWinery(params: {  "skip"?: number; "take"?: number; "filter"?: string; "search"?: string; }, options?: any) {
            return WineryApiFp.wineryHandleListWinery(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the list of wines made by a winery.
         * @param winerySef 
         */
        wineryHandleListWinery_1(params: {  "winerySef": string; }, options?: any) {
            return WineryApiFp.wineryHandleListWinery_1(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new winery.
         * @param winery 
         */
        wineryHandlePostWinery(params: {  "winery": WineryModel; }, options?: any) {
            return WineryApiFp.wineryHandlePostWinery(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing winery.
         * @param winerySef 
         * @param winery 
         */
        wineryHandlePutWinery(params: {  "winerySef": string; "winery": WineryModel; }, options?: any) {
            return WineryApiFp.wineryHandlePutWinery(params, options)(fetch, basePath);
        },
    };
};

