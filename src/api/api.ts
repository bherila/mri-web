/**
 * ideal MRI
 * Signup Center API
 *
 * OpenAPI spec version: v1
 * Contact: ben@herila.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://mrisched.azurewebsites.net".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface Appointment {
    "appointmentId"?: string;
    "appointmentSlotId"?: string;
    "serviceType"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "dob"?: string;
    "phone"?: string;
    "email"?: string;
    "address1"?: string;
    "city"?: string;
    "state"?: string;
    "zip"?: string;
    "height"?: string;
    "weight"?: string;
    "reminder"?: number;
    "doctorName"?: string;
    "doctorPhone"?: string;
    "insuranceCarrier"?: string;
    "insuranceGroupNumber"?: string;
    "insurancePolicyNumber"?: string;
    "insuranceVerified"?: boolean;
    "priorAuthObtained"?: boolean;
    "orderEnteredToRIS"?: boolean;
    "patientWasCalled"?: boolean;
    "confirmed"?: boolean;
    "orderImageUrl"?: string;
    "insuranceFrontUrl"?: string;
    "insuranceBackUrl"?: string;
    "surveyDataJson"?: string;
    "approvedDate"?: Date;
    "submittedDate"?: Date;
    "confirmedDate"?: Date;
    "birthday"?: Date;
    "partitionKey"?: string;
    "rowKey"?: string;
    "timestamp"?: Date;
    "eTag"?: string;
}

export interface CustomerLead {
    "firstName"?: string;
    "lastName"?: string;
    "dob"?: string;
    "phone"?: string;
    "email"?: string;
    "serviceType"?: string;
    "timeSlot"?: string;
    "withContrast"?: boolean;
    "partitionKey"?: string;
    "rowKey"?: string;
    "timestamp"?: Date;
    "eTag"?: string;
}

export interface DayRule {
    "dayOfWeek"?: DayRuleDayOfWeekEnum;
    "openTime"?: number;
    "closeTime"?: number;
    "slotLength"?: number;
}

export type DayRuleDayOfWeekEnum = "Sunday" | "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday";
export interface Location {
    "locationName"?: string;
    "partitionKey"?: string;
    "rowKey"?: string;
    "timestamp"?: Date;
    "eTag"?: string;
}

export interface SlotAvailabilityDate {
    "date"?: Date;
    "friendlyBegin"?: string;
    "times"?: Array<SlotAvailabilityTime>;
}

export interface SlotAvailabilityTime {
    "time"?: string;
    "isAvailable"?: boolean;
    "linkedAppointment"?: Appointment;
    "slotId"?: string;
}

export interface SurveyQuestion {
    "questionId"?: string;
    "questionShowIf"?: string;
    "questionShowIfAnswer"?: string;
    "questionText"?: string;
    "questionType"?: string;
    "isRequired"?: boolean;
    "isHidden"?: boolean;
    "order"?: number;
    "partitionKey"?: string;
    "rowKey"?: string;
    "timestamp"?: Date;
    "eTag"?: string;
}

export interface TableResult {
    "result"?: any;
    "httpStatusCode"?: number;
    "etag"?: string;
}

export interface User {
    "apiKey"?: string;
    "immutableId"?: string;
    "referenceRowKey"?: string;
    "partitionKey"?: string;
    "rowKey"?: string;
    "timestamp"?: Date;
    "eTag"?: string;
}



/**
 * AuthApi - fetch parameter creator
 */
export const AuthApiFetchParamCreator = {
    /**
     *
     * @summary Auth
     * @param req
     * @param authToken
     */
    auth(params: {  "req"?: User; "authToken"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/auth`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "authToken": params["authToken"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = {
    /**
     *
     * @summary Auth
     * @param req
     * @param authToken
     */
    auth(params: { "req"?: User; "authToken"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = AuthApiFetchParamCreator.auth(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     *
     * @summary Auth
     * @param req
     * @param authToken
     */
    auth(params: {  "req"?: User; "authToken"?: string; }, options?: any) {
        return AuthApiFp.auth(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Auth
         * @param req
         * @param authToken
         */
        auth(params: {  "req"?: User; "authToken"?: string; }, options?: any) {
            return AuthApiFp.auth(params, options)(fetch, basePath);
        },
    };
};


/**
 * LeadGenApi - fetch parameter creator
 */
export const LeadGenApiFetchParamCreator = {
    /**
     *
     * @summary Run
     * @param req
     * @param authToken
     */
    runGET(params: {  "req"?: Appointment; "authToken"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/leadGen`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "authToken": params["authToken"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Run
     * @param req
     * @param authToken
     */
    runPOST(params: {  "req"?: Appointment; "authToken"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/leadGen`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "authToken": params["authToken"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LeadGenApi - functional programming interface
 */
export const LeadGenApiFp = {
    /**
     *
     * @summary Run
     * @param req
     * @param authToken
     */
    runGET(params: { "req"?: Appointment; "authToken"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerLead> {
        const fetchArgs = LeadGenApiFetchParamCreator.runGET(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Run
     * @param req
     * @param authToken
     */
    runPOST(params: { "req"?: Appointment; "authToken"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerLead> {
        const fetchArgs = LeadGenApiFetchParamCreator.runPOST(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LeadGenApi - object-oriented interface
 */
export class LeadGenApi extends BaseAPI {
    /**
     *
     * @summary Run
     * @param req
     * @param authToken
     */
    runGET(params: {  "req"?: Appointment; "authToken"?: string; }, options?: any) {
        return LeadGenApiFp.runGET(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Run
     * @param req
     * @param authToken
     */
    runPOST(params: {  "req"?: Appointment; "authToken"?: string; }, options?: any) {
        return LeadGenApiFp.runPOST(params, options)(this.fetch, this.basePath);
    }
};

/**
 * LeadGenApi - factory interface
 */
export const LeadGenApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Run
         * @param req
         * @param authToken
         */
        runGET(params: {  "req"?: Appointment; "authToken"?: string; }, options?: any) {
            return LeadGenApiFp.runGET(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Run
         * @param req
         * @param authToken
         */
        runPOST(params: {  "req"?: Appointment; "authToken"?: string; }, options?: any) {
            return LeadGenApiFp.runPOST(params, options)(fetch, basePath);
        },
    };
};


/**
 * LocationApi - fetch parameter creator
 */
export const LocationApiFetchParamCreator = {
    /**
     *
     * @summary Locations
     * @param locationId
     */
    locationsGET(params: {  "locationId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/locations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "locationId": params["locationId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Locations
     * @param locationId
     */
    locationsPOST(params: {  "locationId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/locations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "locationId": params["locationId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = {
    /**
     *
     * @summary Locations
     * @param locationId
     */
    locationsGET(params: { "locationId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Location>> {
        const fetchArgs = LocationApiFetchParamCreator.locationsGET(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Locations
     * @param locationId
     */
    locationsPOST(params: { "locationId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Location>> {
        const fetchArgs = LocationApiFetchParamCreator.locationsPOST(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     *
     * @summary Locations
     * @param locationId
     */
    locationsGET(params: {  "locationId"?: string; }, options?: any) {
        return LocationApiFp.locationsGET(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Locations
     * @param locationId
     */
    locationsPOST(params: {  "locationId"?: string; }, options?: any) {
        return LocationApiFp.locationsPOST(params, options)(this.fetch, this.basePath);
    }
};

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Locations
         * @param locationId
         */
        locationsGET(params: {  "locationId"?: string; }, options?: any) {
            return LocationApiFp.locationsGET(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Locations
         * @param locationId
         */
        locationsPOST(params: {  "locationId"?: string; }, options?: any) {
            return LocationApiFp.locationsPOST(params, options)(fetch, basePath);
        },
    };
};


/**
 * PostQuestionApi - fetch parameter creator
 */
export const PostQuestionApiFetchParamCreator = {
    /**
     *
     * @summary GetQuestions
     * @param req
     */
    postQuestion(params: {  "req"?: SurveyQuestion; }, options?: any): FetchArgs {
        const baseUrl = `/api/question`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PostQuestionApi - functional programming interface
 */
export const PostQuestionApiFp = {
    /**
     *
     * @summary GetQuestions
     * @param req
     */
    postQuestion(params: { "req"?: SurveyQuestion;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TableResult> {
        const fetchArgs = PostQuestionApiFetchParamCreator.postQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PostQuestionApi - object-oriented interface
 */
export class PostQuestionApi extends BaseAPI {
    /**
     *
     * @summary GetQuestions
     * @param req
     */
    postQuestion(params: {  "req"?: SurveyQuestion; }, options?: any) {
        return PostQuestionApiFp.postQuestion(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PostQuestionApi - factory interface
 */
export const PostQuestionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary GetQuestions
         * @param req
         */
        postQuestion(params: {  "req"?: SurveyQuestion; }, options?: any) {
            return PostQuestionApiFp.postQuestion(params, options)(fetch, basePath);
        },
    };
};


/**
 * QuestionApi - fetch parameter creator
 */
export const QuestionApiFetchParamCreator = {
    /**
     *
     * @summary GetQuestions
     */
    getQuestions(options?: any): FetchArgs {
        const baseUrl = `/api/question`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * QuestionApi - functional programming interface
 */
export const QuestionApiFp = {
    /**
     *
     * @summary GetQuestions
     */
    getQuestions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SurveyQuestion>> {
        const fetchArgs = QuestionApiFetchParamCreator.getQuestions(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * QuestionApi - object-oriented interface
 */
export class QuestionApi extends BaseAPI {
    /**
     *
     * @summary GetQuestions
     */
    getQuestions(options?: any) {
        return QuestionApiFp.getQuestions(options)(this.fetch, this.basePath);
    }
};

/**
 * QuestionApi - factory interface
 */
export const QuestionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary GetQuestions
         */
        getQuestions(options?: any) {
            return QuestionApiFp.getQuestions(options)(fetch, basePath);
        },
    };
};


/**
 * ScheduleApi - fetch parameter creator
 */
export const ScheduleApiFetchParamCreator = {
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesDELETE(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/timeslot/rules`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary AdminRules
     * @param withContrast
     * @param locationId
     */
    adminRulesGET(params: {  "withContrast"?: boolean; "locationId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/timeslot/rules`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesPOST(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/timeslot/rules`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesPUT(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/timeslot/rules`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary TimeSlots
     * @param withContrast
     * @param locationId
     */
    timeSlotsGET(params: {  "withContrast"?: boolean; "locationId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/timeslots`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userScheduleDELETE(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/appointment`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary UserSchedule
     * @param withContrast
     * @param locationId
     * @param search
     */
    userScheduleGET(params: {  "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/appointment`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userSchedulePOST(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/appointment`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userSchedulePUT(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/appointment`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "withContrast": params["withContrast"],
            "locationId": params["locationId"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ScheduleApi - functional programming interface
 */
export const ScheduleApiFp = {
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesDELETE(params: { "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DayRule>> {
        const fetchArgs = ScheduleApiFetchParamCreator.adminRulesDELETE(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary AdminRules
     * @param withContrast
     * @param locationId
     */
    adminRulesGET(params: { "withContrast"?: boolean; "locationId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DayRule>> {
        const fetchArgs = ScheduleApiFetchParamCreator.adminRulesGET(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesPOST(params: { "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DayRule>> {
        const fetchArgs = ScheduleApiFetchParamCreator.adminRulesPOST(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesPUT(params: { "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DayRule>> {
        const fetchArgs = ScheduleApiFetchParamCreator.adminRulesPUT(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary TimeSlots
     * @param withContrast
     * @param locationId
     */
    timeSlotsGET(params: { "withContrast"?: boolean; "locationId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SlotAvailabilityDate>> {
        const fetchArgs = ScheduleApiFetchParamCreator.timeSlotsGET(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userScheduleDELETE(params: { "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Appointment>> {
        const fetchArgs = ScheduleApiFetchParamCreator.userScheduleDELETE(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary UserSchedule
     * @param withContrast
     * @param locationId
     * @param search
     */
    userScheduleGET(params: { "withContrast"?: boolean; "locationId"?: string; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Appointment>> {
        const fetchArgs = ScheduleApiFetchParamCreator.userScheduleGET(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userSchedulePOST(params: { "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Appointment>> {
        const fetchArgs = ScheduleApiFetchParamCreator.userSchedulePOST(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userSchedulePUT(params: { "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Appointment>> {
        const fetchArgs = ScheduleApiFetchParamCreator.userSchedulePUT(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ScheduleApi - object-oriented interface
 */
export class ScheduleApi extends BaseAPI {
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesDELETE(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
        return ScheduleApiFp.adminRulesDELETE(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary AdminRules
     * @param withContrast
     * @param locationId
     */
    adminRulesGET(params: {  "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
        return ScheduleApiFp.adminRulesGET(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesPOST(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
        return ScheduleApiFp.adminRulesPOST(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary AdminRules
     * @param req
     * @param withContrast
     * @param locationId
     */
    adminRulesPUT(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
        return ScheduleApiFp.adminRulesPUT(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary TimeSlots
     * @param withContrast
     * @param locationId
     */
    timeSlotsGET(params: {  "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
        return ScheduleApiFp.timeSlotsGET(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userScheduleDELETE(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any) {
        return ScheduleApiFp.userScheduleDELETE(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary UserSchedule
     * @param withContrast
     * @param locationId
     * @param search
     */
    userScheduleGET(params: {  "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any) {
        return ScheduleApiFp.userScheduleGET(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userSchedulePOST(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any) {
        return ScheduleApiFp.userSchedulePOST(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary UserSchedule
     * @param req
     * @param withContrast
     * @param locationId
     * @param search
     */
    userSchedulePUT(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any) {
        return ScheduleApiFp.userSchedulePUT(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ScheduleApi - factory interface
 */
export const ScheduleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary AdminRules
         * @param req
         * @param withContrast
         * @param locationId
         */
        adminRulesDELETE(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
            return ScheduleApiFp.adminRulesDELETE(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary AdminRules
         * @param withContrast
         * @param locationId
         */
        adminRulesGET(params: {  "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
            return ScheduleApiFp.adminRulesGET(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary AdminRules
         * @param req
         * @param withContrast
         * @param locationId
         */
        adminRulesPOST(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
            return ScheduleApiFp.adminRulesPOST(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary AdminRules
         * @param req
         * @param withContrast
         * @param locationId
         */
        adminRulesPUT(params: {  "req"?: DayRule; "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
            return ScheduleApiFp.adminRulesPUT(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary TimeSlots
         * @param withContrast
         * @param locationId
         */
        timeSlotsGET(params: {  "withContrast"?: boolean; "locationId"?: string; }, options?: any) {
            return ScheduleApiFp.timeSlotsGET(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary UserSchedule
         * @param req
         * @param withContrast
         * @param locationId
         * @param search
         */
        userScheduleDELETE(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any) {
            return ScheduleApiFp.userScheduleDELETE(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary UserSchedule
         * @param withContrast
         * @param locationId
         * @param search
         */
        userScheduleGET(params: {  "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any) {
            return ScheduleApiFp.userScheduleGET(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary UserSchedule
         * @param req
         * @param withContrast
         * @param locationId
         * @param search
         */
        userSchedulePOST(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any) {
            return ScheduleApiFp.userSchedulePOST(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary UserSchedule
         * @param req
         * @param withContrast
         * @param locationId
         * @param search
         */
        userSchedulePUT(params: {  "req"?: Appointment; "withContrast"?: boolean; "locationId"?: string; "search"?: string; }, options?: any) {
            return ScheduleApiFp.userSchedulePUT(params, options)(fetch, basePath);
        },
    };
};

